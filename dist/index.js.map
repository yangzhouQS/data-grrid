{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAKA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAyBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AA+BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAuBA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA6BA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAiBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AACA;AAEA;AAaA;AACA;AACA;AACA;AACA;AAEA;AA2BA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzxCA;AACA;AACA;AACA;AACA;AA4BA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA0EA;AAEA;;;;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACt1CA;AACA;AACA;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAoBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9EA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAKA;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9KA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/IA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1SA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChPA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChJA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpDA;AACA;AAEA;AACA;AAEA;AAaA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjHA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5NA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAcA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClVA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrVA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;ACpBA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/CA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9BA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpLA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9BA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACZA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3HA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA0BA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzFA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9BA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtDA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjBA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzCA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/EA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAsBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChFA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrLA;AACA;AACA;AACA;AAEA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAWA;AACA;AAUA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAQA;AACA;AACA;AAEA;AAEA;AAQA;AACA;AACA;AAEA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7tBA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnCA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3EA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3CA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjDA;AAGA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXA;AACA;AAEA;;;;;;;;;;;;;;;ACoDA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AAkBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAcA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAuBA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AAEA;AAQA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoFA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AAgBA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpgHA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAUA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AAIA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7GA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;AAKA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAGA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnTA;AACA;AACA;AAKA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1OA;AAEA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3JA;AAKA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzEA;AAEA;AAUA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvFA;AAEA;AACA;AAYA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChIA;AAEA;AAEA;AASA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtFA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpKA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AASA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3EA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpFA;AACA;AAEA;AACA;AAEA;AAaA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxCA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtDA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpDA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;ACrCA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/EA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClCA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AAEA;AASA;AAWA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChEA;AAEA;AACA;AAeA;AACA;AAqBA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AAIA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3JA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9DA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClHA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAMA;;;;;;;;;AASA;AACA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1SA;AAOA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5FA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzFA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;AC3EA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;ACxEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpLA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjFA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5PA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/KA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAaA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjZA;AAEA;AAaA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AElBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AAGA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChRA;AACA;AACA;AAUA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzMA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtCA;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtDA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvFA;AAIA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AAEA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5NA;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACXA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FA;AAGA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAMA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AAQA;;;;;;;;;AASA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAQA;;;;;;;;;AASA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAcA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClWA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACrOA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3CA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnIA;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@hodgef/ts-library-boilerplate-basic/webpack/universalModuleDefinition","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/InlineInputElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/InlineMenuElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/SmallDialogInputElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/internal/ErrorMessageElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/internal/MessageElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/internal/WarningMessageElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/style.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/tooltip/internal/TooltipElement.css","webpack://@hodgef/ts-library-boilerplate-basic/./src/GridCanvasHelper.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/ListGrid.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/Action.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/BaseAction.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/BaseInputEditor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/ButtonAction.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/CheckEditor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/Editor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/InlineInputEditor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/InlineMenuEditor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/RadioEditor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/SmallDialogInputEditor.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/action-utils.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/actionBind.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/InlineInputElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/InlineMenuElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/SmallDialogInputElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/action/internal/input-value-handler.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/BaseMessage.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/ErrorMessage.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/InfoMessage.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/MessageHandler.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/WarningMessage.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/internal/ErrorMessageElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/internal/MessageElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/internal/WarningMessageElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/message/messageUtils.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/BaseStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/BranchGraphStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/ButtonStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/CheckStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/IconStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/ImageStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/MenuStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/MultilineTextStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/NumberStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/PercentCompleteBarStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/RadioStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/StdBaseStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/style/Style.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/BaseColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/BranchGraphColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/ButtonColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/CheckColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/Column.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/IconColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/ImageColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/MenuColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/MultilineTextColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/NumberColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/PercentCompleteBarColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/RadioColumn.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/type/columnUtils.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/columns/utils/index.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/core.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/core/DG_EVENT_TYPE.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/core/DrawGrid.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/core/EventTarget.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/data.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/data/CachedDataSource.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/data/DataSource.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/data/FilterDataSource.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/Inline.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/InlineDrawer.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/InlineIcon.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/InlineImage.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/InlinePath2D.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/InlineSvg.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/element/inlines.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/action.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/action/BaseAction.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/action/CheckHeaderAction.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/action/SortHeaderAction.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/action/actionBind.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style/BaseStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style/CheckHeaderStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style/MultilineTextHeaderStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style/SortHeaderStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style/StdBaseStyle.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/style/Style.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/type.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/type/BaseHeader.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/type/CheckHeader.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/type/Header.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/type/MultilineTextHeader.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/header/type/SortHeader.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/headers.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/EventHandler.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/LRUCache.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/NumberMap.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/Rect.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/Scrollable.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/animate.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/calc.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/canvases.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/color.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/dom.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/fonts.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/hiDPI.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/icons.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/imgs.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/legacy/canvas/Path2DShim.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/legacy/canvas/PathCommands.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/legacy/canvas/PathCommandsParser.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/legacy/fontwatch/FontRuler.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/legacy/fontwatch/FontWatchRunner.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/menu-items.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/paste-utils.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/path2DManager.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/sort.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/style.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/symbolManager.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/internal/utils.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/list-grid/LG_EVENT_TYPE.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/list-grid/layout-map/api.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/list-grid/layout-map/index.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/list-grid/layout-map/internal/multi-layout.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/list-grid/layout-map/internal/simple-header-layout.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/list-grid/layout-map/internal/utils.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/plugins/icons.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/plugins/themes.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/register.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/themes.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/themes/BASIC.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/themes/MATERIAL_DESIGN.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/themes/theme.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tools.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tools/Svg.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tools/canvashelper.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tools/svgToIcon.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tooltip/BaseTooltip.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tooltip/Tooltip.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tooltip/TooltipHandler.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/tooltip/internal/TooltipElement.ts","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_add_48px.svg","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_arrow_downward_48px.svg","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_arrow_upward_48px.svg","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_edit_48px.svg","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_star_24px.svg","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_star_border_24px.svg","webpack://@hodgef/ts-library-boilerplate-basic/./src/icons/ic_star_half_24px.svg","webpack://@hodgef/ts-library-boilerplate-basic/webpack/bootstrap","webpack://@hodgef/ts-library-boilerplate-basic/webpack/runtime/define property getters","webpack://@hodgef/ts-library-boilerplate-basic/webpack/runtime/global","webpack://@hodgef/ts-library-boilerplate-basic/webpack/runtime/hasOwnProperty shorthand","webpack://@hodgef/ts-library-boilerplate-basic/webpack/runtime/make namespace object","webpack://@hodgef/ts-library-boilerplate-basic/./src/main.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","import * as calc from './internal/calc'\r\nimport * as canvashelper from './tools/canvashelper'\r\nimport * as fonts from './internal/fonts'\r\nimport * as inlineUtils from './element/inlines'\r\nimport * as themes from './themes'\r\nimport type {\r\n\tCellContext,\r\n\tColorDef,\r\n\tColorPropertyDefine,\r\n\tColorsPropertyDefine,\r\n\tFontPropertyDefine,\r\n\tGridCanvasHelperAPI,\r\n\tLineClamp,\r\n\tListGridAPI,\r\n\tRectProps,\r\n\tRequiredThemeDefine,\r\n\tStylePropertyFunctionArg,\r\n\tTextOverflow\r\n} from './ts-types'\r\nimport type { Inline, InlineDrawOption } from './element/Inline'\r\nimport { calcStartPosition, getFontSize } from './internal/canvases'\r\nimport { cellEquals, cellInRange, getChainSafe, getOrApply, style } from './internal/utils'\r\nimport { InlineDrawer } from './element/InlineDrawer'\r\nimport type { RGBA } from './internal/color'\r\nimport { Rect } from './internal/Rect'\r\nimport type { SimpleColumnIconOption } from './ts-types-internal'\r\nimport { colorToRGB } from './internal/color'\r\n\r\nconst { toBoxArray } = style\r\n\r\nconst INLINE_ELLIPSIS = inlineUtils.of('\\u2026')\r\n\r\ntype ColorsDef = ColorDef | (ColorDef | null)[];\r\n\r\nfunction invalidateCell<T>(context: CellContext, grid: ListGridAPI<T>): void {\r\n\tconst { col, row } = context\r\n\tgrid.invalidateCell(col, row)\r\n}\r\n\r\nfunction getColor<T>(color: ColorPropertyDefine, col: number, row: number, grid: ListGridAPI<T>, context: CanvasRenderingContext2D): ColorDef;\r\nfunction getColor<T>(color: ColorsPropertyDefine, col: number, row: number, grid: ListGridAPI<T>, context: CanvasRenderingContext2D): ColorsDef;\r\nfunction getColor<T>(color: undefined, col: number, row: number, grid: ListGridAPI<T>, context: CanvasRenderingContext2D): undefined;\r\nfunction getColor<T>(\r\n\t\tcolor: ColorPropertyDefine | ColorsPropertyDefine | undefined,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tcontext: CanvasRenderingContext2D\r\n): ColorDef | ColorsDef | undefined {\r\n\treturn getOrApply(color, {\r\n\t\tcol,\r\n\t\trow,\r\n\t\tgrid,\r\n\t\tcontext\r\n\t})\r\n}\r\n\r\nfunction getFont<T>(font: FontPropertyDefine | undefined, col: number, row: number, grid: ListGridAPI<T>, context: CanvasRenderingContext2D): string | undefined {\r\n\tif (font == null) {\r\n\t\treturn undefined\r\n\t}\r\n\treturn getOrApply(font, {\r\n\t\tcol,\r\n\t\trow,\r\n\t\tgrid,\r\n\t\tcontext\r\n\t})\r\n}\r\n\r\nfunction getThemeColor<R, T extends ColorPropertyDefine | ColorsPropertyDefine | string>(grid: ListGridAPI<R>, ...names: string[]): T {\r\n\tconst gridThemeColor = getChainSafe(grid.theme, ...names)\r\n\tif (gridThemeColor == null) {\r\n\t\t// use default theme\r\n\t\treturn getChainSafe(themes.getDefault(), ...names)\r\n\t}\r\n\tif (typeof gridThemeColor !== 'function') {\r\n\t\treturn gridThemeColor\r\n\t}\r\n\tlet defaultThemeColor: ColorDef\r\n\treturn ((args: StylePropertyFunctionArg): any => {\r\n\t\tconst color = gridThemeColor(args)\r\n\t\tif (color != null) {\r\n\t\t\t// use grid theme\r\n\t\t\treturn color\r\n\t\t}\r\n\t\t// use default theme\r\n\t\tdefaultThemeColor = defaultThemeColor || getChainSafe(themes.getDefault(), ...names)\r\n\t\treturn getOrApply(defaultThemeColor, args)\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t}) as any\r\n}\r\n\r\nfunction testFontLoad<T>(font: string | undefined, value: string, context: CellContext, grid: ListGridAPI<T>): boolean {\r\n\tif (font) {\r\n\t\tif (!fonts.check(font, value)) {\r\n\t\t\tfonts.load(font, value, () => invalidateCell(context, grid))\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n\r\nfunction drawInlines<T>(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tinlines: Inline[],\r\n\t\trect: RectProps,\r\n\t\toffset: number,\r\n\t\toffsetTop: number,\r\n\t\toffsetBottom: number,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\tgrid: ListGridAPI<T>\r\n): void {\r\n\tfunction drawInline(inline: Inline, offsetLeft: number, offsetRight: number): void {\r\n\t\tif (inline.canDraw()) {\r\n\t\t\tctx.save()\r\n\t\t\ttry {\r\n\t\t\t\tctx.fillStyle = getColor(inline.color() || ctx.fillStyle, col, row, grid, ctx)\r\n\t\t\t\tctx.font = inline.font() || ctx.font\r\n\t\t\t\tinline.draw({\r\n\t\t\t\t\tctx,\r\n\t\t\t\t\tcanvashelper,\r\n\t\t\t\t\trect,\r\n\t\t\t\t\toffset,\r\n\t\t\t\t\toffsetLeft,\r\n\t\t\t\t\toffsetRight,\r\n\t\t\t\t\toffsetTop,\r\n\t\t\t\t\toffsetBottom\r\n\t\t\t\t})\r\n\t\t\t} finally {\r\n\t\t\t\tctx.restore()\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinline.onReady(() => grid.invalidateCell(col, row))\r\n\t\t\t//noop\r\n\t\t}\r\n\t}\r\n\r\n\tif (inlines.length === 1) {\r\n\t\t//1\r\n\t\tconst inline = inlines[0]\r\n\t\tdrawInline(inline, 0, 0)\r\n\t} else {\r\n\t\tconst inlineWidths = inlines.map((inline) => (inline.width({ ctx }) || 0) - 0)\r\n\t\tlet offsetRight = inlineWidths.reduce((a, b) => a + b)\r\n\r\n\t\tlet offsetLeft = 0\r\n\t\tinlines.forEach((inline, index) => {\r\n\t\t\tconst inlineWidth = inlineWidths[index]\r\n\t\t\toffsetRight -= inlineWidth\r\n\t\t\tdrawInline(inline, offsetLeft, offsetRight)\r\n\t\t\toffsetLeft += inlineWidth\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunction buildInlines(icons: SimpleColumnIconOption[] | undefined, inline: string): Inline[] {\r\n\treturn inlineUtils.buildInlines(icons, inline || '')\r\n}\r\n\r\nfunction inlineToString(inline: Inline | string): string {\r\n\treturn inlineUtils.string(inline)\r\n}\r\n\r\nfunction getOverflowInline(textOverflow?: TextOverflow): Inline {\r\n\tif (!isAllowOverflow(textOverflow) || textOverflow === 'ellipsis') {\r\n\t\treturn INLINE_ELLIPSIS\r\n\t}\r\n\ttextOverflow = textOverflow.trim()\r\n\tif (textOverflow.length === 1) {\r\n\t\treturn inlineUtils.of(textOverflow[0])\r\n\t}\r\n\treturn INLINE_ELLIPSIS\r\n}\r\n\r\nfunction isAllowOverflow(textOverflow?: TextOverflow): textOverflow is string {\r\n\treturn Boolean(textOverflow && textOverflow !== 'clip' && typeof textOverflow === 'string')\r\n}\r\n\r\nfunction getOverflowInlinesIndex(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tinlines: Inline[],\r\n\t\twidth: number\r\n): {\r\n    index: number;\r\n    lineWidth: number;\r\n    remWidth: number;\r\n} | null {\r\n\tconst maxWidth = width - 3 /*buffer*/\r\n\tlet lineWidth = 0\r\n\tfor (let i = 0; i < inlines.length; i++) {\r\n\t\tconst inline = inlines[i]\r\n\t\tconst inlineWidth = (inline.width({ ctx }) || 0) - 0\r\n\t\tif (lineWidth + inlineWidth > maxWidth) {\r\n\t\t\treturn {\r\n\t\t\t\tindex: i,\r\n\t\t\t\tlineWidth,\r\n\t\t\t\tremWidth: maxWidth - lineWidth\r\n\t\t\t}\r\n\t\t}\r\n\t\tlineWidth += inlineWidth\r\n\t}\r\n\treturn null\r\n}\r\n\r\nfunction isOverflowInlines(ctx: CanvasRenderingContext2D, inlines: Inline[], width: number): boolean {\r\n\treturn !!getOverflowInlinesIndex(ctx, inlines, width)\r\n}\r\n\r\nfunction breakWidthInlines(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tinlines: Inline[],\r\n\t\twidth: number\r\n): {\r\n    beforeInlines: Inline[];\r\n    overflow: boolean;\r\n    afterInlines: Inline[];\r\n} {\r\n\tconst indexData = getOverflowInlinesIndex(ctx, inlines, width)\r\n\tif (!indexData) {\r\n\t\treturn {\r\n\t\t\tbeforeInlines: inlines,\r\n\t\t\toverflow: false,\r\n\t\t\tafterInlines: []\r\n\t\t}\r\n\t}\r\n\tconst { index, remWidth } = indexData\r\n\tconst inline = inlines[index]\r\n\tconst beforeInlines = inlines.slice(0, index)\r\n\tconst afterInlines = []\r\n\tif (inline.canBreak()) {\r\n\t\tlet { before, after } = inline.breakWord(ctx, remWidth)\r\n\t\tif (!before && !beforeInlines.length) {\r\n\t\t\t({ before, after } = inline.breakAll(ctx, remWidth))\r\n\t\t}\r\n\t\tif (!before && !beforeInlines.length) {\r\n\t\t\t// Always return one char\r\n\t\t\t({ before, after } = inline.splitIndex(1))\r\n\t\t}\r\n\t\tif (before) {\r\n\t\t\tbeforeInlines.push(before)\r\n\t\t}\r\n\t\tif (after) {\r\n\t\t\tafterInlines.push(after)\r\n\t\t}\r\n\t\tafterInlines.push(...inlines.slice(index + 1))\r\n\t} else {\r\n\t\tif (!beforeInlines.length) {\r\n\t\t\t// Always return one char\r\n\t\t\tbeforeInlines.push(inline)\r\n\t\t}\r\n\t\tafterInlines.push(...inlines.slice(beforeInlines.length))\r\n\t}\r\n\treturn {\r\n\t\tbeforeInlines,\r\n\t\toverflow: true,\r\n\t\tafterInlines\r\n\t}\r\n}\r\n\r\nfunction truncateInlines(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tinlines: Inline[],\r\n\t\twidth: number,\r\n\t\toption?: TextOverflow\r\n): {\r\n    inlines: Inline[];\r\n    overflow: boolean;\r\n} {\r\n\tconst indexData = getOverflowInlinesIndex(ctx, inlines, width)\r\n\tif (!indexData) {\r\n\t\treturn {\r\n\t\t\tinlines,\r\n\t\t\toverflow: false\r\n\t\t}\r\n\t}\r\n\tconst { index, lineWidth } = indexData\r\n\tconst inline = inlines[index]\r\n\tconst overflowInline = getOverflowInline(option)\r\n\tconst ellipsisWidth = overflowInline.width({ ctx })\r\n\tconst remWidth = width - lineWidth - ellipsisWidth\r\n\tconst result = inlines.slice(0, index)\r\n\tif (inline.canBreak()) {\r\n\t\tconst { before } = inline.breakAll(ctx, remWidth)\r\n\t\tif (before) {\r\n\t\t\tresult.push(before)\r\n\t\t}\r\n\t}\r\n\tresult.push(overflowInline)\r\n\treturn {\r\n\t\tinlines: result,\r\n\t\toverflow: true\r\n\t}\r\n}\r\n\r\nfunction _inlineRect<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tinline: string,\r\n\t\trect: RectProps,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\t{\r\n\t\t\toffset,\r\n\t\t\tcolor,\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tfont,\r\n\t\t\ttextOverflow,\r\n\t\t\ticons\r\n\t\t}: {\r\n        offset: number;\r\n        color?: ColorPropertyDefine;\r\n        textAlign: CanvasTextAlign;\r\n        textBaseline: CanvasTextBaseline;\r\n        font?: string;\r\n        textOverflow?: TextOverflow;\r\n        icons?: SimpleColumnIconOption[];\r\n    }\r\n): void {\r\n\t//style\r\n\tctx.fillStyle = getColor(color || ctx.fillStyle, col, row, grid, ctx)\r\n\tctx.textAlign = textAlign\r\n\tctx.textBaseline = textBaseline\r\n\tctx.font = font || ctx.font\r\n\r\n\tlet inlines = buildInlines(icons, inline)\r\n\tif (isAllowOverflow(textOverflow) && isOverflowInlines(ctx, inlines, rect.width)) {\r\n\t\tconst { inlines: truncInlines, overflow } = truncateInlines(ctx, inlines, rect.width, textOverflow)\r\n\t\tinlines = truncInlines\r\n\t\tgrid.setCellOverflowText(col, row, overflow && inlineToString(inline))\r\n\t} else {\r\n\t\tgrid.setCellOverflowText(col, row, false)\r\n\t}\r\n\r\n\tdrawInlines(ctx, inlines, rect, offset, 0, 0, col, row, grid)\r\n}\r\n\r\n// eslint-disable-next-line complexity\r\nfunction _multiInlineRect<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tmultiInlines: string[],\r\n\t\trect: RectProps,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\t{\r\n\t\t\toffset,\r\n\t\t\tcolor,\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tfont,\r\n\t\t\tlineHeight,\r\n\t\t\tautoWrapText,\r\n\t\t\tlineClamp,\r\n\t\t\ttextOverflow,\r\n\t\t\ticons\r\n\t\t}: {\r\n        offset: number;\r\n        color?: ColorPropertyDefine;\r\n        textAlign: CanvasTextAlign;\r\n        textBaseline: CanvasTextBaseline;\r\n        font?: string;\r\n        lineHeight: number;\r\n        autoWrapText?: boolean;\r\n        lineClamp: LineClamp;\r\n        textOverflow?: TextOverflow;\r\n        icons?: SimpleColumnIconOption[];\r\n    }\r\n): void {\r\n\t//style\r\n\tctx.fillStyle = getColor(color || ctx.fillStyle, col, row, grid, ctx)\r\n\tctx.textAlign = textAlign\r\n\tctx.textBaseline = textBaseline\r\n\tctx.font = font || ctx.font\r\n\r\n\tif (lineClamp === 'auto') {\r\n\t\tconst rectHeight = rect.height - offset * 2 - 2 /*offset added by Inline#draw*/\r\n\t\tlineClamp = Math.max(Math.floor(rectHeight / lineHeight), 1)\r\n\t}\r\n\r\n\tlet buildedMultiInlines: Inline[][]\r\n\tif (autoWrapText || lineClamp > 0 || isAllowOverflow(textOverflow)) {\r\n\t\tconst { width } = rect\r\n\t\tbuildedMultiInlines = []\r\n\t\tconst procLineClamp =\r\n            lineClamp > 0\r\n            \t? (inlines: Inline[], hasNext: boolean): boolean => {\r\n            \t\tif (buildedMultiInlines.length + 1 >= lineClamp) {\r\n            \t\t\tif (inlines.length === 0 && hasNext) {\r\n            \t\t\t\tbuildedMultiInlines.push([ getOverflowInline(textOverflow) ])\r\n            \t\t\t\tgrid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join('\\n'))\r\n            \t\t\t} else {\r\n            \t\t\t\tconst { inlines: truncInlines, overflow } = truncateInlines(ctx, inlines, width, textOverflow)\r\n            \t\t\t\tbuildedMultiInlines.push(hasNext && !overflow ? truncInlines.concat([ getOverflowInline(textOverflow) ]) : truncInlines)\r\n            \t\t\t\tif (overflow || hasNext) {\r\n            \t\t\t\t\tgrid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join('\\n'))\r\n            \t\t\t\t}\r\n            \t\t\t}\r\n            \t\t\treturn false\r\n            \t\t}\r\n            \t\treturn true\r\n            \t}\r\n            \t: (): boolean => true\r\n\t\tconst procLine = autoWrapText\r\n\t\t\t? (inlines: Inline[], hasNext: boolean): boolean => {\r\n\t\t\t\tif (!procLineClamp(inlines, hasNext)) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\twhile (inlines.length) {\r\n\t\t\t\t\tif (!procLineClamp(inlines, hasNext)) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst { beforeInlines, afterInlines } = breakWidthInlines(ctx, inlines, width)\r\n\t\t\t\t\tbuildedMultiInlines.push(beforeInlines)\r\n\t\t\t\t\tinlines = afterInlines\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t: isAllowOverflow(textOverflow)\r\n\t\t\t\t? (inlines: Inline[], hasNext: boolean): boolean => {\r\n\t\t\t\t\tif (!procLineClamp(inlines, hasNext)) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst { inlines: truncInlines, overflow } = truncateInlines(ctx, inlines, width, textOverflow)\r\n\t\t\t\t\tbuildedMultiInlines.push(truncInlines)\r\n\t\t\t\t\tif (overflow) {\r\n\t\t\t\t\t\tgrid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join('\\n'))\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t\t: (inlines: Inline[], hasNext: boolean): boolean => {\r\n\t\t\t\t\tif (!procLineClamp(inlines, hasNext)) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuildedMultiInlines.push(inlines)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\tgrid.setCellOverflowText(col, row, false)\r\n\t\tfor (let lineRow = 0; lineRow < multiInlines.length; lineRow++) {\r\n\t\t\tconst inline = multiInlines[lineRow]\r\n\t\t\tconst buildedInline = buildInlines(lineRow === 0 ? icons : undefined, inline)\r\n\t\t\tif (!procLine(buildedInline, lineRow + 1 < multiInlines.length)) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tgrid.setCellOverflowText(col, row, false)\r\n\t\tbuildedMultiInlines = multiInlines.map((inline, lineRow) => buildInlines(lineRow === 0 ? icons : undefined, inline))\r\n\t}\r\n\r\n\tlet paddingTop = 0\r\n\tlet paddingBottom = lineHeight * (buildedMultiInlines.length - 1)\r\n\r\n\tif (ctx.textBaseline === 'top' || ctx.textBaseline === 'hanging') {\r\n\t\tconst em = getFontSize(ctx, ctx.font).height\r\n\t\tconst pad = (lineHeight - em) / 2\r\n\t\tpaddingTop += pad\r\n\t\tpaddingBottom -= pad\r\n\t} else if (ctx.textBaseline === 'bottom' || ctx.textBaseline === 'alphabetic' || ctx.textBaseline === 'ideographic') {\r\n\t\tconst em = getFontSize(ctx, ctx.font).height\r\n\t\tconst pad = (lineHeight - em) / 2\r\n\t\tpaddingTop -= pad\r\n\t\tpaddingBottom += pad\r\n\t}\r\n\tbuildedMultiInlines.forEach((buildedInline) => {\r\n\t\tdrawInlines(ctx, buildedInline, rect, offset, paddingTop, paddingBottom, col, row, grid)\r\n\t\tpaddingTop += lineHeight\r\n\t\tpaddingBottom -= lineHeight\r\n\t})\r\n}\r\n\r\nfunction calcElapsedColor(startColor: string, endColor: string, elapsedTime: number): string {\r\n\tconst startColorRGB = colorToRGB(startColor)\r\n\tconst endColorRGB = colorToRGB(endColor)\r\n\tconst getRGB = (colorName: keyof RGBA): number => {\r\n\t\tconst start = startColorRGB[colorName]\r\n\t\tconst end = endColorRGB[colorName]\r\n\t\tif (elapsedTime >= 1) {\r\n\t\t\treturn end\r\n\t\t}\r\n\t\tif (elapsedTime <= 0) {\r\n\t\t\treturn start\r\n\t\t}\r\n\t\tconst diff = start - end\r\n\t\treturn Math.ceil(start - diff * elapsedTime)\r\n\t}\r\n\treturn `rgb(${ getRGB('r') }, ${ getRGB('g') }, ${ getRGB('b') })`\r\n}\r\n\r\nfunction drawCheckbox<T>(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\trect: RectProps,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\tcheck: boolean,\r\n\t\thelper: GridCanvasHelper<T>,\r\n\t\t{\r\n\t\t\tanimElapsedTime = 1,\r\n\t\t\tuncheckBgColor = helper.theme.checkbox.uncheckBgColor,\r\n\t\t\tcheckBgColor = helper.theme.checkbox.checkBgColor,\r\n\t\t\tborderColor = helper.theme.checkbox.borderColor,\r\n\t\t\ttextAlign = 'center',\r\n\t\t\ttextBaseline = 'middle'\r\n\t\t}: {\r\n        animElapsedTime?: number;\r\n        uncheckBgColor?: ColorPropertyDefine;\r\n        checkBgColor?: ColorPropertyDefine;\r\n        borderColor?: ColorPropertyDefine;\r\n        textAlign?: CanvasTextAlign;\r\n        textBaseline?: CanvasTextBaseline;\r\n    },\r\n\t\tpositionOpt = {}\r\n): void {\r\n\tconst boxWidth = canvashelper.measureCheckbox(ctx).width\r\n\tctx.textAlign = textAlign\r\n\tctx.textBaseline = textBaseline\r\n\tconst pos = calcStartPosition(ctx, rect, boxWidth + 1 /*+1*/, boxWidth + 1 /*+1*/, positionOpt)\r\n\tuncheckBgColor = helper.getColor(uncheckBgColor, col, row, ctx)\r\n\tcheckBgColor = helper.getColor(checkBgColor, col, row, ctx)\r\n\tborderColor = helper.getColor(borderColor, col, row, ctx)\r\n\tif (0 < animElapsedTime && animElapsedTime < 1) {\r\n\t\tuncheckBgColor = check ? uncheckBgColor : calcElapsedColor(checkBgColor as string, uncheckBgColor as string, animElapsedTime)\r\n\t\tcheckBgColor = check ? calcElapsedColor(uncheckBgColor as string, checkBgColor as string, animElapsedTime) : checkBgColor\r\n\t}\r\n\r\n\tcanvashelper.drawCheckbox(ctx, pos.x, pos.y, check ? animElapsedTime : false, {\r\n\t\tuncheckBgColor,\r\n\t\tcheckBgColor,\r\n\t\tborderColor\r\n\t})\r\n}\r\n\r\nfunction drawRadioButton<T>(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\trect: RectProps,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\tcheck: boolean,\r\n\t\thelper: GridCanvasHelper<T>,\r\n\t\t{\r\n\t\t\tanimElapsedTime = 1,\r\n\t\t\tcheckColor = helper.theme.radioButton.checkColor,\r\n\t\t\tuncheckBorderColor = helper.theme.radioButton.uncheckBorderColor,\r\n\t\t\tcheckBorderColor = helper.theme.radioButton.checkBorderColor,\r\n\t\t\tuncheckBgColor = helper.theme.radioButton.uncheckBgColor,\r\n\t\t\tcheckBgColor = helper.theme.radioButton.checkBgColor,\r\n\t\t\ttextAlign = 'center',\r\n\t\t\ttextBaseline = 'middle'\r\n\t\t}: {\r\n        animElapsedTime?: number;\r\n        checkColor?: ColorPropertyDefine;\r\n        uncheckBorderColor?: ColorPropertyDefine;\r\n        checkBorderColor?: ColorPropertyDefine;\r\n        uncheckBgColor?: ColorPropertyDefine;\r\n        checkBgColor?: ColorPropertyDefine;\r\n        textAlign?: CanvasTextAlign;\r\n        textBaseline?: CanvasTextBaseline;\r\n    },\r\n\t\tpositionOpt = {}\r\n): void {\r\n\tconst boxWidth = canvashelper.measureRadioButton(ctx).width\r\n\tctx.textAlign = textAlign\r\n\tctx.textBaseline = textBaseline\r\n\tconst pos = calcStartPosition(ctx, rect, boxWidth + 1 /*+1*/, boxWidth + 1 /*+1*/, positionOpt)\r\n\tcheckColor = helper.getColor(checkColor, col, row, ctx)\r\n\tuncheckBorderColor = helper.getColor(uncheckBorderColor, col, row, ctx)\r\n\tcheckBorderColor = helper.getColor(checkBorderColor, col, row, ctx)\r\n\tuncheckBgColor = helper.getColor(uncheckBgColor, col, row, ctx)\r\n\tcheckBgColor = helper.getColor(checkBgColor, col, row, ctx)\r\n\tlet borderColor = check ? checkBorderColor : uncheckBorderColor\r\n\tlet bgColor = check ? checkBgColor : uncheckBgColor\r\n\tif (0 < animElapsedTime && animElapsedTime < 1) {\r\n\t\tborderColor = check\r\n\t\t\t? calcElapsedColor(uncheckBorderColor as string, checkBorderColor as string, animElapsedTime)\r\n\t\t\t: calcElapsedColor(checkBorderColor as string, uncheckBorderColor as string, animElapsedTime)\r\n\t\tbgColor = check ? calcElapsedColor(uncheckBgColor as string, checkBgColor as string, animElapsedTime) : calcElapsedColor(checkBgColor as string, uncheckBgColor as string, animElapsedTime)\r\n\t}\r\n\r\n\tcanvashelper.drawRadioButton(ctx, pos.x, pos.y, check ? animElapsedTime : 1 - animElapsedTime, {\r\n\t\tcheckColor,\r\n\t\tborderColor,\r\n\t\tbgColor\r\n\t})\r\n}\r\n\r\nclass ThemeResolver<T> implements RequiredThemeDefine {\r\n    private _grid: ListGridAPI<T>\r\n\r\n    private _checkbox: RequiredThemeDefine['checkbox'] | null = null\r\n\r\n    private _radioButton: RequiredThemeDefine['radioButton'] | null = null\r\n\r\n    private _button: RequiredThemeDefine['button'] | null = null\r\n\r\n    private _header: RequiredThemeDefine['header'] | null = null\r\n\r\n    private _messages: RequiredThemeDefine['messages'] | null = null\r\n\r\n    constructor(grid: ListGridAPI<T>) {\r\n    \tthis._grid = grid\r\n    }\r\n\r\n    getThemeColor<T extends ColorPropertyDefine | ColorsPropertyDefine | FontPropertyDefine>(...name: string[]): T {\r\n    \treturn getThemeColor(this._grid, ...name)\r\n    }\r\n\r\n    get font(): string {\r\n    \treturn getThemeColor(this._grid, 'font')\r\n    }\r\n\r\n    get underlayBackgroundColor(): string {\r\n    \treturn getThemeColor(this._grid, 'underlayBackgroundColor')\r\n    }\r\n\r\n    // color\r\n    get color(): ColorPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'color')\r\n    }\r\n\r\n    get frozenRowsColor(): ColorPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'frozenRowsColor')\r\n    }\r\n\r\n    // background\r\n    get defaultBgColor(): ColorPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'defaultBgColor')\r\n    }\r\n\r\n    get frozenRowsBgColor(): ColorPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'frozenRowsBgColor')\r\n    }\r\n\r\n    get selectionBgColor(): ColorPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'selectionBgColor')\r\n    }\r\n\r\n    get highlightBgColor(): ColorPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'highlightBgColor')\r\n    }\r\n\r\n    // border\r\n    get borderColor(): ColorsPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'borderColor')\r\n    }\r\n\r\n    get frozenRowsBorderColor(): ColorsPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'frozenRowsBorderColor')\r\n    }\r\n\r\n    get highlightBorderColor(): ColorsPropertyDefine {\r\n    \treturn getThemeColor(this._grid, 'highlightBorderColor')\r\n    }\r\n\r\n    get checkbox(): RequiredThemeDefine['checkbox'] {\r\n    \tconst grid = this._grid\r\n    \treturn (\r\n    \t\tthis._checkbox ||\r\n            (this._checkbox = {\r\n            \tget uncheckBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'checkbox', 'uncheckBgColor')\r\n            \t},\r\n            \tget checkBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'checkbox', 'checkBgColor')\r\n            \t},\r\n            \tget borderColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'checkbox', 'borderColor')\r\n            \t}\r\n            })\r\n    \t)\r\n    }\r\n\r\n    get radioButton(): RequiredThemeDefine['radioButton'] {\r\n    \tconst grid = this._grid\r\n    \treturn (\r\n    \t\tthis._radioButton ||\r\n            (this._radioButton = {\r\n            \tget checkColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'radioButton', 'checkColor')\r\n            \t},\r\n            \tget uncheckBorderColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'radioButton', 'uncheckBorderColor')\r\n            \t},\r\n            \tget checkBorderColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'radioButton', 'checkBorderColor')\r\n            \t},\r\n            \tget uncheckBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'radioButton', 'uncheckBgColor')\r\n            \t},\r\n            \tget checkBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'radioButton', 'checkBgColor')\r\n            \t}\r\n            })\r\n    \t)\r\n    }\r\n\r\n    get button(): RequiredThemeDefine['button'] {\r\n    \tconst grid = this._grid\r\n    \treturn (\r\n    \t\tthis._button ||\r\n            (this._button = {\r\n            \tget color(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'button', 'color')\r\n            \t},\r\n            \tget bgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'button', 'bgColor')\r\n            \t}\r\n            })\r\n    \t)\r\n    }\r\n\r\n    get header(): RequiredThemeDefine['header'] {\r\n    \tconst grid = this._grid\r\n    \treturn (\r\n    \t\tthis._header ||\r\n            (this._header = {\r\n            \tget sortArrowColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'header', 'sortArrowColor')\r\n            \t}\r\n            })\r\n    \t)\r\n    }\r\n\r\n    get messages(): RequiredThemeDefine['messages'] {\r\n    \tconst grid = this._grid\r\n    \treturn (\r\n    \t\tthis._messages ||\r\n            (this._messages = {\r\n            \tget infoBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'messages', 'infoBgColor')\r\n            \t},\r\n            \tget errorBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'messages', 'errorBgColor')\r\n            \t},\r\n            \tget warnBgColor(): ColorPropertyDefine {\r\n            \t\treturn getThemeColor(grid, 'messages', 'warnBgColor')\r\n            \t}\r\n            })\r\n    \t)\r\n    }\r\n}\r\n\r\nfunction strokeRect(ctx: CanvasRenderingContext2D, color: ColorsDef, left: number, top: number, width: number, height: number): void {\r\n\tif (!Array.isArray(color)) {\r\n\t\tif (color) {\r\n\t\t\tctx.strokeStyle = color\r\n\t\t\tctx.strokeRect(left, top, width, height)\r\n\t\t}\r\n\t} else {\r\n\t\tconst borderColors = toBoxArray(color)\r\n\t\tcanvashelper.strokeColorsRect(ctx, borderColors, left, top, width, height)\r\n\t}\r\n}\r\n\r\nexport class GridCanvasHelper<T> implements GridCanvasHelperAPI {\r\n    private _grid: ListGridAPI<T>\r\n\r\n    private _theme: RequiredThemeDefine\r\n\r\n    constructor(grid: ListGridAPI<T>) {\r\n    \tthis._grid = grid\r\n    \tthis._theme = new ThemeResolver(grid)\r\n    }\r\n\r\n    createCalculator(\r\n    \t\tcontext: CellContext,\r\n    \t\tfont: string | undefined\r\n    ): {\r\n        calcWidth(width: number | string): number;\r\n        calcHeight(height: number | string): number;\r\n    } {\r\n    \treturn {\r\n    \t\tcalcWidth(width: number | string): number {\r\n    \t\t\treturn calc.toPx(width, {\r\n    \t\t\t\tget full() {\r\n    \t\t\t\t\tconst rect = context.getRect()\r\n    \t\t\t\t\treturn rect.width\r\n    \t\t\t\t},\r\n    \t\t\t\tget em() {\r\n    \t\t\t\t\treturn getFontSize(context.getContext(), font).width\r\n    \t\t\t\t}\r\n    \t\t\t})\r\n    \t\t},\r\n    \t\tcalcHeight(height: number | string): number {\r\n    \t\t\treturn calc.toPx(height, {\r\n    \t\t\t\tget full() {\r\n    \t\t\t\t\tconst rect = context.getRect()\r\n    \t\t\t\t\treturn rect.height\r\n    \t\t\t\t},\r\n    \t\t\t\tget em() {\r\n    \t\t\t\t\treturn getFontSize(context.getContext(), font).height\r\n    \t\t\t\t}\r\n    \t\t\t})\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    getColor(color: ColorPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorDef;\r\n\r\n    getColor(color: ColorsPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorsDef;\r\n\r\n    getColor(color: ColorPropertyDefine | ColorsPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorsDef {\r\n    \treturn getColor(color, col, row, this._grid, ctx)\r\n    }\r\n\r\n    toBoxArray(obj: ColorsDef): [ ColorDef | null, ColorDef | null, ColorDef | null, ColorDef | null ] {\r\n    \treturn toBoxArray(obj)\r\n    }\r\n\r\n    toBoxPixelArray(value: number | string | (number | string)[], context: CellContext, font: string | undefined): [ number, number, number, number ] {\r\n    \tif (typeof value === 'string' || Array.isArray(value)) {\r\n    \t\tconst calculator = this.createCalculator(context, font)\r\n    \t\tconst box = toBoxArray(value)\r\n    \t\treturn [ calculator.calcHeight(box[0]), calculator.calcWidth(box[1]), calculator.calcHeight(box[2]), calculator.calcWidth(box[3]) ]\r\n    \t}\r\n    \treturn toBoxArray(value)\r\n    }\r\n\r\n    get theme(): RequiredThemeDefine {\r\n    \treturn this._theme\r\n    }\r\n\r\n    drawWithClip(context: CellContext, draw: (ctx: CanvasRenderingContext2D) => void): void {\r\n    \tconst drawRect = context.getDrawRect()\r\n    \tif (!drawRect) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst ctx = context.getContext()\r\n\r\n    \tctx.save()\r\n    \ttry {\r\n    \t\tctx.beginPath()\r\n    \t\tctx.rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height)\r\n    \t\t//clip\r\n    \t\tctx.clip()\r\n\r\n    \t\tdraw(ctx)\r\n    \t} finally {\r\n    \t\tctx.restore()\r\n    \t}\r\n    }\r\n\r\n    drawBorderWithClip(context: CellContext, draw: (ctx: CanvasRenderingContext2D) => void): void {\r\n    \tconst drawRect = context.getDrawRect()\r\n    \tif (!drawRect) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst rect = context.getRect()\r\n    \tconst ctx = context.getContext()\r\n    \tctx.save()\r\n    \ttry {\r\n    \t\t//clip\r\n    \t\tctx.beginPath()\r\n    \t\tlet clipLeft = drawRect.left\r\n    \t\tlet clipWidth = drawRect.width\r\n    \t\tif (drawRect.left === rect.left) {\r\n    \t\t\tclipLeft += -1\r\n    \t\t\tclipWidth += 1\r\n    \t\t}\r\n    \t\tlet clipTop = drawRect.top\r\n    \t\tlet clipHeight = drawRect.height\r\n    \t\tif (drawRect.top === rect.top) {\r\n    \t\t\tclipTop += -1\r\n    \t\t\tclipHeight += 1\r\n    \t\t}\r\n    \t\tctx.rect(clipLeft, clipTop, clipWidth, clipHeight)\r\n    \t\tctx.clip()\r\n\r\n    \t\tdraw(ctx)\r\n    \t} finally {\r\n    \t\tctx.restore()\r\n    \t}\r\n    }\r\n\r\n    text(\r\n    \t\ttext: string,\r\n    \t\tcontext: CellContext,\r\n    \t\t{\r\n    \t\t\tpadding,\r\n    \t\t\toffset = 2,\r\n    \t\t\tcolor,\r\n    \t\t\ttextAlign = 'left',\r\n    \t\t\ttextBaseline = 'middle',\r\n    \t\t\tfont,\r\n    \t\t\ttextOverflow = 'clip',\r\n    \t\t\ticons\r\n    \t\t}: {\r\n            padding?: number | string | (number | string)[];\r\n            offset?: number;\r\n            color?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n            font?: FontPropertyDefine;\r\n            textOverflow?: TextOverflow;\r\n            icons?: SimpleColumnIconOption[];\r\n        } = {}\r\n    ): void {\r\n    \tlet rect = context.getRect()\r\n\r\n    \tconst { col, row } = context\r\n\r\n    \tif (!color) {\r\n    \t\t({ color } = this.theme)\r\n    \t\t// header color\r\n    \t\tconst isFrozenCell = this._grid.isFrozenCell(col, row)\r\n    \t\tif (isFrozenCell && isFrozenCell.row) {\r\n    \t\t\tcolor = this.theme.frozenRowsColor\r\n    \t\t}\r\n    \t}\r\n\r\n    \tthis.drawWithClip(context, (ctx) => {\r\n    \t\tfont = getFont(font, context.col, context.row, this._grid, ctx)\r\n    \t\tif (padding) {\r\n    \t\t\tconst paddingNums = this.toBoxPixelArray(padding, context, font)\r\n    \t\t\tconst left = rect.left + paddingNums[3]\r\n    \t\t\tconst top = rect.top + paddingNums[0]\r\n    \t\t\tconst width = rect.width - paddingNums[1] - paddingNums[3]\r\n    \t\t\tconst height = rect.height - paddingNums[0] - paddingNums[2]\r\n    \t\t\trect = new Rect(left, top, width, height)\r\n    \t\t}\r\n    \t\t_inlineRect(this._grid, ctx, text, rect, col, row, {\r\n    \t\t\toffset,\r\n    \t\t\tcolor,\r\n    \t\t\ttextAlign,\r\n    \t\t\ttextBaseline,\r\n    \t\t\tfont,\r\n    \t\t\ttextOverflow,\r\n    \t\t\ticons\r\n    \t\t})\r\n    \t})\r\n    }\r\n\r\n    multilineText(\r\n    \t\tmultilines: string[],\r\n    \t\tcontext: CellContext,\r\n    \t\t{\r\n    \t\t\tpadding,\r\n    \t\t\toffset = 2,\r\n    \t\t\tcolor,\r\n    \t\t\ttextAlign = 'left',\r\n    \t\t\ttextBaseline = 'middle',\r\n    \t\t\tfont,\r\n    \t\t\tlineHeight = '1em',\r\n    \t\t\tautoWrapText = false,\r\n    \t\t\tlineClamp = 0,\r\n    \t\t\ttextOverflow = 'clip',\r\n    \t\t\ticons\r\n    \t\t}: {\r\n            padding?: number | string | (number | string)[];\r\n            offset?: number;\r\n            color?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n            font?: FontPropertyDefine;\r\n            lineHeight?: string | number;\r\n            autoWrapText?: boolean;\r\n            lineClamp?: LineClamp;\r\n            textOverflow?: TextOverflow;\r\n            icons?: SimpleColumnIconOption[];\r\n        } = {}\r\n    ): void {\r\n    \tlet rect = context.getRect()\r\n\r\n    \tconst { col, row } = context\r\n\r\n    \tif (!color) {\r\n    \t\t({ color } = this.theme)\r\n    \t\t// header color\r\n    \t\tconst isFrozenCell = this._grid.isFrozenCell(col, row)\r\n    \t\tif (isFrozenCell && isFrozenCell.row) {\r\n    \t\t\tcolor = this.theme.frozenRowsColor\r\n    \t\t}\r\n    \t}\r\n\r\n    \tthis.drawWithClip(context, (ctx) => {\r\n    \t\tfont = getFont(font, context.col, context.row, this._grid, ctx)\r\n    \t\tif (padding) {\r\n    \t\t\tconst paddingNums = this.toBoxPixelArray(padding, context, font)\r\n    \t\t\tconst left = rect.left + paddingNums[3]\r\n    \t\t\tconst top = rect.top + paddingNums[0]\r\n    \t\t\tconst width = rect.width - paddingNums[1] - paddingNums[3]\r\n    \t\t\tconst height = rect.height - paddingNums[0] - paddingNums[2]\r\n    \t\t\trect = new Rect(left, top, width, height)\r\n    \t\t}\r\n    \t\tconst calculator = this.createCalculator(context, font)\r\n    \t\tlineHeight = calculator.calcHeight(lineHeight)\r\n    \t\t_multiInlineRect(this._grid, ctx, multilines, rect, col, row, {\r\n    \t\t\toffset,\r\n    \t\t\tcolor,\r\n    \t\t\ttextAlign,\r\n    \t\t\ttextBaseline,\r\n    \t\t\tfont,\r\n    \t\t\tlineHeight,\r\n    \t\t\tautoWrapText,\r\n    \t\t\tlineClamp,\r\n    \t\t\ttextOverflow,\r\n    \t\t\ticons\r\n    \t\t})\r\n    \t})\r\n    }\r\n\r\n    fillText(\r\n    \t\ttext: string,\r\n    \t\tx: number,\r\n    \t\ty: number,\r\n    \t\tcontext: CellContext,\r\n    \t\t{\r\n    \t\t\tcolor,\r\n    \t\t\ttextAlign = 'left',\r\n    \t\t\ttextBaseline = 'top',\r\n    \t\t\tfont\r\n    \t\t}: {\r\n            color?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n            font?: FontPropertyDefine;\r\n        } = {}\r\n    ): void {\r\n    \tconst { col, row } = context\r\n\r\n    \tif (!color) {\r\n    \t\t({ color } = this.theme)\r\n    \t\t// header color\r\n    \t\tconst isFrozenCell = this._grid.isFrozenCell(col, row)\r\n    \t\tif (isFrozenCell && isFrozenCell.row) {\r\n    \t\t\tcolor = this.theme.frozenRowsColor\r\n    \t\t}\r\n    \t}\r\n    \tconst ctx = context.getContext()\r\n    \tctx.save()\r\n    \ttry {\r\n    \t\tfont = getFont(font, context.col, context.row, this._grid, ctx)\r\n    \t\tctx.fillStyle = getColor(color, col, row, this._grid, ctx)\r\n    \t\tctx.textAlign = textAlign\r\n    \t\tctx.textBaseline = textBaseline\r\n    \t\tctx.font = font || ctx.font\r\n    \t\tctx.fillText(text, x, y)\r\n    \t} finally {\r\n    \t\tctx.restore()\r\n    \t}\r\n    }\r\n\r\n    fillCell(context: CellContext, { fillColor = this.theme.defaultBgColor }: { fillColor?: ColorPropertyDefine } = {}): void {\r\n    \tconst rect = context.getRect()\r\n\r\n    \tthis.drawWithClip(context, (ctx) => {\r\n    \t\tconst { col, row } = context\r\n    \t\tctx.fillStyle = getColor(fillColor, col, row, this._grid, ctx)\r\n\r\n    \t\tctx.beginPath()\r\n    \t\tctx.rect(rect.left, rect.top, rect.width, rect.height)\r\n    \t\tctx.fill()\r\n    \t})\r\n    }\r\n\r\n    fillCellWithState(context: CellContext, option: { fillColor?: ColorPropertyDefine } = {}): void {\r\n    \toption.fillColor = this.getFillColorState(context, option)\r\n    \tthis.fillCell(context, option)\r\n    }\r\n\r\n    fillRect(rect: RectProps, context: CellContext, { fillColor = this.theme.defaultBgColor }: { fillColor?: ColorPropertyDefine } = {}): void {\r\n    \tconst ctx = context.getContext()\r\n    \tctx.save()\r\n    \ttry {\r\n    \t\tconst { col, row } = context\r\n    \t\tctx.fillStyle = getColor(fillColor, col, row, this._grid, ctx)\r\n\r\n    \t\tctx.beginPath()\r\n    \t\tctx.rect(rect.left, rect.top, rect.width, rect.height)\r\n    \t\tctx.fill()\r\n    \t} finally {\r\n    \t\tctx.restore()\r\n    \t}\r\n    }\r\n\r\n    fillRectWithState(rect: RectProps, context: CellContext, option: { fillColor?: ColorPropertyDefine } = {}): void {\r\n    \toption.fillColor = this.getFillColorState(context, option)\r\n\r\n    \tthis.fillRect(rect, context, option)\r\n    }\r\n\r\n    getFillColorState(context: CellContext, option: { fillColor?: ColorPropertyDefine } = {}): ColorPropertyDefine {\r\n    \tconst sel = context.getSelection()\r\n    \tconst { col, row } = context\r\n    \tif (!cellEquals(sel.select, context) && cellInRange(sel.range, col, row)) {\r\n    \t\treturn this.theme.selectionBgColor\r\n    \t}\r\n    \tif (option.fillColor) {\r\n    \t\treturn option.fillColor\r\n    \t}\r\n    \tif (cellEquals(sel.select, context)) {\r\n    \t\treturn this.theme.highlightBgColor\r\n    \t}\r\n    \tconst isFrozenCell = this._grid.isFrozenCell(col, row)\r\n    \tif (isFrozenCell && isFrozenCell.row) {\r\n    \t\treturn this.theme.frozenRowsBgColor\r\n    \t}\r\n    \treturn this.theme.defaultBgColor\r\n    }\r\n\r\n    border(context: CellContext, { borderColor = this.theme.borderColor, lineWidth = 1 }: { borderColor?: ColorsPropertyDefine; lineWidth?: number } = {}): void {\r\n    \tconst rect = context.getRect()\r\n\r\n    \tthis.drawBorderWithClip(context, (ctx) => {\r\n    \t\tconst { col, row } = context\r\n    \t\tconst borderColors = getColor(borderColor, col, row, this._grid, ctx)\r\n\r\n    \t\tif (lineWidth === 1) {\r\n    \t\t\tctx.lineWidth = 1\r\n    \t\t\tstrokeRect(ctx, borderColors, rect.left - 0.5, rect.top - 0.5, rect.width, rect.height)\r\n    \t\t} else if (lineWidth === 2) {\r\n    \t\t\tctx.lineWidth = 2\r\n    \t\t\tstrokeRect(ctx, borderColors, rect.left, rect.top, rect.width - 1, rect.height - 1)\r\n    \t\t} else {\r\n    \t\t\tctx.lineWidth = lineWidth\r\n    \t\t\tconst startOffset = lineWidth / 2 - 1\r\n    \t\t\tstrokeRect(ctx, borderColors, rect.left + startOffset, rect.top + startOffset, rect.width - lineWidth + 1, rect.height - lineWidth + 1)\r\n    \t\t}\r\n    \t})\r\n    }\r\n\r\n    // Unused in main\r\n    borderWithState(context: CellContext, option: { borderColor?: ColorsPropertyDefine; lineWidth?: number } = {}): void {\r\n    \tconst rect = context.getRect()\r\n    \tconst sel = context.getSelection()\r\n    \tconst { col, row } = context\r\n\r\n    \t//\r\n    \tif (cellEquals(sel.select, context)) {\r\n    \t\toption.borderColor = this.theme.highlightBorderColor\r\n    \t\toption.lineWidth = 2\r\n    \t\tthis.border(context, option)\r\n    \t} else {\r\n    \t\t// header color\r\n    \t\tconst isFrozenCell = this._grid.isFrozenCell(col, row)\r\n    \t\tif (isFrozenCell?.row) {\r\n    \t\t\toption.borderColor = this.theme.frozenRowsBorderColor\r\n    \t\t}\r\n\r\n    \t\toption.lineWidth = 1\r\n    \t\tthis.border(context, option)\r\n\r\n    \t\t//\r\n    \t\tconst sel = this._grid.selection.select\r\n    \t\tif (sel.col + 1 === col && sel.row === row) {\r\n    \t\t\t//\r\n    \t\t\tthis.drawBorderWithClip(context, (ctx) => {\r\n    \t\t\t\tconst borderColors = toBoxArray(getColor(this.theme.highlightBorderColor, sel.col, sel.row, this._grid, ctx))\r\n    \t\t\t\tctx.lineWidth = 1\r\n    \t\t\t\tctx.strokeStyle = borderColors[1] || ctx.strokeStyle\r\n    \t\t\t\tctx.beginPath()\r\n    \t\t\t\tctx.moveTo(rect.left - 0.5, rect.top)\r\n    \t\t\t\tctx.lineTo(rect.left - 0.5, rect.bottom)\r\n    \t\t\t\tctx.stroke()\r\n    \t\t\t})\r\n    \t\t} else if (sel.col === col && sel.row + 1 === row) {\r\n    \t\t\t//\r\n    \t\t\tthis.drawBorderWithClip(context, (ctx) => {\r\n    \t\t\t\tconst borderColors = toBoxArray(getColor(this.theme.highlightBorderColor, sel.col, sel.row, this._grid, ctx))\r\n    \t\t\t\tctx.lineWidth = 1\r\n    \t\t\t\tctx.strokeStyle = borderColors[0] || ctx.strokeStyle\r\n    \t\t\t\tctx.beginPath()\r\n    \t\t\t\tctx.moveTo(rect.left, rect.top - 0.5)\r\n    \t\t\t\tctx.lineTo(rect.right, rect.top - 0.5)\r\n    \t\t\t\tctx.stroke()\r\n    \t\t\t})\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    buildCheckBoxInline(\r\n    \t\tcheck: boolean,\r\n    \t\tcontext: CellContext,\r\n    \t\toption: {\r\n            animElapsedTime?: number;\r\n            uncheckBgColor?: ColorPropertyDefine;\r\n            checkBgColor?: ColorPropertyDefine;\r\n            borderColor?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n        } = {}\r\n    ): InlineDrawer {\r\n    \t// eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    \tconst self = this\r\n    \tconst ctx = context.getContext()\r\n    \tconst boxWidth = canvashelper.measureCheckbox(ctx).width\r\n    \treturn new InlineDrawer({\r\n    \t\tdraw,\r\n    \t\twidth: boxWidth + 3,\r\n    \t\theight: boxWidth + 1,\r\n    \t\tcolor: undefined\r\n    \t})\r\n\r\n    \tfunction draw({ ctx, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n    \t\tconst { col, row } = context\r\n    \t\tdrawCheckbox(ctx, rect, col, row, check, self, option, {\r\n    \t\t\toffset: offset + 1,\r\n    \t\t\tpadding: {\r\n    \t\t\t\tleft: offsetLeft + 1,\r\n    \t\t\t\tright: offsetRight,\r\n    \t\t\t\ttop: offsetTop,\r\n    \t\t\t\tbottom: offsetBottom\r\n    \t\t\t}\r\n    \t\t})\r\n    \t}\r\n    }\r\n\r\n    checkbox(\r\n    \t\tcheck: boolean,\r\n    \t\tcontext: CellContext,\r\n    \t\toption: {\r\n            animElapsedTime?: number;\r\n            uncheckBgColor?: ColorPropertyDefine;\r\n            checkBgColor?: ColorPropertyDefine;\r\n            borderColor?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n        } = {}\r\n    ): void {\r\n    \tthis.drawWithClip(context, (ctx) => {\r\n    \t\tconst { col, row } = context\r\n    \t\tdrawCheckbox(ctx, context.getRect(), col, row, check, this, option)\r\n    \t})\r\n    }\r\n\r\n    radioButton(\r\n    \t\tcheck: boolean,\r\n    \t\tcontext: CellContext,\r\n    \t\toption: {\r\n            animElapsedTime?: number;\r\n            checkColor?: ColorPropertyDefine;\r\n            uncheckBorderColor?: ColorPropertyDefine;\r\n            checkBorderColor?: ColorPropertyDefine;\r\n            bgColor?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n        } = {}\r\n    ): void {\r\n    \tthis.drawWithClip(context, (ctx) => {\r\n    \t\tconst { col, row } = context\r\n    \t\tdrawRadioButton(ctx, context.getRect(), col, row, check, this, option)\r\n    \t})\r\n    }\r\n\r\n    button(\r\n    \t\tcaption: string,\r\n    \t\tcontext: CellContext,\r\n    \t\t{\r\n    \t\t\tbgColor = this.theme.button.bgColor,\r\n    \t\t\tpadding,\r\n    \t\t\toffset = 2,\r\n    \t\t\tcolor = this.theme.button.color,\r\n    \t\t\ttextAlign = 'center',\r\n    \t\t\ttextBaseline = 'middle',\r\n    \t\t\tshadow,\r\n    \t\t\tfont,\r\n    \t\t\ttextOverflow = 'clip',\r\n    \t\t\ticons\r\n    \t\t}: {\r\n            bgColor?: ColorPropertyDefine;\r\n            padding?: number | string | (number | string)[];\r\n            offset?: number;\r\n            color?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n            shadow?: canvashelper.DrawButtonOption['shadow'];\r\n            font?: FontPropertyDefine;\r\n            textOverflow?: TextOverflow;\r\n            icons?: SimpleColumnIconOption[];\r\n        } = {}\r\n    ): void {\r\n    \tconst rect = context.getRect()\r\n\r\n    \tthis.drawWithClip(context, (ctx) => {\r\n    \t\tfont = getFont(font, context.col, context.row, this._grid, ctx)\r\n    \t\tconst { col, row } = context\r\n    \t\tconst paddingNums = this.toBoxPixelArray(padding || rect.height / 8, context, font)\r\n    \t\tconst left = rect.left + paddingNums[3]\r\n    \t\tconst top = rect.top + paddingNums[0]\r\n    \t\tconst width = rect.width - paddingNums[1] - paddingNums[3]\r\n    \t\tconst height = rect.height - paddingNums[0] - paddingNums[2]\r\n\r\n    \t\tbgColor = getColor(bgColor, context.col, context.row, this._grid, ctx)\r\n\r\n    \t\tcanvashelper.drawButton(ctx, left, top, width, height, {\r\n    \t\t\tbgColor,\r\n    \t\t\tradius: rect.height / 8,\r\n    \t\t\t// offset,\r\n    \t\t\tshadow\r\n    \t\t})\r\n    \t\t_inlineRect(this._grid, ctx, caption, new Rect(left, top, width, height), col, row, {\r\n    \t\t\toffset,\r\n    \t\t\tcolor,\r\n    \t\t\ttextAlign,\r\n    \t\t\ttextBaseline,\r\n    \t\t\tfont,\r\n    \t\t\ttextOverflow,\r\n    \t\t\ticons\r\n    \t\t})\r\n    \t})\r\n    }\r\n\r\n    testFontLoad(font: string | undefined, value: string, context: CellContext): boolean {\r\n    \treturn testFontLoad(font, value, context, this._grid)\r\n    }\r\n}\r\n","import * as icons from './internal/icons'\r\nimport * as themes from './themes'\r\n// import { CachedDataSource, DataSource } from './data'\r\nimport { CachedDataSource } from './data/CachedDataSource'\r\nimport { DataSource } from './data/DataSource'\r\nimport type {\r\n\tCellAddress,\r\n\tCellContext,\r\n\tCellRange,\r\n\tColorPropertyDefine,\r\n\tColorsPropertyDefine,\r\n\tColumnIconOption,\r\n\tColumnStyleOption,\r\n\tColumnTypeAPI,\r\n\tDrawGridAPI,\r\n\tEventListenerId,\r\n\tFieldData,\r\n\tFieldDef,\r\n\tHeaderValues,\r\n\tLayoutObjectId,\r\n\tListGridAPI,\r\n\tListGridEventHandlersEventMap,\r\n\tListGridEventHandlersReturnMap,\r\n\tMaybePromise,\r\n\tMaybePromiseOrUndef,\r\n\tMessage,\r\n\tPasteCellEvent,\r\n\tSelectedCellEvent,\r\n\tSetPasteValueTestData,\r\n\tSortState,\r\n\tThemeDefine\r\n} from './ts-types'\r\nimport { ColumnDefine, GroupHeaderDefine, HeaderDefine, HeadersDefine, MultiLayoutMap, SimpleHeaderLayoutMap } from './list-grid/layout-map'\r\nimport type { DrawGridConstructorOptions, DrawGridProtected } from './core/DrawGrid'\r\nimport type { LayoutDefine, LayoutMapAPI } from './list-grid/layout-map'\r\nimport { MessageHandler, hasMessage } from './columns/message/MessageHandler'\r\nimport { cellEquals, event, isPromise, obj, omit, then } from './internal/utils'\r\nimport type { BaseColumn } from './columns/type/BaseColumn'\r\nimport { BaseStyle } from './columns/style'\r\nimport type { ColumnData } from './list-grid/layout-map/api'\r\nimport type { DrawCellInfo } from './ts-types-internal'\r\nimport { DrawGrid } from './core/DrawGrid'\r\nimport { GridCanvasHelper } from './GridCanvasHelper'\r\nimport { BaseStyle as HeaderBaseStyle } from './header/style'\r\nimport { LG_EVENT_TYPE } from './list-grid/LG_EVENT_TYPE'\r\nimport { Rect } from './internal/Rect'\r\nimport type { Theme } from './themes/theme'\r\nimport { TooltipHandler } from './tooltip/TooltipHandler'\r\n//protected symbol\r\nimport { getProtectedSymbol } from './internal/symbolManager'\r\nimport { parsePasteRangeBoxValues } from './internal/paste-utils'\r\n\r\n/** @private */\r\nconst _ = getProtectedSymbol()\r\n\r\n//private methods\r\n/** @private */\r\nfunction _getCellRange<T>(grid: ListGrid<T>, col: number, row: number): CellRange {\r\n\treturn grid[_].layoutMap.getCellRange(col, row)\r\n}\r\n\r\n/** @private */\r\nfunction _updateRect<T>(grid: ListGrid<T>, col: number, row: number, context: CellContext): void {\r\n\tcontext.setRectFilter((rect) => {\r\n\t\tlet { left, right, top, bottom } = rect\r\n\t\tconst {\r\n\t\t\tstart: { col: startCol, row: startRow },\r\n\t\t\tend: { col: endCol, row: endRow }\r\n\t\t} = _getCellRange(grid, col, row)\r\n\t\tfor (let c = col - 1; c >= startCol; c--) {\r\n\t\t\tleft -= grid.getColWidth(c)\r\n\t\t}\r\n\t\tfor (let c = col + 1; c <= endCol; c++) {\r\n\t\t\tright += grid.getColWidth(c)\r\n\t\t}\r\n\t\tfor (let r = row - 1; r >= startRow; r--) {\r\n\t\t\ttop -= grid.getRowHeight(r)\r\n\t\t}\r\n\t\tfor (let r = row + 1; r <= endRow; r++) {\r\n\t\t\tbottom += grid.getRowHeight(r)\r\n\t\t}\r\n\t\treturn Rect.bounds(left, top, right, bottom)\r\n\t})\r\n}\r\n\r\n/** @private */\r\nfunction _getCellValue<T>(grid: ListGrid<T>, col: number, row: number): FieldData {\r\n\tif (row < grid[_].layoutMap.headerRowCount) {\r\n\t\tconst { caption } = grid[_].layoutMap.getHeader(col, row)\r\n\t\treturn typeof caption === 'function' ? caption() : caption\r\n\t} else {\r\n\t\tconst { field } = grid[_].layoutMap.getBody(col, row)\r\n\t\treturn _getField(grid, field, row)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _setCellValue<T>(\r\n\t\tgrid: ListGrid<T>,\r\n\t\tcol: number,\r\n\t\trow: number,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tvalue: any\r\n): MaybePromise<boolean> {\r\n\tif (row < grid[_].layoutMap.headerRowCount) {\r\n\t\t// nop\r\n\t\treturn false\r\n\t} else {\r\n\t\tconst { field } = grid[_].layoutMap.getBody(col, row)\r\n\t\tif (field == null) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tconst index = _getRecordIndexByRow(grid, row)\r\n\t\treturn grid[_].dataSource.setField(index, field, value)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _getCellMessage<T>(grid: ListGrid<T>, col: number, row: number): FieldData {\r\n\tif (row < grid[_].layoutMap.headerRowCount) {\r\n\t\treturn null\r\n\t} else {\r\n\t\tconst { message } = grid[_].layoutMap.getBody(col, row)\r\n\t\tif (!message) {\r\n\t\t\treturn null\r\n\t\t}\r\n\t\tif (!Array.isArray(message)) {\r\n\t\t\treturn _getField(grid, message as FieldDef<T>, row)\r\n\t\t}\r\n\t\tconst promises: Promise<Message>[] = []\r\n\t\tfor (let index = 0; index < message.length; index++) {\r\n\t\t\tconst msg = _getField(grid, message[index] as FieldDef<T>, row)\r\n\t\t\tif (isPromise(msg)) {\r\n\t\t\t\tpromises.push(msg)\r\n\t\t\t} else if (hasMessage(msg)) {\r\n\t\t\t\treturn msg\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!promises.length) {\r\n\t\t\treturn null\r\n\t\t}\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tpromises.forEach((p) => {\r\n\t\t\t\tp.then((msg) => {\r\n\t\t\t\t\tif (hasMessage(msg)) {\r\n\t\t\t\t\t\tresolve(msg)\r\n\t\t\t\t\t}\r\n\t\t\t\t}, reject)\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _getCellIcon0<T>(grid: ListGrid<T>, icon: ColumnIconOption<T>, row: number): ColumnIconOption<T>;\r\nfunction _getCellIcon0<T>(grid: ListGrid<T>, icon: ColumnIconOption<T>[], row: number): ColumnIconOption<T>[];\r\nfunction _getCellIcon0<T>(grid: ListGrid<T>, icon: ColumnIconOption<T> | ColumnIconOption<T>[], row: number): ColumnIconOption<T> | ColumnIconOption<T>[];\r\nfunction _getCellIcon0<T>(grid: ListGrid<T>, icon: ColumnIconOption<T> | ColumnIconOption<T>[], row: number): ColumnIconOption<T> | ColumnIconOption<T>[] {\r\n\tif (Array.isArray(icon)) {\r\n\t\treturn icon.map((i) => _getCellIcon0(grid, i, row))\r\n\t}\r\n\tif (!obj.isObject(icon) || typeof icon === 'function') {\r\n\t\treturn _getField(grid, icon, row)\r\n\t}\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tconst retIcon: any = {}\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tconst iconOpt: any = icon\r\n\ticons.iconPropKeys.forEach((k) => {\r\n\t\tif (iconOpt[k]) {\r\n\t\t\tconst f = _getField(grid, iconOpt[k], row)\r\n\t\t\tif (f != null) {\r\n\t\t\t\tretIcon[k] = f\r\n\t\t\t} else {\r\n\t\t\t\tif (!_hasField(grid, iconOpt[k], row)) {\r\n\t\t\t\t\tretIcon[k] = iconOpt[k]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\treturn retIcon\r\n}\r\n\r\n/** @private */\r\nfunction _getCellIcon<T>(grid: ListGrid<T>, col: number, row: number): ColumnIconOption<T> | ColumnIconOption<T>[] | null {\r\n\tconst { icon } = grid[_].layoutMap.getBody(col, row)\r\n\tif (icon == null) {\r\n\t\treturn null\r\n\t}\r\n\treturn _getCellIcon0(grid, icon, row)\r\n}\r\n\r\n/** @private */\r\nfunction _getField<T>(grid: ListGrid<T>, field: FieldDef<T> | undefined, row: number): FieldData {\r\n\tif (field == null) {\r\n\t\treturn null\r\n\t}\r\n\tif (row < grid[_].layoutMap.headerRowCount) {\r\n\t\treturn null\r\n\t} else {\r\n\t\tconst index = _getRecordIndexByRow(grid, row)\r\n\t\treturn grid[_].dataSource.getField(index, field)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _hasField<T>(grid: ListGrid<T>, field: FieldDef<T>, row: number): boolean {\r\n\tif (field == null) {\r\n\t\treturn false\r\n\t}\r\n\tif (row < grid[_].layoutMap.headerRowCount) {\r\n\t\treturn false\r\n\t} else {\r\n\t\tconst index = _getRecordIndexByRow(grid, row)\r\n\t\treturn grid[_].dataSource.hasField(index, field)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _onDrawValue<T>(\r\n\t\tgrid: ListGrid<T>,\r\n\t\tcellValue: MaybePromise<unknown>,\r\n\t\tcontext: CellContext,\r\n\t\t{ col, row }: CellAddress,\r\n\t\tstyle: ColumnStyleOption | null | undefined,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tdraw: BaseColumn<T, any>['onDrawCell']\r\n): MaybePromise<void> {\r\n\tconst helper = grid[_].gridCanvasHelper\r\n\r\n\tconst drawCellBg = ({ bgColor }: { bgColor?: ColorPropertyDefine } = {}): void => {\r\n\t\tconst fillOpt = {\r\n\t\t\tfillColor: bgColor\r\n\t\t}\r\n\t\t//cell\r\n\t\thelper.fillCellWithState(context, fillOpt)\r\n\t}\r\n\tconst drawCellBorder = (): void => {\r\n\t\tif (context.col === grid.frozenColCount - 1) {\r\n\t\t\t//\r\n\t\t\tconst rect = context.getRect()\r\n\t\t\thelper.drawWithClip(context, (ctx) => {\r\n\t\t\t\tconst borderColor = context.row >= grid.frozenRowCount ? helper.theme.borderColor : helper.theme.frozenRowsBorderColor\r\n\r\n\t\t\t\tconst borderColors = helper.toBoxArray(helper.getColor(borderColor, context.col, context.row, ctx))\r\n\t\t\t\tif (borderColors[1]) {\r\n\t\t\t\t\tctx.lineWidth = 1\r\n\t\t\t\t\tctx.strokeStyle = borderColors[1]\r\n\t\t\t\t\tctx.beginPath()\r\n\t\t\t\t\tctx.moveTo(rect.right - 2.5, rect.top)\r\n\t\t\t\t\tctx.lineTo(rect.right - 2.5, rect.bottom)\r\n\t\t\t\t\tctx.stroke()\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t_borderWithState(grid, helper, context)\r\n\t}\r\n\r\n\tconst drawCellBase = ({ bgColor }: { bgColor?: ColorPropertyDefine } = {}): void => {\r\n\t\tdrawCellBg({ bgColor })\r\n\t\tdrawCellBorder()\r\n\t}\r\n\tconst info: DrawCellInfo<T> = {\r\n\t\tgetRecord: () => grid.getRowRecord(row),\r\n\t\tgetIcon: () => _getCellIcon(grid, col, row),\r\n\t\tgetMessage: () => _getCellMessage(grid, col, row),\r\n\t\tmessageHandler: grid[_].messageHandler,\r\n\t\tstyle,\r\n\t\tdrawCellBase,\r\n\t\tdrawCellBg,\r\n\t\tdrawCellBorder\r\n\t}\r\n\r\n\treturn draw(cellValue, info, context, grid)\r\n}\r\n\r\n/** @private */\r\nfunction _borderWithState<T>(grid: ListGrid<T>, helper: GridCanvasHelper<T>, context: CellContext): void {\r\n\tconst { col, row } = context\r\n\tconst sel = grid.selection.select\r\n\tconst { layoutMap } = grid[_]\r\n\r\n\tconst rect = context.getRect()\r\n\tconst option: { borderColor?: ColorsPropertyDefine; lineWidth?: number } = {}\r\n\r\n\tconst selRecordIndex = layoutMap.getRecordIndexByRow(sel.row)\r\n\tconst selId = layoutMap.getCellId(sel.col, sel.row)\r\n\r\n\tfunction isSelectCell(col: number, row: number): boolean {\r\n\t\tif (col === sel.col && row === sel.row) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\treturn selId != null && layoutMap.getCellId(col, row) === selId && layoutMap.getRecordIndexByRow(row) === selRecordIndex\r\n\t}\r\n\r\n\t//\r\n\tif (isSelectCell(col, row)) {\r\n\t\toption.borderColor = helper.theme.highlightBorderColor\r\n\t\toption.lineWidth = 2\r\n\t\thelper.border(context, option)\r\n\t} else {\r\n\t\toption.lineWidth = 1\r\n\t\t// header color\r\n\t\tconst isFrozenCell = grid.isFrozenCell(col, row)\r\n\t\tif (isFrozenCell?.row) {\r\n\t\t\toption.borderColor = helper.theme.frozenRowsBorderColor\r\n\t\t}\r\n\t\thelper.border(context, option)\r\n\r\n\t\t//\r\n\t\tif (col > 0 && isSelectCell(col - 1, row)) {\r\n\t\t\t//\r\n\t\t\thelper.drawBorderWithClip(context, (ctx) => {\r\n\t\t\t\tconst borderColors = helper.toBoxArray(helper.getColor(helper.theme.highlightBorderColor, sel.col, sel.row, ctx))\r\n\t\t\t\tif (borderColors[1]) {\r\n\t\t\t\t\tctx.lineWidth = 1\r\n\t\t\t\t\tctx.strokeStyle = borderColors[1]\r\n\t\t\t\t\tctx.beginPath()\r\n\t\t\t\t\tctx.moveTo(rect.left - 0.5, rect.top)\r\n\t\t\t\t\tctx.lineTo(rect.left - 0.5, rect.bottom)\r\n\t\t\t\t\tctx.stroke()\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else if (row > 0 && isSelectCell(col, row - 1)) {\r\n\t\t\t//\r\n\t\t\thelper.drawBorderWithClip(context, (ctx) => {\r\n\t\t\t\tconst borderColors = helper.toBoxArray(helper.getColor(helper.theme.highlightBorderColor, sel.col, sel.row, ctx))\r\n\t\t\t\tif (borderColors[0]) {\r\n\t\t\t\t\tctx.lineWidth = 1\r\n\t\t\t\t\tctx.strokeStyle = borderColors[0]\r\n\t\t\t\t\tctx.beginPath()\r\n\t\t\t\t\tctx.moveTo(rect.left, rect.top - 0.5)\r\n\t\t\t\t\tctx.lineTo(rect.right, rect.top - 0.5)\r\n\t\t\t\t\tctx.stroke()\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _refreshHeader<T>(grid: ListGrid<T>): void {\r\n\tconst protectedSpace = grid[_]\r\n\tif (protectedSpace.headerEvents) {\r\n\t\tprotectedSpace.headerEvents.forEach((id) => grid.unlisten(id))\r\n\t}\r\n\r\n\tconst headerEvents: EventListenerId[] = (grid[_].headerEvents = [])\r\n\r\n\theaderEvents.forEach((id) => grid.unlisten(id))\r\n\tlet layoutMap: LayoutMapAPI<T>\r\n\tif (protectedSpace.layout && (!Array.isArray(protectedSpace.layout) || protectedSpace.layout.length > 0)) {\r\n\t\tlayoutMap = protectedSpace.layoutMap = new MultiLayoutMap(protectedSpace.layout)\r\n\t} else {\r\n\t\tlayoutMap = protectedSpace.layoutMap = new SimpleHeaderLayoutMap(protectedSpace.header ?? [])\r\n\t}\r\n\tlayoutMap.headerObjects.forEach((cell) => {\r\n\t\tconst ids = cell.headerType.bindGridEvent(grid, cell.id)\r\n\t\theaderEvents.push(...ids)\r\n\t\tif (cell.style) {\r\n\t\t\tif (cell.style instanceof HeaderBaseStyle) {\r\n\t\t\t\tconst id = cell.style.listen(HeaderBaseStyle.EVENT_TYPE.CHANGE_STYLE, () => {\r\n\t\t\t\t\tgrid.invalidate()\r\n\t\t\t\t})\r\n\t\t\t\theaderEvents.push(id)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (cell.action) {\r\n\t\t\tconst ids = cell.action.bindGridEvent(grid, cell.id)\r\n\t\t\theaderEvents.push(...ids)\r\n\t\t}\r\n\t})\r\n\tlayoutMap.columnObjects.forEach((col) => {\r\n\t\tif (col.action) {\r\n\t\t\tconst ids = col.action.bindGridEvent(grid, col.id)\r\n\t\t\theaderEvents.push(...ids)\r\n\t\t}\r\n\t\tif (col.columnType) {\r\n\t\t\tconst ids = col.columnType.bindGridEvent(grid, col.id)\r\n\t\t\theaderEvents.push(...ids)\r\n\t\t}\r\n\t\tif (col.style) {\r\n\t\t\tif (col.style instanceof BaseStyle) {\r\n\t\t\t\tconst id = col.style.listen(BaseStyle.EVENT_TYPE.CHANGE_STYLE, () => {\r\n\t\t\t\t\tgrid.invalidate()\r\n\t\t\t\t})\r\n\t\t\t\theaderEvents.push(id)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tfor (let col = 0; col < layoutMap.columnWidths.length; col++) {\r\n\t\tconst column = layoutMap.columnWidths[col]\r\n\t\tconst { width, minWidth, maxWidth } = column\r\n\t\tif (width && (width > 0 || typeof width === 'string')) {\r\n\t\t\tgrid.setColWidth(col, width)\r\n\t\t}\r\n\t\tif (minWidth && (minWidth > 0 || typeof minWidth === 'string')) {\r\n\t\t\tgrid.setMinColWidth(col, minWidth)\r\n\t\t}\r\n\t\tif (maxWidth && (maxWidth > 0 || typeof maxWidth === 'string')) {\r\n\t\t\tgrid.setMaxColWidth(col, maxWidth)\r\n\t\t}\r\n\t}\r\n\tconst { headerRowHeight } = grid[_]\r\n\tfor (let row = 0; row < layoutMap.headerRowCount; row++) {\r\n\t\tconst height = Array.isArray(headerRowHeight) ? headerRowHeight[row] : headerRowHeight\r\n\t\tif (height && height > 0) {\r\n\t\t\tgrid.setRowHeight(row, height)\r\n\t\t}\r\n\t}\r\n\tgrid.colCount = layoutMap.colCount\r\n\t_refreshRowCount(grid)\r\n\tgrid.frozenRowCount = layoutMap.headerRowCount\r\n}\r\n\r\n/** @private */\r\nfunction _refreshRowCount<T>(grid: ListGrid<T>): void {\r\n\tconst { layoutMap } = grid[_]\r\n\tgrid.rowCount = grid[_].dataSource.length * layoutMap.bodyRowCount + layoutMap.headerRowCount\r\n}\r\n\r\n/** @private */\r\nfunction _tryWithUpdateDataSource<T>(grid: ListGrid<T>, fn: (grid: ListGrid<T>) => void): void {\r\n\tconst { dataSourceEventIds } = grid[_]\r\n\r\n\tif (dataSourceEventIds) {\r\n\t\tdataSourceEventIds.forEach((id) => grid[_].handler.off(id))\r\n\t}\r\n\r\n\tfn(grid)\r\n\r\n\tgrid[_].dataSourceEventIds = [\r\n\t\tgrid[_].handler.on(grid[_].dataSource, DataSource.EVENT_TYPE.UPDATED_LENGTH, () => {\r\n\t\t\t_refreshRowCount(grid)\r\n\t\t\tgrid.invalidate()\r\n\t\t}),\r\n\t\tgrid[_].handler.on(grid[_].dataSource, DataSource.EVENT_TYPE.UPDATED_ORDER, () => {\r\n\t\t\tgrid.invalidate()\r\n\t\t})\r\n\t]\r\n}\r\n\r\n/** @private */\r\nfunction _setRecords<T>(grid: ListGrid<T>, records: T[] = []): void {\r\n\t_tryWithUpdateDataSource(grid, () => {\r\n\t\tgrid[_].records = records\r\n\t\tconst newDataSource = (grid[_].dataSource = CachedDataSource.ofArray(records))\r\n\t\tgrid.addDisposable(newDataSource)\r\n\t})\r\n}\r\n\r\n/** @private */\r\nfunction _setDataSource<T>(grid: ListGrid<T>, dataSource: DataSource<T>): void {\r\n\t_tryWithUpdateDataSource(grid, () => {\r\n\t\tif (dataSource) {\r\n\t\t\tif (dataSource instanceof DataSource) {\r\n\t\t\t\tgrid[_].dataSource = dataSource\r\n\t\t\t} else {\r\n\t\t\t\tconst newDataSource = (grid[_].dataSource = new CachedDataSource(dataSource))\r\n\t\t\t\tgrid.addDisposable(newDataSource)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tgrid[_].dataSource = DataSource.EMPTY\r\n\t\t}\r\n\t\tgrid[_].records = null\r\n\t})\r\n}\r\n\r\n/** @private */\r\nfunction _getRecordIndexByRow<T>(grid: ListGrid<T>, row: number): number {\r\n\tconst { layoutMap } = grid[_]\r\n\treturn layoutMap.getRecordIndexByRow(row)\r\n}\r\n\r\n/** @private */\r\nfunction _onRangePaste<T>(this: ListGrid<T>, text: string, test: (data: SetPasteValueTestData<T>) => boolean = (): boolean => true): void {\r\n\tconst { layoutMap } = this[_]\r\n\tconst selectionRange = this.selection.range\r\n\tconst { start } = this.getCellRange(selectionRange.start.col, selectionRange.start.row)\r\n\tconst { end } = this.getCellRange(selectionRange.end.col, selectionRange.end.row)\r\n\tconst values = parsePasteRangeBoxValues(text)\r\n\r\n\tconst pasteRowCount = Math.min(Math.max(end.row - start.row + 1, values.rowCount), this.rowCount - start.row)\r\n\tconst pasteColCount = Math.min(Math.max(end.col - start.col + 1, values.colCount), this.colCount - start.col)\r\n\r\n\tlet hasEditable = false\r\n\tconst actionColumnsBox: ColumnData<T>[][] = []\r\n\tfor (let bodyRow = 0; bodyRow < layoutMap.bodyRowCount; bodyRow++) {\r\n\t\tconst actionColumnsRow: ColumnData<T>[] = []\r\n\t\tactionColumnsBox.push(actionColumnsRow)\r\n\t\tfor (let offsetCol = 0; offsetCol < pasteColCount; offsetCol++) {\r\n\t\t\tconst body = layoutMap.getBody(start.col + offsetCol, bodyRow + layoutMap.headerRowCount)\r\n\t\t\tactionColumnsRow[offsetCol] = body\r\n\t\t\tif (!hasEditable && body.action?.editable) {\r\n\t\t\t\thasEditable = true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (!hasEditable) {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst startRow = layoutMap.getRecordStartRowByRecordIndex(layoutMap.getRecordIndexByRow(start.row))\r\n\tconst startRowOffset = start.row - startRow\r\n\r\n\tlet duplicate: { [key: number]: boolean } = {}\r\n\tlet actionRow = startRowOffset\r\n\tlet valuesRow = 0\r\n\tfor (let offsetRow = 0; offsetRow < pasteRowCount; offsetRow++) {\r\n\t\tlet valuesCol = 0\r\n\t\tfor (let offsetCol = 0; offsetCol < pasteColCount; offsetCol++) {\r\n\t\t\tconst { action, id } = actionColumnsBox[actionRow][offsetCol]\r\n\t\t\tif (!duplicate[id as number] && action?.editable) {\r\n\t\t\t\tduplicate[id as number] = true\r\n\t\t\t\tconst col = start.col + offsetCol\r\n\t\t\t\tconst row = start.row + offsetRow\r\n\t\t\t\tconst cellValue = values.getCellValue(valuesCol, valuesRow)\r\n\r\n\t\t\t\tthen(this.getRowRecord(row), (record) => {\r\n\t\t\t\t\tthen(_getCellValue(this, col, row), (oldValue) => {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\ttest({\r\n\t\t\t\t\t\t\t\tgrid: this,\r\n\t\t\t\t\t\t\t\trecord: record as T,\r\n\t\t\t\t\t\t\t\tcol,\r\n\t\t\t\t\t\t\t\trow,\r\n\t\t\t\t\t\t\t\tvalue: cellValue,\r\n\t\t\t\t\t\t\t\toldValue\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\taction.onPasteCellRangeBox(this, { col, row }, cellValue)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvaluesCol++\r\n\t\t\tif (valuesCol >= values.colCount) {\r\n\t\t\t\tvaluesCol = 0\r\n\t\t\t}\r\n\t\t}\r\n\t\tactionRow++\r\n\t\tif (actionRow >= layoutMap.bodyRowCount) {\r\n\t\t\tactionRow = 0\r\n\t\t\tduplicate = {}\r\n\t\t}\r\n\t\tvaluesRow++\r\n\t\tif (valuesRow >= values.rowCount) {\r\n\t\t\tvaluesRow = 0\r\n\t\t}\r\n\t}\r\n\r\n\tconst newEnd = {\r\n\t\tcol: start.col + pasteColCount - 1,\r\n\t\trow: start.row + pasteRowCount - 1\r\n\t}\r\n\tthis.selection.range = {\r\n\t\tstart,\r\n\t\tend: newEnd\r\n\t}\r\n\tthis.invalidateCellRange(this.selection.range)\r\n}\r\n\r\n/** @private */\r\nfunction _onRangeDelete<T>(this: ListGrid<T>): void {\r\n\tconst { layoutMap } = this[_]\r\n\tconst selectionRange = this.selection.range\r\n\tconst { start } = this.getCellRange(selectionRange.start.col, selectionRange.start.row)\r\n\tconst { end } = this.getCellRange(selectionRange.end.col, selectionRange.end.row)\r\n\r\n\tconst deleteRowCount = Math.min(end.row - start.row + 1, this.rowCount - start.row)\r\n\tconst deleteColCount = Math.min(end.col - start.col + 1, this.colCount - start.col)\r\n\r\n\tlet hasEditable = false\r\n\tconst actionColumnsBox: ColumnData<T>[][] = []\r\n\tfor (let bodyRow = 0; bodyRow < layoutMap.bodyRowCount; bodyRow++) {\r\n\t\tconst actionColumnsRow: ColumnData<T>[] = []\r\n\t\tactionColumnsBox.push(actionColumnsRow)\r\n\t\tfor (let offsetCol = 0; offsetCol < deleteColCount; offsetCol++) {\r\n\t\t\tconst body = layoutMap.getBody(start.col + offsetCol, bodyRow + layoutMap.headerRowCount)\r\n\t\t\tactionColumnsRow[offsetCol] = body\r\n\t\t\tif (!hasEditable && body.action?.editable) {\r\n\t\t\t\thasEditable = true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (!hasEditable) {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst startRow = layoutMap.getRecordStartRowByRecordIndex(layoutMap.getRecordIndexByRow(start.row))\r\n\tconst startRowOffset = start.row - startRow\r\n\r\n\tlet duplicate: { [key: number]: boolean } = {}\r\n\tlet actionRow = startRowOffset\r\n\tfor (let offsetRow = 0; offsetRow < deleteRowCount; offsetRow++) {\r\n\t\tfor (let offsetCol = 0; offsetCol < deleteColCount; offsetCol++) {\r\n\t\t\tconst { action, id } = actionColumnsBox[actionRow][offsetCol]\r\n\t\t\tif (!duplicate[id as number] && action?.editable) {\r\n\t\t\t\tduplicate[id as number] = true\r\n\t\t\t\tconst col = start.col + offsetCol\r\n\t\t\t\tconst row = start.row + offsetRow\r\n\r\n\t\t\t\tthen(this.getRowRecord(row), (_record) => {\r\n\t\t\t\t\tthen(_getCellValue(this, col, row), (_oldValue) => {\r\n\t\t\t\t\t\taction.onDeleteCellRangeBox(this, { col, row })\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tactionRow++\r\n\t\tif (actionRow >= layoutMap.bodyRowCount) {\r\n\t\t\tactionRow = 0\r\n\t\t\tduplicate = {}\r\n\t\t}\r\n\t}\r\n\r\n\tthis.invalidateCellRange(selectionRange)\r\n}\r\n\r\n//end private methods\r\n//\r\n//\r\n//\r\n\r\n/** @protected */\r\ninterface ListGridProtected<T> extends DrawGridProtected {\r\n    dataSourceEventIds?: EventListenerId[];\r\n    headerEvents?: EventListenerId[];\r\n    layoutMap: LayoutMapAPI<T>;\r\n    headerValues?: HeaderValues;\r\n    tooltipHandler: TooltipHandler<T>;\r\n    messageHandler: MessageHandler<T>;\r\n    theme: Theme | null;\r\n    headerRowHeight: number[] | number;\r\n    header: HeadersDefine<T>;\r\n    layout: LayoutDefine<T>;\r\n    gridCanvasHelper: GridCanvasHelper<T>;\r\n    sortState: SortState;\r\n    dataSource: DataSource<T>;\r\n    records?: T[] | null;\r\n    allowRangePaste: boolean;\r\n}\r\n\r\nexport { ListGridProtected }\r\n\r\nexport interface ListGridConstructorOptions<T> extends DrawGridConstructorOptions {\r\n    /**\r\n     * Simple header property\r\n     */\r\n    header?: HeadersDefine<T>;\r\n    /**\r\n     * Layout property\r\n     */\r\n    layout?: LayoutDefine<T>;\r\n    /**\r\n     * Header row height(s)\r\n     */\r\n    headerRowHeight?: number[] | number;\r\n    /**\r\n     * Records data source\r\n     */\r\n    dataSource?: DataSource<T>;\r\n    /**\r\n     * Simple records data\r\n     */\r\n    records?: T[];\r\n    /**\r\n     * Theme\r\n     */\r\n    theme?: ThemeDefine | string;\r\n    /**\r\n     * If set to true to allow pasting of ranges. default false\r\n     */\r\n    allowRangePaste?: boolean;\r\n    /**\r\n     * @deprecated Cannot be used with ListGrid.\r\n     * @override\r\n     */\r\n    rowCount?: undefined;\r\n    /**\r\n     * @deprecated Cannot be used with ListGrid.\r\n     * @override\r\n     */\r\n    colCount?: undefined;\r\n    /**\r\n     * @deprecated Cannot be used with ListGrid.\r\n     * @override\r\n     */\r\n    frozenRowCount?: undefined;\r\n}\r\n\r\n// export { HeadersDefine, ColumnDefine, HeaderDefine, GroupHeaderDefine }\r\n\r\n/**\r\n * ListGrid\r\n * @classdesc cheetahGrid.ListGrid\r\n * @memberof cheetahGrid\r\n */\r\nexport class ListGrid<T> extends DrawGrid implements ListGridAPI<T> {\r\n    protected [_]: ListGridProtected<T>\r\n\r\n    public disabled = false\r\n\r\n    public readOnly = false\r\n\r\n    static get EVENT_TYPE(): typeof LG_EVENT_TYPE {\r\n    \treturn LG_EVENT_TYPE\r\n    }\r\n\r\n    /**\r\n     * constructor\r\n     *\r\n     * @constructor\r\n     * @param options Constructor options\r\n     */\r\n    constructor(options: ListGridConstructorOptions<T> = {}) {\r\n    \tsuper(omit(options, [ 'colCount', 'rowCount', 'frozenRowCount' ]))\r\n    \tconst protectedSpace = this[_]\r\n    \tprotectedSpace.header = options.header || []\r\n    \tprotectedSpace.layout = options.layout || []\r\n    \tprotectedSpace.headerRowHeight = options.headerRowHeight || []\r\n    \tif (options.dataSource) {\r\n    \t\t_setDataSource(this, options.dataSource)\r\n    \t} else {\r\n    \t\t_setRecords(this, options.records)\r\n    \t}\r\n    \tprotectedSpace.allowRangePaste = options.allowRangePaste ?? false\r\n    \t_refreshHeader(this)\r\n    \tprotectedSpace.sortState = {\r\n    \t\tcol: -1,\r\n    \t\trow: -1,\r\n    \t\torder: undefined\r\n    \t}\r\n    \tprotectedSpace.gridCanvasHelper = new GridCanvasHelper(this)\r\n    \tprotectedSpace.theme = themes.of(options.theme)\r\n    \tprotectedSpace.messageHandler = new MessageHandler(this, (col: number, row: number): Message => _getCellMessage(this, col, row))\r\n    \tprotectedSpace.tooltipHandler = new TooltipHandler(this)\r\n    \tthis.invalidate()\r\n    \tprotectedSpace.handler.on(window, 'resize', () => {\r\n    \t\tthis.updateSize()\r\n    \t\tthis.updateScroll()\r\n    \t\tthis.invalidate()\r\n    \t})\r\n    }\r\n\r\n    /**\r\n     * Dispose the grid instance.\r\n     * @returns {void}\r\n     */\r\n    dispose(): void {\r\n    \tconst protectedSpace = this[_]\r\n    \tprotectedSpace.messageHandler.dispose()\r\n    \tprotectedSpace.tooltipHandler.dispose()\r\n    \tsuper.dispose()\r\n    }\r\n\r\n    /**\r\n     * Gets the define of the header.\r\n     */\r\n    get header(): HeadersDefine<T> {\r\n    \treturn this[_].header\r\n    }\r\n\r\n    /**\r\n     * Sets the define of the header with the given data.\r\n     * <pre>\r\n     * column options\r\n     * -----\r\n     * caption: header caption\r\n     * field: field name\r\n     * width: column width\r\n     * minWidth: column min width\r\n     * maxWidth: column max width\r\n     * icon: icon name\r\n     * message: message key name\r\n     * columnType: column type\r\n     * action: column action\r\n     * style: column style\r\n     * headerType: header type\r\n     * headerStyle: header style\r\n     * headerAction: header action\r\n     * headerField: header field name\r\n     * sort: define sort setting\r\n     * -----\r\n     *\r\n     * multiline header\r\n     * -----\r\n     * caption: header caption\r\n     * columns: columns define\r\n     * -----\r\n     * </pre>\r\n     */\r\n    set header(header: HeadersDefine<T>) {\r\n    \tthis[_].header = header\r\n    \t_refreshHeader(this)\r\n    }\r\n\r\n    /**\r\n     * Gets the define of the layout.\r\n     */\r\n    get layout(): LayoutDefine<T> {\r\n    \treturn this[_].layout\r\n    }\r\n\r\n    /**\r\n     * Sets the define of the layout with the given data.\r\n     */\r\n    set layout(layout: LayoutDefine<T>) {\r\n    \tthis[_].layout = layout\r\n    \t_refreshHeader(this)\r\n    }\r\n\r\n    /**\r\n     * Get the row count per record\r\n     */\r\n    get recordRowCount(): number {\r\n    \treturn this[_].layoutMap.bodyRowCount\r\n    }\r\n\r\n    /**\r\n     * Get the records.\r\n     */\r\n    get records(): T[] | null {\r\n    \treturn this[_].records || null\r\n    }\r\n\r\n    /**\r\n     * Set the records from given\r\n     */\r\n    set records(records: T[] | null) {\r\n    \tif (records == null) {\r\n    \t\treturn\r\n    \t}\r\n    \t_setRecords(this, records)\r\n    \t_refreshRowCount(this)\r\n    \tthis.invalidate()\r\n    }\r\n\r\n    /**\r\n     * Get the data source.\r\n     */\r\n    get dataSource(): DataSource<T> {\r\n    \treturn this[_].dataSource\r\n    }\r\n\r\n    /**\r\n     * Set the data source from given\r\n     */\r\n    set dataSource(dataSource: DataSource<T>) {\r\n    \t_setDataSource(this, dataSource)\r\n    \t_refreshRowCount(this)\r\n    \tthis.invalidate()\r\n    }\r\n\r\n    /**\r\n     * Get the theme.\r\n     */\r\n    get theme(): Theme | null {\r\n    \treturn this[_].theme\r\n    }\r\n\r\n    /**\r\n     * Set the theme from given\r\n     */\r\n    set theme(theme: Theme | null) {\r\n    \tthis[_].theme = themes.of(theme)\r\n    \tthis.invalidate()\r\n    }\r\n\r\n    /**\r\n     * If set to true to allow pasting of ranges.\r\n     */\r\n    get allowRangePaste(): boolean {\r\n    \treturn this[_].allowRangePaste\r\n    }\r\n\r\n    set allowRangePaste(allowRangePaste: boolean) {\r\n    \tthis[_].allowRangePaste = allowRangePaste\r\n    }\r\n\r\n    /**\r\n     * Get the font definition as a string.\r\n     * @override\r\n     */\r\n\r\n    get font(): string {\r\n    \t// return super.font || this[_].gridCanvasHelper.theme.font\r\n    \treturn ''\r\n    }\r\n\r\n    /**\r\n     * Set the font definition with the given string.\r\n     * @override\r\n     */\r\n    set font(font: string) {\r\n    \t// super.font = font\r\n    }\r\n\r\n    /**\r\n     * Get the background color of the underlay.\r\n     * @override\r\n     */\r\n    get underlayBackgroundColor(): string {\r\n    \treturn 'transparent'\r\n    \t// return (\r\n    \t//       super.underlayBackgroundColor ||\r\n    \t//       this[_].gridCanvasHelper.theme.underlayBackgroundColor\r\n    \t//   )\r\n    }\r\n\r\n    /**\r\n     * Set the background color of the underlay.\r\n     * @override\r\n     */\r\n    set underlayBackgroundColor(underlayBackgroundColor: string) {\r\n    \t// super.underlayBackgroundColor = underlayBackgroundColor\r\n    }\r\n\r\n    /**\r\n     * Get the sort state.\r\n     */\r\n    get sortState(): SortState {\r\n    \treturn this[_].sortState\r\n    }\r\n\r\n    /**\r\n     * Sets the sort state.\r\n     * If `null` to set, the sort state is initialized.\r\n     */\r\n    set sortState(sortState: SortState) {\r\n    \tconst oldState = this.sortState\r\n    \tlet oldField\r\n    \tif (oldState.col >= 0 && oldState.row >= 0) {\r\n    \t\toldField = this.getHeaderField(oldState.col, oldState.row)\r\n    \t}\r\n\r\n    \tconst newState = (this[_].sortState =\r\n            sortState != null\r\n            \t? sortState\r\n            \t: {\r\n            \t\tcol: -1,\r\n            \t\trow: -1,\r\n            \t\torder: undefined\r\n            \t})\r\n\r\n    \tlet newField\r\n    \tif (newState.col >= 0 && newState.row >= 0) {\r\n    \t\tnewField = this.getHeaderField(newState.col, newState.row)\r\n    \t}\r\n\r\n    \t// bind header value\r\n    \tif (oldField != null && oldField !== newField) {\r\n    \t\tthis.setHeaderValue(oldState.col, oldState.row, undefined)\r\n    \t}\r\n    \tif (newField != null) {\r\n    \t\tthis.setHeaderValue(newState.col, newState.row, newState.order)\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Get the header values.\r\n     */\r\n    get headerValues(): HeaderValues {\r\n    \treturn this[_].headerValues || (this[_].headerValues = new Map())\r\n    }\r\n\r\n    /**\r\n     * Sets the header values.\r\n     */\r\n    set headerValues(headerValues: HeaderValues) {\r\n    \tthis[_].headerValues = headerValues || new Map()\r\n    }\r\n\r\n    /**\r\n     * Get the field of the given column index.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index.\r\n     * @return {*} The field object.\r\n     */\r\n    getField(col: number, row: number): FieldDef<T> | undefined {\r\n    \treturn this[_].layoutMap.getBody(col, row ?? this[_].layoutMap.headerRowCount).field\r\n    }\r\n\r\n    /**\r\n     * Get the column define of the given column index.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index.\r\n     * @return {*} The column define object.\r\n     */\r\n    getColumnDefine(col: number, row: number): ColumnDefine<T> {\r\n    \treturn this[_].layoutMap.getBody(col, row ?? this[_].layoutMap.headerRowCount).define\r\n    }\r\n\r\n    getColumnType(col: number, row: number): ColumnTypeAPI {\r\n    \treturn this[_].layoutMap.getBody(col, row).columnType\r\n    }\r\n\r\n    /**\r\n     * Get the header field of the given header cell.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The header row index.\r\n     * @return {*} The field object.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    getHeaderField(col: number, row: number): any | undefined {\r\n    \tconst hd = this[_].layoutMap.getHeader(col, row)\r\n    \treturn hd.field\r\n    }\r\n\r\n    /**\r\n     * Get the header define of the given header cell.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The header row index.\r\n     * @return {*} The header define object.\r\n     */\r\n    getHeaderDefine(col: number, row: number): HeaderDefine<T> {\r\n    \tconst hd = this[_].layoutMap.getHeader(col, row)\r\n    \treturn hd.define\r\n    }\r\n\r\n    /**\r\n     * Get the record of the given row index.\r\n     * @param  {number} row The row index.\r\n     * @return {object} The record.\r\n     */\r\n    getRowRecord(row: number): MaybePromiseOrUndef<T> {\r\n    \tif (row < this[_].layoutMap.headerRowCount) {\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\treturn undefined\r\n    \t} else {\r\n    \t\treturn this[_].dataSource.get(_getRecordIndexByRow(this, row))\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Get the record index of the given row index.\r\n     * @param  {number} row The row index.\r\n     */\r\n    getRecordIndexByRow(row: number): number {\r\n    \treturn _getRecordIndexByRow(this, row)\r\n    }\r\n\r\n    /**\r\n     * Gets the row index starting at the given record index.\r\n     * @param  {number} index The record index.\r\n     */\r\n    getRecordStartRowByRecordIndex(index: number): number {\r\n    \treturn this[_].layoutMap.getRecordStartRowByRecordIndex(index)\r\n    }\r\n\r\n    /**\r\n     * Get the column index of the given field.\r\n     * @param  {*} field The field.\r\n     * @return {number} The column index.\r\n     * @deprecated use `getCellRangeByField` instead\r\n     */\r\n    getColumnIndexByField(field: FieldDef<T>): number | null {\r\n    \tconst range = this.getCellRangeByField(field, 0)\r\n    \treturn range?.start.col ?? null\r\n    }\r\n\r\n    /**\r\n     * Get the column index of the given field.\r\n     * @param  {*} field The field.\r\n     * @param  {number} index The record index\r\n     * @return {number} The column index.\r\n     */\r\n    getCellRangeByField(field: FieldDef<T>, index: number): CellRange | null {\r\n    \tconst { layoutMap } = this[_]\r\n    \tconst colObj = layoutMap.columnObjects.find((col) => col.field === field)\r\n    \tif (colObj) {\r\n    \t\tconst layoutRange = layoutMap.getBodyLayoutRangeById(colObj.id)\r\n    \t\tconst startRow = layoutMap.getRecordStartRowByRecordIndex(index)\r\n    \t\treturn {\r\n    \t\t\tstart: {\r\n    \t\t\t\tcol: layoutRange.start.col,\r\n    \t\t\t\trow: startRow + layoutRange.start.row\r\n    \t\t\t},\r\n    \t\t\tend: {\r\n    \t\t\t\tcol: layoutRange.end.col,\r\n    \t\t\t\trow: startRow + layoutRange.end.row\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn null\r\n    }\r\n\r\n    /**\r\n     * Focus the cell.\r\n     * @param  {*} field The field.\r\n     * @param  {number} index The record index\r\n     * @return {void}\r\n     */\r\n    focusGridCell(field: FieldDef<T>, index: number): void {\r\n    \tconst {\r\n    \t\tstart: { col: startCol, row: startRow },\r\n    \t\tend: { col: endCol, row: endRow }\r\n    \t} = this.selection.range\r\n\r\n    \tconst newFocus = this.getCellRangeByField(field, index)?.start\r\n    \tif (newFocus == null) {\r\n    \t\treturn\r\n    \t}\r\n    \tthis.focusCell(newFocus.col, newFocus.row)\r\n    \tthis.selection.select = newFocus\r\n    \tthis.invalidateGridRect(startCol, startRow, endCol, endRow)\r\n    \tthis.invalidateCell(newFocus.col, newFocus.row)\r\n    }\r\n\r\n    /**\r\n     * Scroll to where cell is visible.\r\n     * @param  {*} field The field.\r\n     * @param  {number} index The record index\r\n     * @return {void}\r\n     */\r\n    makeVisibleGridCell(field: FieldDef<T>, index: number): void {\r\n    \tconst cell = this.getCellRangeByField(field, index)?.start\r\n    \tthis.makeVisibleCell(cell?.col ?? 0, cell?.row ?? this[_].layoutMap.headerRowCount)\r\n    }\r\n\r\n    getGridCanvasHelper(): GridCanvasHelper<T> {\r\n    \treturn this[_].gridCanvasHelper\r\n    }\r\n\r\n    /**\r\n     * Get cell range information for a given cell.\r\n     * @param {number} col column index of the cell\r\n     * @param {number} row row index of the cell\r\n     * @returns {object} cell range info\r\n     */\r\n    getCellRange(col: number, row: number): CellRange {\r\n    \treturn _getCellRange(this, col, row)\r\n    }\r\n\r\n    /**\r\n     * Get header range information for a given cell.\r\n     * @param {number} col column index of the cell\r\n     * @param {number} row row index of the cell\r\n     * @returns {object} cell range info\r\n     * @deprecated use `getCellRange` instead\r\n     */\r\n    getHeaderCellRange(col: number, row: number): CellRange {\r\n    \treturn this.getCellRange(col, row)\r\n    }\r\n\r\n    protected getCopyCellValue(col: number, row: number, range?: CellRange): string {\r\n    \tconst cellRange = _getCellRange(this, col, row)\r\n    \tconst startCol = range ? Math.max(range.start.col, cellRange.start.col) : cellRange.start.col\r\n    \tconst startRow = range ? Math.max(range.start.row, cellRange.start.row) : cellRange.start.row\r\n    \tif (startCol !== col || startRow !== row) {\r\n    \t\treturn ''\r\n    \t}\r\n\r\n    \tconst value = _getCellValue(this, col, row)\r\n\r\n    \tif (row < this[_].layoutMap.headerRowCount) {\r\n    \t\treturn value\r\n    \t}\r\n\r\n    \tconst columnData = this[_].layoutMap.getBody(col, row)\r\n    \treturn columnData.columnType.getCopyCellValue(value, this, { col, row }) ?? value\r\n    }\r\n\r\n    protected onDrawCell(col: number, row: number, context: CellContext): MaybePromise<void> {\r\n    \tconst { layoutMap } = this[_]\r\n\r\n    \tlet draw\r\n    \tlet style\r\n    \tif (row < layoutMap.headerRowCount) {\r\n    \t\tconst hd = layoutMap.getHeader(col, row)\r\n    \t\tdraw = hd.headerType.onDrawCell;\r\n    \t\t({ style } = hd)\r\n    \t\t_updateRect(this, col, row, context)\r\n    \t} else {\r\n    \t\tconst column = layoutMap.getBody(col, row)\r\n    \t\tdraw = column.columnType.onDrawCell;\r\n    \t\t({ style } = column)\r\n    \t\t_updateRect(this, col, row, context)\r\n    \t}\r\n    \tconst cellValue = _getCellValue(this, col, row)\r\n    \tif (this.rowCount <= row) {\r\n    \t\t// Depending on the FilterDataSource, the rowCount may be reduced.\r\n    \t\treturn undefined\r\n    \t}\r\n    \treturn _onDrawValue(this, cellValue, context, { col, row }, style, draw)\r\n    }\r\n\r\n    doGetCellValue(\r\n    \t\tcol: number,\r\n    \t\trow: number,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tvalueCallback: (value: any) => void\r\n    ): boolean {\r\n    \tif (row < this[_].layoutMap.headerRowCount) {\r\n    \t\t// nop\r\n    \t\treturn false\r\n    \t} else {\r\n    \t\tconst value = _getCellValue(this, col, row)\r\n    \t\tif (isPromise(value)) {\r\n    \t\t\t//\r\n    \t\t\treturn false\r\n    \t\t}\r\n    \t\tvalueCallback(value)\r\n    \t}\r\n    \treturn true\r\n    }\r\n\r\n    doChangeValue(\r\n    \t\tcol: number,\r\n    \t\trow: number,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tchangeValueCallback: (before: any) => any\r\n    ): MaybePromise<boolean> {\r\n    \tif (row < this[_].layoutMap.headerRowCount) {\r\n    \t\t// nop\r\n    \t\treturn false\r\n    \t} else {\r\n    \t\tconst record = this.getRowRecord(row)\r\n    \t\tif (isPromise(record)) {\r\n    \t\t\t//\r\n    \t\t\treturn false\r\n    \t\t}\r\n    \t\tconst before = _getCellValue(this, col, row)\r\n    \t\tif (isPromise(before)) {\r\n    \t\t\t//\r\n    \t\t\treturn false\r\n    \t\t}\r\n    \t\tconst after = changeValueCallback(before)\r\n    \t\tif (after === undefined) {\r\n    \t\t\treturn false\r\n    \t\t}\r\n    \t\treturn then(_setCellValue(this, col, row, after), (ret) => {\r\n    \t\t\tif (ret) {\r\n    \t\t\t\tconst { field } = this[_].layoutMap.getBody(col, row)\r\n    \t\t\t\tthis.fireListeners(LG_EVENT_TYPE.CHANGED_VALUE, {\r\n    \t\t\t\t\tcol,\r\n    \t\t\t\t\trow,\r\n    \t\t\t\t\trecord: record as T,\r\n    \t\t\t\t\tfield: field as FieldDef<T>,\r\n    \t\t\t\t\tvalue: after,\r\n    \t\t\t\t\toldValue: before\r\n    \t\t\t\t})\r\n    \t\t\t}\r\n    \t\t\treturn ret\r\n    \t\t})\r\n    \t}\r\n    }\r\n\r\n    doSetPasteValue(text: string, test?: (data: SetPasteValueTestData<T>) => boolean): void {\r\n    \t// _onRangePaste.call<ListGrid<T>, [ string, (data: SetPasteValueTestData<T>) => boolean ], void>(this, text, test as (data: SetPasteValueTestData<T>) => boolean)\r\n    \t_onRangePaste.call(this, text, test as (data: SetPasteValueTestData<T>) => boolean)\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    getHeaderValue(col: number, row: number): any | undefined {\r\n    \tconst field = this.getHeaderField(col, row)\r\n    \treturn this.headerValues.get(field)\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    setHeaderValue(col: number, row: number, newValue: any): void {\r\n    \tconst field = this.getHeaderField(col, row)\r\n\r\n    \tconst oldValue = this.headerValues.get(field)\r\n    \tthis.headerValues.set(field, newValue)\r\n\r\n    \tthis.fireListeners(LG_EVENT_TYPE.CHANGED_HEADER_VALUE, {\r\n    \t\tcol,\r\n    \t\trow,\r\n    \t\tfield,\r\n    \t\tvalue: newValue,\r\n    \t\toldValue\r\n    \t})\r\n    }\r\n\r\n    getLayoutCellId(col: number, row: number): LayoutObjectId {\r\n    \treturn this[_].layoutMap.getCellId(col, row)\r\n    }\r\n\r\n    protected bindEventsInternal(): void {\r\n    \tconst grid: DrawGridAPI = this as DrawGridAPI\r\n    \tgrid.listen(LG_EVENT_TYPE.SELECTED_CELL, (e: SelectedCellEvent) => {\r\n    \t\tconst range = _getCellRange(this, e.col, e.row)\r\n    \t\tconst {\r\n    \t\t\tstart: { col: startCol, row: startRow },\r\n    \t\t\tend: { col: endCol, row: endRow }\r\n    \t\t} = range\r\n    \t\tif (startCol !== endCol || startRow !== endRow) {\r\n    \t\t\tthis.invalidateCellRange(range)\r\n    \t\t}\r\n    \t})\r\n    \tgrid.listen(LG_EVENT_TYPE.PASTE_CELL, (e: PasteCellEvent) => {\r\n    \t\tif (!this[_].allowRangePaste) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst { start, end } = this.selection.range\r\n    \t\tif (!e.multi && cellEquals(start, end)) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst { layoutMap } = this[_]\r\n\r\n    \t\tif (start.row < layoutMap.headerRowCount) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tevent.cancel(e.event)\r\n    \t\t_onRangePaste.call(this, e.normalizeValue)\r\n    \t})\r\n    \tgrid.listen(LG_EVENT_TYPE.DELETE_CELL, (e) => {\r\n    \t\tconst { start } = this.selection.range\r\n    \t\tconst { layoutMap } = this[_]\r\n\r\n    \t\tif (start.row < layoutMap.headerRowCount) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tevent.cancel(e.event)\r\n    \t\t_onRangeDelete.call(this)\r\n    \t})\r\n    }\r\n\r\n    protected getMoveLeftColByKeyDownInternal({ col, row }: CellAddress): number {\r\n    \tconst {\r\n    \t\tstart: { col: startCol }\r\n    \t} = _getCellRange(this, col, row)\r\n    \tcol = startCol\r\n    \treturn super.getMoveLeftColByKeyDownInternal({ col, row })\r\n    }\r\n\r\n    protected getMoveRightColByKeyDownInternal({ col, row }: CellAddress): number {\r\n    \tconst {\r\n    \t\tend: { col: endCol }\r\n    \t} = _getCellRange(this, col, row)\r\n    \tcol = endCol\r\n    \treturn super.getMoveRightColByKeyDownInternal({ col, row })\r\n    }\r\n\r\n    protected getMoveUpRowByKeyDownInternal({ col, row }: CellAddress): number {\r\n    \tconst {\r\n    \t\tstart: { row: startRow }\r\n    \t} = _getCellRange(this, col, row)\r\n    \trow = startRow\r\n    \treturn super.getMoveUpRowByKeyDownInternal({ col, row })\r\n    }\r\n\r\n    protected getMoveDownRowByKeyDownInternal({ col, row }: CellAddress): number {\r\n    \tconst {\r\n    \t\tend: { row: endRow }\r\n    \t} = _getCellRange(this, col, row)\r\n    \trow = endRow\r\n    \treturn super.getMoveDownRowByKeyDownInternal({ col, row })\r\n    }\r\n\r\n    protected getOffsetInvalidateCells(): number {\r\n    \treturn 1\r\n    }\r\n\r\n    protected getCopyRangeInternal(range: CellRange): CellRange {\r\n    \tconst { start } = this.getCellRange(range.start.col, range.start.row)\r\n    \tconst { end } = this.getCellRange(range.end.col, range.end.row)\r\n    \treturn { start, end }\r\n    }\r\n\r\n    fireListeners<TYPE extends keyof ListGridEventHandlersEventMap<T>>(type: TYPE, ...event: ListGridEventHandlersEventMap<T>[TYPE]): ListGridEventHandlersReturnMap[TYPE][] {\r\n    \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \treturn super.fireListeners(type as any, ...event)\r\n    }\r\n}\r\n","import * as action from './columns/action'\r\nimport * as style from './columns/style'\r\nimport * as type from './columns/type'\r\n\r\n/**\r\n * columns\r\n */\r\nexport const columns = { action, type, style }\r\n","import type {\r\n\tActionOption,\r\n\tBaseActionOption,\r\n\tButtonActionOption,\r\n\tColumnActionOption,\r\n\tEditorOption,\r\n\tInlineInputEditorOption,\r\n\tInlineMenuEditorOption,\r\n\tRecordBoolean,\r\n\tSmallDialogInputEditorOption\r\n} from '../ts-types'\r\nimport { Action } from './action/Action'\r\nimport { BaseAction } from './action/BaseAction'\r\nimport { ButtonAction } from './action/ButtonAction'\r\nimport { CheckEditor } from './action/CheckEditor'\r\nimport { Editor } from './action/Editor'\r\nimport { InlineInputEditor } from './action/InlineInputEditor'\r\nimport { InlineMenuEditor } from './action/InlineMenuEditor'\r\nimport { RadioEditor } from './action/RadioEditor'\r\nimport { SmallDialogInputEditor } from './action/SmallDialogInputEditor'\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nclass ImmutableCheckEditor extends CheckEditor<any> {\r\n\tget disabled(): RecordBoolean {\r\n\t\treturn this._disabled\r\n\t}\r\n\r\n\tget readOnly(): RecordBoolean {\r\n\t\treturn this._readOnly\r\n\t}\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nclass ImmutableRadioEditor extends RadioEditor<any> {\r\n\tget disabled(): RecordBoolean {\r\n\t\treturn this._disabled\r\n\t}\r\n\r\n\tget readOnly(): RecordBoolean {\r\n\t\treturn this._readOnly\r\n\t}\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nclass ImmutableInputEditor extends SmallDialogInputEditor<any> {\r\n\tget disabled(): RecordBoolean {\r\n\t\treturn this._disabled\r\n\t}\r\n\r\n\tget readOnly(): RecordBoolean {\r\n\t\treturn this._readOnly\r\n\t}\r\n}\r\n\r\nexport const ACTIONS = {\r\n\tCHECK: new ImmutableCheckEditor(),\r\n\tINPUT: new ImmutableInputEditor(),\r\n\tRADIO: new ImmutableRadioEditor()\r\n}\r\n/**\r\n * column actions\r\n * @namespace cheetahGrid.columns.action\r\n * @memberof cheetahGrid.columns\r\n */\r\nexport {\r\n\tBaseAction,\r\n\tEditor,\r\n\tAction,\r\n\tCheckEditor,\r\n\tRadioEditor,\r\n\tButtonAction,\r\n\tSmallDialogInputEditor,\r\n\tInlineInputEditor,\r\n\tInlineMenuEditor,\r\n\t// types\r\n\tActionOption,\r\n\tBaseActionOption,\r\n\tButtonActionOption,\r\n\tEditorOption,\r\n\tInlineInputEditorOption,\r\n\tInlineMenuEditorOption,\r\n\tSmallDialogInputEditorOption\r\n}\r\n\r\nexport function of<T>(columnAction: ColumnActionOption | BaseAction<T> | null | undefined): BaseAction<T> | undefined {\r\n\tif (!columnAction) {\r\n\t\treturn undefined\r\n\t} else if (typeof columnAction === 'string') {\r\n\t\tconst key = columnAction.toUpperCase() as keyof typeof ACTIONS\r\n\t\treturn ACTIONS[key] || of(null)\r\n\t} else {\r\n\t\treturn columnAction\r\n\t}\r\n}\r\n","import type { ActionListener, ActionOption, CellAddress, EventListenerId, LayoutObjectId, ListGridAPI } from '../../ts-types'\r\nimport { bindCellClickAction, bindCellKeyAction } from './actionBind'\r\nimport { BaseAction } from './BaseAction'\r\nimport type { GridInternal } from '../../ts-types-internal'\r\nimport { extend } from '../../internal/utils'\r\nimport { isDisabledRecord } from './action-utils'\r\n\r\nexport class Action<T> extends BaseAction<T> {\r\n    private _action: ActionListener\r\n\r\n    constructor(option: ActionOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._action = option.action || ((): void => {\r\n    \t})\r\n    }\r\n\r\n    get editable(): boolean {\r\n    \treturn false\r\n    }\r\n\r\n    get action(): ActionListener {\r\n    \treturn this._action\r\n    }\r\n\r\n    set action(action: ActionListener) {\r\n    \tthis._action = action\r\n    }\r\n\r\n    clone(): Action<T> {\r\n    \treturn new Action(this)\r\n    }\r\n\r\n    getState(_grid: GridInternal<T>): { mouseActiveCell?: CellAddress } {\r\n    \treturn {}\r\n    }\r\n\r\n    bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n    \tconst state = this.getState(grid)\r\n    \tconst action = (cell: CellAddress): void => {\r\n    \t\tif (isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst record = grid.getRowRecord(cell.row)\r\n    \t\tthis._action(record, extend(cell, { grid }))\r\n    \t}\r\n\r\n    \treturn [\r\n    \t\t...bindCellClickAction(grid, cellId, {\r\n    \t\t\taction,\r\n    \t\t\tmouseOver: (e) => {\r\n    \t\t\t\tif (isDisabledRecord(this.disabled, grid, e.row)) {\r\n    \t\t\t\t\treturn false\r\n    \t\t\t\t}\r\n    \t\t\t\tstate.mouseActiveCell = {\r\n    \t\t\t\t\tcol: e.col,\r\n    \t\t\t\t\trow: e.row\r\n    \t\t\t\t}\r\n    \t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n    \t\t\t\tgrid.invalidateCellRange(range)\r\n    \t\t\t\treturn true\r\n    \t\t\t},\r\n    \t\t\tmouseOut: (e) => {\r\n    \t\t\t\tdelete state.mouseActiveCell\r\n    \t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n    \t\t\t\tgrid.invalidateCellRange(range)\r\n    \t\t\t}\r\n    \t\t}),\r\n    \t\t...bindCellKeyAction(grid, cellId, {\r\n    \t\t\taction\r\n    \t\t})\r\n    \t]\r\n    }\r\n\r\n    onPasteCellRangeBox(): void {\r\n    \t// noop\r\n    }\r\n\r\n    onDeleteCellRangeBox(): void {\r\n    \t// noop\r\n    }\r\n}\r\n","import type { BaseActionOption, CellAddress, EventListenerId, LayoutObjectId, ListGridAPI, RecordBoolean } from '../../ts-types'\r\n\r\nexport abstract class BaseAction<T> {\r\n    protected _disabled: RecordBoolean\r\n\r\n    constructor(option: BaseActionOption = {}) {\r\n    \tthis._disabled = option.disabled || false\r\n    }\r\n\r\n    abstract get editable(): boolean;\r\n\r\n    get disabled(): RecordBoolean {\r\n    \treturn this._disabled\r\n    }\r\n\r\n    set disabled(disabled: RecordBoolean) {\r\n    \tthis._disabled = disabled\r\n    \tthis.onChangeDisabledInternal()\r\n    }\r\n\r\n    abstract clone(): BaseAction<T>;\r\n\r\n    abstract bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[];\r\n\r\n    protected onChangeDisabledInternal(): void {\r\n    \t// abstruct\r\n    }\r\n\r\n    abstract onPasteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress, value: string): void;\r\n\r\n    abstract onDeleteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress): void;\r\n}\r\n","import type { CellAddress, EditorOption, EventListenerId, LayoutObjectId, ListGridAPI } from '../../ts-types'\r\nimport { cellEquals, event } from '../../internal/utils'\r\nimport { isDisabledRecord, isReadOnlyRecord } from './action-utils'\r\nimport { DG_EVENT_TYPE } from '../../core/DG_EVENT_TYPE'\r\nimport { Editor } from './Editor'\r\n\r\nconst KEY_ENTER = 13\r\nconst KEY_F2 = 113\r\n\r\nexport abstract class BaseInputEditor<T> extends Editor<T> {\r\n\tconstructor(option: EditorOption = {}) {\r\n\t\tsuper(option)\r\n\t}\r\n\r\n    abstract clone(): BaseInputEditor<T>;\r\n\r\n    abstract onInputCellInternal(grid: ListGridAPI<T>, cell: CellAddress, inputValue: string): void;\r\n\r\n    abstract onOpenCellInternal(grid: ListGridAPI<T>, cell: CellAddress): void;\r\n\r\n    abstract onChangeSelectCellInternal(grid: ListGridAPI<T>, cell: CellAddress, selected: boolean): void;\r\n\r\n    abstract onSetInputAttrsInternal(grid: ListGridAPI<T>, cell: CellAddress, input: HTMLInputElement): void;\r\n\r\n    abstract onGridScrollInternal(grid: ListGridAPI<T>): void;\r\n\r\n    bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n    \tconst open = (cell: CellAddress): boolean => {\r\n    \t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\t\treturn false\r\n    \t\t}\r\n    \t\tthis.onOpenCellInternal(grid, cell)\r\n    \t\treturn true\r\n    \t}\r\n\r\n    \tconst input = (cell: CellAddress, value: string): void => {\r\n    \t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tthis.onInputCellInternal(grid, cell, value)\r\n    \t}\r\n\r\n    \tfunction isTarget(col: number, row: number): boolean {\r\n    \t\treturn grid.getLayoutCellId(col, row) === cellId\r\n    \t}\r\n\r\n    \treturn [\r\n    \t\tgrid.listen(DG_EVENT_TYPE.INPUT_CELL, (e) => {\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tinput(\r\n    \t\t\t\t\t{\r\n    \t\t\t\t\t\tcol: e.col,\r\n    \t\t\t\t\t\trow: e.row\r\n    \t\t\t\t\t},\r\n    \t\t\t\t\te.value\r\n    \t\t\t)\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.PASTE_CELL, (e) => {\r\n    \t\t\tif (e.multi) {\r\n    \t\t\t\t// ignore multi cell values\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst selectionRange = grid.selection.range\r\n    \t\t\tif (!cellEquals(selectionRange.start, selectionRange.end)) {\r\n    \t\t\t\t// ignore multi paste values\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tevent.cancel(e.event)\r\n    \t\t\tinput(\r\n    \t\t\t\t\t{\r\n    \t\t\t\t\t\tcol: e.col,\r\n    \t\t\t\t\t\trow: e.row\r\n    \t\t\t\t\t},\r\n    \t\t\t\t\te.normalizeValue\r\n    \t\t\t)\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.DBLCLICK_CELL, (cell) => {\r\n    \t\t\tif (!isTarget(cell.col, cell.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\topen({\r\n    \t\t\t\tcol: cell.col,\r\n    \t\t\t\trow: cell.row\r\n    \t\t\t})\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.DBLTAP_CELL, (e) => {\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\topen({\r\n    \t\t\t\tcol: e.col,\r\n    \t\t\t\trow: e.row\r\n    \t\t\t})\r\n\r\n    \t\t\tevent.cancel(e.event)\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.KEYDOWN, (e) => {\r\n    \t\t\tif (e.keyCode !== KEY_F2 && e.keyCode !== KEY_ENTER) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst sel = grid.selection.select\r\n    \t\t\tif (!isTarget(sel.col, sel.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (\r\n    \t\t\t\topen({\r\n    \t\t\t\t\tcol: sel.col,\r\n    \t\t\t\t\trow: sel.row\r\n    \t\t\t\t})\r\n    \t\t\t) {\r\n    \t\t\t\te.stopCellMoving()\r\n    \t\t\t}\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.SELECTED_CELL, (e) => {\r\n    \t\t\tthis.onChangeSelectCellInternal(grid, { col: e.col, row: e.row }, e.selected)\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.SCROLL, () => {\r\n    \t\t\tthis.onGridScrollInternal(grid)\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.EDITABLEINPUT_CELL, (cell) => {\r\n    \t\t\tif (!isTarget(cell.col, cell.row)) {\r\n    \t\t\t\treturn false\r\n    \t\t\t}\r\n    \t\t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\t\t\treturn false\r\n    \t\t\t}\r\n    \t\t\treturn true\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.MODIFY_STATUS_EDITABLEINPUT_CELL, (cell) => {\r\n    \t\t\tif (!isTarget(cell.col, cell.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst range = grid.getCellRange(cell.col, cell.row)\r\n    \t\t\tif (range.start.col !== range.end.col || range.start.row !== range.end.row) {\r\n    \t\t\t\tconst { input } = cell\r\n    \t\t\t\tconst baseRect = grid.getCellRect(cell.col, cell.row)\r\n    \t\t\t\tconst rangeRect = grid.getCellRangeRect(range)\r\n    \t\t\t\tinput.style.top = `${ (parseFloat(input.style.top) + (rangeRect.top - baseRect.top)).toFixed() }px`\r\n    \t\t\t\tinput.style.left = `${ (parseFloat(input.style.left) + (rangeRect.left - baseRect.left)).toFixed() }px`\r\n    \t\t\t\tinput.style.width = `${ rangeRect.width.toFixed() }px`\r\n    \t\t\t\tinput.style.height = `${ rangeRect.height.toFixed() }px`\r\n    \t\t\t}\r\n    \t\t\tthis.onSetInputAttrsInternal(\r\n    \t\t\t\t\tgrid,\r\n    \t\t\t\t\t{\r\n    \t\t\t\t\t\tcol: cell.col,\r\n    \t\t\t\t\t\trow: cell.row\r\n    \t\t\t\t\t},\r\n    \t\t\t\t\tcell.input\r\n    \t\t\t)\r\n    \t\t})\r\n    \t]\r\n    }\r\n\r\n    onPasteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress, value: string): void {\r\n    \tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\treturn\r\n    \t}\r\n    \tgrid.doChangeValue(cell.col, cell.row, () => value)\r\n    }\r\n\r\n    onDeleteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress): void {\r\n    \tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\treturn\r\n    \t}\r\n    \tgrid.doChangeValue(cell.col, cell.row, () => '')\r\n    }\r\n}\r\n","import type { ButtonColumnState, GridInternal } from '../../ts-types-internal'\r\nimport { Action } from './Action'\r\nimport { getButtonColumnStateId } from '../../internal/symbolManager'\r\nimport { obj } from '../../internal/utils'\r\n\r\nconst BUTTON_COLUMN_STATE_ID = getButtonColumnStateId()\r\n\r\nexport class ButtonAction<T> extends Action<T> {\r\n\tgetState(grid: GridInternal<T>): ButtonColumnState {\r\n\t\tlet state = grid[BUTTON_COLUMN_STATE_ID]\r\n\t\tif (!state) {\r\n\t\t\tstate = {}\r\n\t\t\tobj.setReadonly(grid, BUTTON_COLUMN_STATE_ID, state)\r\n\t\t}\r\n\t\treturn state\r\n\t}\r\n}\r\n","import type { CellAddress, EventListenerId, LayoutObjectId } from '../../ts-types'\r\nimport { bindCellClickAction, bindCellKeyAction } from './actionBind'\r\nimport { cellEquals, event, isPromise, obj } from '../../internal/utils'\r\nimport { isDisabledRecord, isReadOnlyRecord, toggleValue } from './action-utils'\r\nimport { DG_EVENT_TYPE } from '../../core/DG_EVENT_TYPE'\r\nimport { Editor } from './Editor'\r\nimport type { GridInternal } from '../../ts-types-internal'\r\nimport { animate } from '../../internal/animate'\r\nimport { getCheckColumnStateId } from '../../internal/symbolManager'\r\n\r\nconst CHECK_COLUMN_STATE_ID = getCheckColumnStateId()\r\n\r\nexport class CheckEditor<T> extends Editor<T> {\r\n\tclone(): CheckEditor<T> {\r\n\t\treturn new CheckEditor(this)\r\n\t}\r\n\r\n\tbindGridEvent(grid: GridInternal<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n\t\tlet _state = grid[CHECK_COLUMN_STATE_ID]\r\n\t\tif (!_state) {\r\n\t\t\t_state = { block: {}, elapsed: {} }\r\n\t\t\tobj.setReadonly(grid, CHECK_COLUMN_STATE_ID, _state)\r\n\t\t}\r\n\t\tconst state = _state\r\n\r\n\t\tconst action = (cell: CellAddress): void => {\r\n\t\t\tconst range = grid.getCellRange(cell.col, cell.row)\r\n\t\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\r\n\t\t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row) || state.block[cellKey]) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tconst ret = grid.doChangeValue(cell.col, cell.row, toggleValue)\r\n\t\t\tif (ret) {\r\n\t\t\t\tconst onChange = (): void => {\r\n\t\t\t\t\t// checkbox animation\r\n\t\t\t\t\tanimate(200, (point) => {\r\n\t\t\t\t\t\tif (point === 1) {\r\n\t\t\t\t\t\t\tdelete state.elapsed[cellKey]\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstate.elapsed[cellKey] = point\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (isPromise(ret)) {\r\n\t\t\t\t\tstate.block[cellKey] = true\r\n\t\t\t\t\tret.then(() => {\r\n\t\t\t\t\t\tdelete state.block[cellKey]\r\n\t\t\t\t\t\tonChange()\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tonChange()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction isTarget(col: number, row: number): boolean {\r\n\t\t\treturn grid.getLayoutCellId(col, row) === cellId\r\n\t\t}\r\n\r\n\t\treturn [\r\n\t\t\t...bindCellClickAction(grid, cellId, {\r\n\t\t\t\taction,\r\n\t\t\t\tmouseOver: (e) => {\r\n\t\t\t\t\tif (isDisabledRecord(this.disabled, grid, e.row)) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstate.mouseActiveCell = {\r\n\t\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\t\trow: e.row\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t},\r\n\t\t\t\tmouseOut: (e) => {\r\n\t\t\t\t\tdelete state.mouseActiveCell\r\n\t\t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\t...bindCellKeyAction(grid, cellId, {\r\n\t\t\t\taction: (_e) => {\r\n\t\t\t\t\tconst selrange = grid.selection.range\r\n\t\t\t\t\tconst { col } = grid.selection.select\r\n\t\t\t\t\tfor (let { row } = selrange.start; row <= selrange.end.row; row++) {\r\n\t\t\t\t\t\tif (!isTarget(col, row)) {\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\taction({\r\n\t\t\t\t\t\t\tcol,\r\n\t\t\t\t\t\t\trow\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\r\n\t\t\t// paste value\r\n\t\t\tgrid.listen(DG_EVENT_TYPE.PASTE_CELL, (e) => {\r\n\t\t\t\tif (e.multi) {\r\n\t\t\t\t\t// ignore multi cell values\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tconst selectionRange = grid.selection.range\r\n\t\t\t\tif (!cellEquals(selectionRange.start, selectionRange.end)) {\r\n\t\t\t\t\t// ignore multi paste values\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tconst pasteValue = e.normalizeValue.trim()\r\n\t\t\t\tgrid.doGetCellValue(e.col, e.row, (value) => {\r\n\t\t\t\t\tconst newValue = toggleValue(value)\r\n\t\t\t\t\tif (`${ newValue }`.trim() === pasteValue) {\r\n\t\t\t\t\t\tevent.cancel(e.event)\r\n\r\n\t\t\t\t\t\taction({\r\n\t\t\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\t\t\trow: e.row\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t]\r\n\t}\r\n\r\n\tonPasteCellRangeBox(grid: GridInternal<T>, cell: CellAddress, value: string): void {\r\n\t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst pasteValue = value.trim()\r\n\t\tgrid.doGetCellValue(cell.col, cell.row, (value) => {\r\n\t\t\tconst newValue = toggleValue(value)\r\n\t\t\tif (`${ newValue }`.trim() === pasteValue) {\r\n\t\t\t\tgrid.doChangeValue(cell.col, cell.row, toggleValue)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tonDeleteCellRangeBox(): void {\r\n\t\t// noop\r\n\t}\r\n}\r\n","import type { EditorOption, RecordBoolean } from '../../ts-types'\r\nimport { BaseAction } from './BaseAction'\r\n\r\nexport abstract class Editor<T> extends BaseAction<T> {\r\n    protected _readOnly: RecordBoolean\r\n\r\n    constructor(option: EditorOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._readOnly = option.readOnly || false\r\n    }\r\n\r\n    get editable(): boolean {\r\n    \treturn true\r\n    }\r\n\r\n    get readOnly(): RecordBoolean {\r\n    \treturn this._readOnly\r\n    }\r\n\r\n    set readOnly(readOnly: RecordBoolean) {\r\n    \tthis._readOnly = readOnly\r\n    \tthis.onChangeReadOnlyInternal()\r\n    }\r\n\r\n    onChangeReadOnlyInternal(): void {\r\n    \t// abstruct\r\n    }\r\n}\r\n","import type { CellAddress, InlineInputEditorOption, ListGridAPI } from '../../ts-types'\r\nimport type { GridInternal, InputEditorState } from '../../ts-types-internal'\r\nimport { BaseInputEditor } from './BaseInputEditor'\r\nimport { InlineInputElement } from './internal/InlineInputElement'\r\nimport { getInlineInputEditorStateId } from '../../internal/symbolManager'\r\nimport { obj } from '../../internal/utils'\r\n\r\nconst _ = getInlineInputEditorStateId()\r\n\r\nfunction getState<T>(grid: GridInternal<T>): InputEditorState {\r\n\tlet state = grid[_]\r\n\tif (!state) {\r\n\t\tstate = {}\r\n\t\tobj.setReadonly(grid, _, state)\r\n\t}\r\n\treturn state\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nlet globalElement: InlineInputElement<any> | null = null\r\nlet bindGridCount = 0\r\n\r\nfunction attachInput<T>(grid: GridInternal<T>, cell: CellAddress, editor: InlineInputEditor<T>, value: string): void {\r\n\tconst state = getState(grid)\r\n\tif (!globalElement) {\r\n\t\tglobalElement = new InlineInputElement()\r\n\t}\r\n\tif (!state.element) {\r\n\t\tstate.element = globalElement\r\n\t\tbindGridCount++\r\n\t\tgrid.addDisposable({\r\n\t\t\tdispose() {\r\n\t\t\t\tbindGridCount--\r\n\t\t\t\tif (!bindGridCount) {\r\n\t\t\t\t\tglobalElement?.dispose()\r\n\t\t\t\t\tglobalElement = null\r\n\t\t\t\t\tstate.element = null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tglobalElement.attach(grid, editor, cell.col, cell.row, value)\r\n}\r\n\r\nfunction detachInput(gridFocus?: boolean): void {\r\n\tif (globalElement) {\r\n\t\tglobalElement.detach(gridFocus)\r\n\t}\r\n}\r\n\r\nfunction doChangeValue<T>(_grid: ListGridAPI<T>): void {\r\n\tif (globalElement) {\r\n\t\tglobalElement.doChangeValue()\r\n\t}\r\n}\r\n\r\nexport class InlineInputEditor<T> extends BaseInputEditor<T> {\r\n    private _classList?: string | string[]\r\n\r\n    private _type?: string\r\n\r\n    constructor(option: InlineInputEditorOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._classList = option.classList\r\n    \tthis._type = option.type\r\n    }\r\n\r\n    get classList(): string[] | undefined {\r\n    \tif (!this._classList) {\r\n    \t\treturn undefined\r\n    \t}\r\n    \treturn Array.isArray(this._classList) ? this._classList : [ this._classList ]\r\n    }\r\n\r\n    set classList(classList: string[] | undefined) {\r\n    \tthis._classList = classList\r\n    }\r\n\r\n    get type(): string | undefined {\r\n    \treturn this._type\r\n    }\r\n\r\n    set type(type: string | undefined) {\r\n    \tthis._type = type\r\n    }\r\n\r\n    clone(): InlineInputEditor<T> {\r\n    \treturn new InlineInputEditor(this)\r\n    }\r\n\r\n    onInputCellInternal(grid: ListGridAPI<T>, cell: CellAddress, inputValue: string): void {\r\n    \tattachInput(grid, cell, this, inputValue)\r\n    }\r\n\r\n    onOpenCellInternal(grid: ListGridAPI<T>, cell: CellAddress): void {\r\n    \tgrid.doGetCellValue(cell.col, cell.row, (value) => {\r\n    \t\tattachInput(grid, cell, this, value)\r\n    \t})\r\n    }\r\n\r\n    onChangeSelectCellInternal(grid: ListGridAPI<T>, _cell: CellAddress, _selected: boolean): void {\r\n    \tdoChangeValue(grid)\r\n    \tdetachInput()\r\n    }\r\n\r\n    onGridScrollInternal(grid: ListGridAPI<T>): void {\r\n    \tdoChangeValue(grid)\r\n    \tdetachInput(true)\r\n    }\r\n\r\n    onChangeDisabledInternal(): void {\r\n    \t// cancel input\r\n    \tdetachInput(true)\r\n    }\r\n\r\n    onChangeReadOnlyInternal(): void {\r\n    \t// cancel input\r\n    \tdetachInput(true)\r\n    }\r\n\r\n    onSetInputAttrsInternal(grid: ListGridAPI<T>, _cell: CellAddress, input: HTMLInputElement): void {\r\n    \tInlineInputElement.setInputAttrs(this, grid, input)\r\n    }\r\n}\r\n","import type { CellAddress, ColumnMenuItemOption, ColumnTypeAPI, EventListenerId, InlineMenuEditorOption, LayoutObjectId, ListGridAPI, SimpleColumnMenuItemOption } from '../../ts-types'\r\nimport type { GridInternal, InputEditorState } from '../../ts-types-internal'\r\nimport { array, cellEquals, event, isPromise, obj, then } from '../../internal/utils'\r\nimport { isDisabledRecord, isReadOnlyRecord } from './action-utils'\r\nimport { DG_EVENT_TYPE } from '../../core/DG_EVENT_TYPE'\r\nimport { Editor } from './Editor'\r\nimport { InlineMenuElement } from './internal/InlineMenuElement'\r\nimport { MenuColumn } from '../type'\r\nimport { getInlineMenuEditorStateId } from '../../internal/symbolManager'\r\nimport { normalizeToFn } from '../../internal/menu-items'\r\n\r\nconst _ = getInlineMenuEditorStateId()\r\n\r\nfunction getState<T>(grid: GridInternal<T>): InputEditorState {\r\n\tlet state = grid[_]\r\n\tif (!state) {\r\n\t\tstate = {}\r\n\t\tobj.setReadonly(grid, _, state)\r\n\t}\r\n\treturn state\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nlet globalElement: InlineMenuElement<any> | null = null\r\nlet bindGridCount = 0\r\n\r\nfunction attachMenu<T>(grid: ListGridAPI<T>, cell: CellAddress, editor: InlineMenuEditor<T>, value: string, record: T | undefined): void {\r\n\tconst state = getState(grid)\r\n\tif (!globalElement) {\r\n\t\tglobalElement = new InlineMenuElement()\r\n\t}\r\n\tif (!state.element) {\r\n\t\tstate.element = globalElement\r\n\t\tbindGridCount++\r\n\t\tgrid.addDisposable({\r\n\t\t\tdispose() {\r\n\t\t\t\tbindGridCount--\r\n\t\t\t\tif (!bindGridCount) {\r\n\t\t\t\t\tglobalElement?.dispose()\r\n\t\t\t\t\tglobalElement = null\r\n\t\t\t\t\tstate.element = null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tglobalElement.attach(grid, editor, cell.col, cell.row, value, record)\r\n}\r\n\r\nfunction detachMenu(gridFocus?: boolean): void {\r\n\tif (globalElement) {\r\n\t\tglobalElement.detach(gridFocus)\r\n\t}\r\n}\r\n\r\nconst KEY_ENTER = 13\r\nconst KEY_F2 = 113\r\n\r\nexport class InlineMenuEditor<T> extends Editor<T> {\r\n    private _classList?: string | string[]\r\n\r\n    private _options: (record: T | undefined) => ColumnMenuItemOption[]\r\n\r\n    constructor(option: InlineMenuEditorOption<T> = {}) {\r\n    \tsuper(option)\r\n    \tthis._classList = option.classList\r\n    \tthis._options = normalizeToFn(option.options)\r\n    }\r\n\r\n    dispose(): void {\r\n    \t// noop\r\n    }\r\n\r\n    get classList(): string[] | undefined {\r\n    \tif (!this._classList) {\r\n    \t\treturn undefined\r\n    \t}\r\n    \treturn Array.isArray(this._classList) ? this._classList : [ this._classList ]\r\n    }\r\n\r\n    set classList(classList: string[] | undefined) {\r\n    \tthis._classList = classList\r\n    }\r\n\r\n    get options(): (record: T | undefined) => ColumnMenuItemOption[] {\r\n    \treturn this._options\r\n    }\r\n\r\n    set options(options: (record: T | undefined) => ColumnMenuItemOption[]) {\r\n    \tthis._options = normalizeToFn(options)\r\n    }\r\n\r\n    clone(): InlineMenuEditor<T> {\r\n    \treturn new InlineMenuEditor(this)\r\n    }\r\n\r\n    onChangeDisabledInternal(): void {\r\n    \t// cancel input\r\n    \tdetachMenu(true)\r\n    }\r\n\r\n    onChangeReadOnlyInternal(): void {\r\n    \t// cancel input\r\n    \tdetachMenu(true)\r\n    }\r\n\r\n    bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n    \tconst open = (cell: CellAddress): boolean => {\r\n    \t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\t\treturn false\r\n    \t\t}\r\n    \t\tgrid.doGetCellValue(cell.col, cell.row, (value) => {\r\n    \t\t\tconst record = grid.getRowRecord(cell.row)\r\n    \t\t\tif (isPromise(record)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tattachMenu(grid, cell, this, value, record)\r\n    \t\t})\r\n    \t\treturn true\r\n    \t}\r\n\r\n    \tfunction isTarget(col: number, row: number): boolean {\r\n    \t\treturn grid.getLayoutCellId(col, row) === cellId\r\n    \t}\r\n\r\n    \treturn [\r\n    \t\tgrid.listen(DG_EVENT_TYPE.CLICK_CELL, (cell) => {\r\n    \t\t\tif (!isTarget(cell.col, cell.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\topen({\r\n    \t\t\t\tcol: cell.col,\r\n    \t\t\t\trow: cell.row\r\n    \t\t\t})\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.KEYDOWN, (e) => {\r\n    \t\t\tif (e.keyCode !== KEY_F2 && e.keyCode !== KEY_ENTER) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst sel = grid.selection.select\r\n    \t\t\tif (!isTarget(sel.col, sel.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n\r\n    \t\t\tif (\r\n    \t\t\t\topen({\r\n    \t\t\t\t\tcol: sel.col,\r\n    \t\t\t\t\trow: sel.row\r\n    \t\t\t\t})\r\n    \t\t\t) {\r\n    \t\t\t\te.stopCellMoving()\r\n    \t\t\t}\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.SELECTED_CELL, (_e) => {\r\n    \t\t\tdetachMenu()\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.SCROLL, () => {\r\n    \t\t\tdetachMenu(true)\r\n    \t\t}),\r\n\r\n    \t\t// mouse move\r\n    \t\tgrid.listen(DG_EVENT_TYPE.MOUSEOVER_CELL, (e) => {\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (isReadOnlyRecord(this.readOnly, grid, e.row) || isDisabledRecord(this.disabled, grid, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tgrid.getElement().style.cursor = 'pointer'\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.MOUSEMOVE_CELL, (e) => {\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (isReadOnlyRecord(this.readOnly, grid, e.row) || isDisabledRecord(this.disabled, grid, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (!grid.getElement().style.cursor) {\r\n    \t\t\t\tgrid.getElement().style.cursor = 'pointer'\r\n    \t\t\t}\r\n    \t\t}),\r\n    \t\tgrid.listen(DG_EVENT_TYPE.MOUSEOUT_CELL, (e) => {\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tgrid.getElement().style.cursor = ''\r\n    \t\t}),\r\n\r\n    \t\t// paste value\r\n    \t\tgrid.listen(DG_EVENT_TYPE.PASTE_CELL, (e) => {\r\n    \t\t\tif (e.multi) {\r\n    \t\t\t\t// ignore multi cell values\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst selectionRange = grid.selection.range\r\n    \t\t\tif (!cellEquals(selectionRange.start, selectionRange.end)) {\r\n    \t\t\t\t// ignore multi paste values\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (isReadOnlyRecord(this.readOnly, grid, e.row) || isDisabledRecord(this.disabled, grid, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst record = grid.getRowRecord(e.row)\r\n    \t\t\tif (isPromise(record)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst pasteOpt = this._pasteDataToOptionValue(e.normalizeValue, grid, e, record)\r\n    \t\t\tif (pasteOpt) {\r\n    \t\t\t\tevent.cancel(e.event)\r\n    \t\t\t\tthen(\r\n    \t\t\t\t\t\tgrid.doChangeValue(e.col, e.row, () => pasteOpt.value),\r\n    \t\t\t\t\t\t() => {\r\n    \t\t\t\t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n    \t\t\t\t\t\t\tgrid.invalidateCellRange(range)\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t)\r\n    \t\t\t}\r\n    \t\t})\r\n    \t]\r\n    }\r\n\r\n    onPasteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress, value: string): void {\r\n    \tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst record = grid.getRowRecord(cell.row)\r\n    \tif (isPromise(record)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst pasteOpt = this._pasteDataToOptionValue(value, grid, cell, record)\r\n    \tif (pasteOpt) {\r\n    \t\tgrid.doChangeValue(cell.col, cell.row, () => pasteOpt.value)\r\n    \t}\r\n    }\r\n\r\n    onDeleteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress): void {\r\n    \tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst record = grid.getRowRecord(cell.row)\r\n    \tif (isPromise(record)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst pasteOpt = this._pasteDataToOptionValue('', grid, cell, record)\r\n    \tif (pasteOpt) {\r\n    \t\tgrid.doChangeValue(cell.col, cell.row, () => pasteOpt.value)\r\n    \t}\r\n    }\r\n\r\n    private _pasteDataToOptionValue(value: string, grid: ListGridAPI<T>, cell: CellAddress, record: T | undefined): SimpleColumnMenuItemOption | undefined {\r\n    \tconst options = this._options(record)\r\n    \tconst pasteOpt = _textToOptionValue(value, options)\r\n    \tif (pasteOpt) {\r\n    \t\treturn pasteOpt\r\n    \t}\r\n    \tconst columnType = grid.getColumnType(cell.col, cell.row)\r\n    \tif (hasOptions(columnType)) {\r\n    \t\t// Find with caption.\r\n    \t\tconst pasteValue = normalizePasteValueStr(value)\r\n    \t\tconst captionOpt = array.find(columnType.options, (opt) => normalizePasteValueStr(opt.label) === pasteValue)\r\n    \t\tif (captionOpt) {\r\n    \t\t\treturn _textToOptionValue(captionOpt.value, options)\r\n    \t\t}\r\n    \t}\r\n    \treturn undefined\r\n    }\r\n}\r\n\r\nfunction _textToOptionValue(value: string, options: SimpleColumnMenuItemOption[]): SimpleColumnMenuItemOption | undefined {\r\n\tconst pasteValue = normalizePasteValueStr(value)\r\n\tconst pasteOpt = array.find(options, (opt) => normalizePasteValueStr(opt.value) === pasteValue)\r\n\tif (pasteOpt) {\r\n\t\treturn pasteOpt\r\n\t}\r\n\treturn undefined\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction normalizePasteValueStr(value: any): string {\r\n\tif (value == null) {\r\n\t\treturn ''\r\n\t}\r\n\treturn `${ value }`.trim()\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction hasOptions(columnType: ColumnTypeAPI): columnType is MenuColumn<any> {\r\n\tif (columnType instanceof MenuColumn) {\r\n\t\treturn true\r\n\t}\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tif (Array.isArray((columnType as any).options)) {\r\n\t\treturn true\r\n\t}\r\n\r\n\treturn false\r\n}\r\n","import type { ActionListener, CellAddress, EventListenerId, GetRadioEditorGroup, LayoutObjectId, RadioEditorOption } from '../../ts-types'\r\nimport { bindCellClickAction, bindCellKeyAction } from './actionBind'\r\nimport { cellEquals, event, extend, isPromise, obj, then } from '../../internal/utils'\r\nimport { isDisabledRecord, isReadOnlyRecord, toggleValue } from './action-utils'\r\nimport { DG_EVENT_TYPE } from '../../core/DG_EVENT_TYPE'\r\nimport { Editor } from './Editor'\r\nimport type { GridInternal } from '../../ts-types-internal'\r\nimport { animate } from '../../internal/animate'\r\nimport { getRadioColumnStateId } from '../../internal/symbolManager'\r\nimport { toBoolean } from '../utils'\r\n\r\nconst RADIO_COLUMN_STATE_ID = getRadioColumnStateId()\r\n\r\nexport class RadioEditor<T> extends Editor<T> {\r\n    protected _group: GetRadioEditorGroup<T> | undefined\r\n\r\n    private _checkAction: ActionListener | undefined\r\n\r\n    constructor(option: RadioEditorOption<T> = {}) {\r\n    \tsuper(option)\r\n    \tthis._group = option.group\r\n    \tthis._checkAction = option.checkAction\r\n    }\r\n\r\n    clone(): RadioEditor<T> {\r\n    \treturn new RadioEditor(this)\r\n    }\r\n\r\n    /** @deprecated Use checkAction instead. */\r\n    get group(): GetRadioEditorGroup<T> | undefined {\r\n    \treturn this._group\r\n    }\r\n\r\n    /** @deprecated Use checkAction instead. */\r\n    set group(group: GetRadioEditorGroup<T> | undefined) {\r\n    \tthis._group = group\r\n    }\r\n\r\n    get checkAction(): ActionListener | undefined {\r\n    \treturn this._checkAction\r\n    }\r\n\r\n    set checkAction(checkAction: ActionListener | undefined) {\r\n    \tthis._checkAction = checkAction\r\n    }\r\n\r\n    bindGridEvent(grid: GridInternal<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n    \tlet _state = grid[RADIO_COLUMN_STATE_ID]\r\n    \tif (!_state) {\r\n    \t\t_state = { block: {}, elapsed: {} }\r\n    \t\tobj.setReadonly(grid, RADIO_COLUMN_STATE_ID, _state)\r\n    \t}\r\n    \tconst state = _state\r\n\r\n    \tconst action = (cell: CellAddress): void => {\r\n    \t\tthis._action(grid, cell)\r\n    \t}\r\n\r\n    \tfunction isTarget(col: number, row: number): boolean {\r\n    \t\treturn grid.getLayoutCellId(col, row) === cellId\r\n    \t}\r\n\r\n    \treturn [\r\n    \t\t...bindCellClickAction(grid, cellId, {\r\n    \t\t\taction,\r\n    \t\t\tmouseOver: (e) => {\r\n    \t\t\t\tif (isDisabledRecord(this.disabled, grid, e.row)) {\r\n    \t\t\t\t\treturn false\r\n    \t\t\t\t}\r\n    \t\t\t\tstate.mouseActiveCell = {\r\n    \t\t\t\t\tcol: e.col,\r\n    \t\t\t\t\trow: e.row\r\n    \t\t\t\t}\r\n    \t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n    \t\t\t\tgrid.invalidateCellRange(range)\r\n    \t\t\t\treturn true\r\n    \t\t\t},\r\n    \t\t\tmouseOut: (e) => {\r\n    \t\t\t\tdelete state.mouseActiveCell\r\n    \t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n    \t\t\t\tgrid.invalidateCellRange(range)\r\n    \t\t\t}\r\n    \t\t}),\r\n    \t\t...bindCellKeyAction(grid, cellId, {\r\n    \t\t\taction\r\n    \t\t}),\r\n\r\n    \t\t// paste value\r\n    \t\tgrid.listen(DG_EVENT_TYPE.PASTE_CELL, (e) => {\r\n    \t\t\tif (e.multi) {\r\n    \t\t\t\t// ignore multi cell values\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst selectionRange = grid.selection.range\r\n    \t\t\tif (!cellEquals(selectionRange.start, selectionRange.end)) {\r\n    \t\t\t\t// ignore multi paste values\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tif (!isTarget(e.col, e.row)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n\r\n    \t\t\tconst pasteValue = e.normalizeValue.trim()\r\n    \t\t\tif (!toBoolean(pasteValue)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tevent.cancel(e.event)\r\n\r\n    \t\t\taction({\r\n    \t\t\t\tcol: e.col,\r\n    \t\t\t\trow: e.row\r\n    \t\t\t})\r\n    \t\t})\r\n    \t]\r\n    }\r\n\r\n    onPasteCellRangeBox(grid: GridInternal<T>, cell: CellAddress, value: string): void {\r\n    \tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst pasteValue = value.trim()\r\n    \tif (!toBoolean(pasteValue)) {\r\n    \t\treturn\r\n    \t}\r\n    \tthis._action(grid, {\r\n    \t\tcol: cell.col,\r\n    \t\trow: cell.row\r\n    \t})\r\n    }\r\n\r\n    onDeleteCellRangeBox(): void {\r\n    \t// noop\r\n    }\r\n\r\n    private _action(grid: GridInternal<T>, cell: CellAddress): void {\r\n    \tconst state = grid[RADIO_COLUMN_STATE_ID]!\r\n    \tconst range = grid.getCellRange(cell.col, cell.row)\r\n    \tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\r\n    \tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row) || state.block[cellKey]) {\r\n    \t\treturn\r\n    \t}\r\n\r\n    \tgrid.doGetCellValue(cell.col, cell.row, (value) => {\r\n    \t\tif (toBoolean(value)) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tif (this._checkAction) {\r\n    \t\t\t// User behavior\r\n    \t\t\tconst record = grid.getRowRecord(cell.row)\r\n    \t\t\tthis._checkAction(record, extend(cell, { grid }))\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tif (this._group) {\r\n    \t\t\t// Backward compatibility\r\n    \t\t\tconst state = grid[RADIO_COLUMN_STATE_ID]!\r\n\r\n    \t\t\tconst targets = this._group({ grid, col: cell.col, row: cell.row })\r\n    \t\t\ttargets.forEach(({ col, row }) => {\r\n    \t\t\t\tconst range = grid.getCellRange(col, row)\r\n    \t\t\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\r\n    \t\t\t\tif (isReadOnlyRecord(this.readOnly, grid, cell.row) || isDisabledRecord(this.disabled, grid, cell.row) || state.block[cellKey]) {\r\n    \t\t\t\t\treturn\r\n    \t\t\t\t}\r\n\r\n    \t\t\t\tactionCell(grid, col, row, col === cell.col && row === cell.row)\r\n    \t\t\t})\r\n    \t\t\treturn\r\n    \t\t}\r\n\r\n    \t\t// default behavior\r\n    \t\tconst field = grid.getField(cell.col, cell.row)!\r\n    \t\tconst recordStartRow = grid.getRecordStartRowByRecordIndex(grid.getRecordIndexByRow(cell.row))\r\n\r\n    \t\t/** Original DataSource */\r\n    \t\tconst { dataSource } = grid.dataSource\r\n\r\n    \t\tconst girdRecords = getAllRecordsFromGrid(grid)\r\n\r\n    \t\tfor (let index = 0; index < dataSource.length; index++) {\r\n    \t\t\tconst record = dataSource.get(index)\r\n    \t\t\tconst showData = girdRecords.find((d) => d.record === record)\r\n    \t\t\tif (showData) {\r\n    \t\t\t\tactionCell(grid, cell.col, showData.row, showData.row === recordStartRow)\r\n    \t\t\t} else {\r\n    \t\t\t\t// Hidden record\r\n    \t\t\t\tthen(dataSource.getField(index, field), (value) => {\r\n    \t\t\t\t\tif (!toBoolean(value)) {\r\n    \t\t\t\t\t\treturn\r\n    \t\t\t\t\t}\r\n    \t\t\t\t\tdataSource.setField(index, field, toggleValue(value))\r\n    \t\t\t\t})\r\n    \t\t\t}\r\n    \t\t}\r\n    \t})\r\n    }\r\n}\r\n\r\nfunction getAllRecordsFromGrid<T>(grid: GridInternal<T>) {\r\n\tconst result = []\r\n\tconst { rowCount, recordRowCount } = grid\r\n\tfor (let targetRow = grid.frozenRowCount; targetRow < rowCount; targetRow += recordRowCount) {\r\n\t\tconst record = grid.getRowRecord(targetRow)\r\n\t\tresult.push({ row: targetRow, record })\r\n\t}\r\n\treturn result\r\n}\r\n\r\nfunction actionCell<T>(grid: GridInternal<T>, col: number, row: number, flag: boolean): void {\r\n\tgrid.doGetCellValue(col, row, (value) => {\r\n\t\tif (toBoolean(value) === flag) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst state = grid[RADIO_COLUMN_STATE_ID]!\r\n\t\tconst range = grid.getCellRange(col, row)\r\n\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\t\tconst ret = grid.doChangeValue(col, row, toggleValue)\r\n\t\tif (ret) {\r\n\t\t\tconst onChange = (): void => {\r\n\t\t\t\t// checkbox animation\r\n\t\t\t\tanimate(200, (point) => {\r\n\t\t\t\t\tif (point === 1) {\r\n\t\t\t\t\t\tdelete state.elapsed[cellKey]\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstate.elapsed[cellKey] = point\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (isPromise(ret)) {\r\n\t\t\t\tstate.block[cellKey] = true\r\n\t\t\t\tret.then(() => {\r\n\t\t\t\t\tdelete state.block[cellKey]\r\n\t\t\t\t\tonChange()\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tonChange()\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n}\r\n","import type { CellAddress, ListGridAPI, MaybePromise, SmallDialogInputEditorOption } from '../../ts-types'\r\nimport type { GridInternal, InputEditorState } from '../../ts-types-internal'\r\nimport { BaseInputEditor } from './BaseInputEditor'\r\nimport { SmallDialogInputElement } from './internal/SmallDialogInputElement'\r\nimport { getSmallDialogInputEditorStateId } from '../../internal/symbolManager'\r\nimport { obj } from '../../internal/utils'\r\n\r\nconst _ = getSmallDialogInputEditorStateId()\r\n\r\nfunction getState<T>(grid: GridInternal<T>): InputEditorState {\r\n\tlet state = grid[_]\r\n\tif (!state) {\r\n\t\tstate = {}\r\n\t\tobj.setReadonly(grid, _, state)\r\n\t}\r\n\treturn state\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nlet globalElement: SmallDialogInputElement<any> | null = null\r\nlet bindGridCount = 0\r\n\r\nfunction attachInput<T>(grid: ListGridAPI<T>, cell: CellAddress, editor: SmallDialogInputEditor<T>, value: string): void {\r\n\tconst state = getState(grid)\r\n\tif (!globalElement) {\r\n\t\tglobalElement = new SmallDialogInputElement()\r\n\t}\r\n\tif (!state.element) {\r\n\t\tstate.element = globalElement\r\n\t\tbindGridCount++\r\n\t\tgrid.addDisposable({\r\n\t\t\tdispose() {\r\n\t\t\t\tbindGridCount--\r\n\t\t\t\tif (!bindGridCount) {\r\n\t\t\t\t\tglobalElement?.dispose()\r\n\t\t\t\t\tglobalElement = null\r\n\t\t\t\t\tstate.element = null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tglobalElement.attach(grid, editor, cell.col, cell.row, value)\r\n}\r\n\r\nfunction detachInput(gridFocus?: boolean): void {\r\n\tif (globalElement) {\r\n\t\tglobalElement.detach(gridFocus)\r\n\t}\r\n}\r\n\r\ntype GetValueResult<T, R> = (value: string, info: { grid: ListGridAPI<T>; col: number; row: number }) => R;\r\n\r\nexport class SmallDialogInputEditor<T> extends BaseInputEditor<T> {\r\n    private _helperText?: string | GetValueResult<T, string>\r\n\r\n    private _inputValidator?: GetValueResult<T, MaybePromise<string>>\r\n\r\n    private _validator?: GetValueResult<T, MaybePromise<string>>\r\n\r\n    private _classList?: string | string[]\r\n\r\n    private _type?: string\r\n\r\n    constructor(option: SmallDialogInputEditorOption<T> = {}) {\r\n    \tsuper(option)\r\n    \tthis._helperText = option.helperText\r\n    \tthis._inputValidator = option.inputValidator\r\n    \tthis._validator = option.validator\r\n    \tthis._classList = option.classList\r\n    \tthis._type = option.type\r\n    }\r\n\r\n    dispose(): void {\r\n    \t//noop\r\n    }\r\n\r\n    get classList(): string[] | undefined {\r\n    \tif (!this._classList) {\r\n    \t\treturn undefined\r\n    \t}\r\n    \treturn Array.isArray(this._classList) ? this._classList : [ this._classList ]\r\n    }\r\n\r\n    set classList(classList: string[] | undefined) {\r\n    \tthis._classList = classList\r\n    }\r\n\r\n    get type(): string | undefined {\r\n    \treturn this._type\r\n    }\r\n\r\n    set type(type: string | undefined) {\r\n    \tthis._type = type\r\n    }\r\n\r\n    get helperText(): string | GetValueResult<T, string> | undefined {\r\n    \treturn this._helperText\r\n    }\r\n\r\n    get inputValidator(): GetValueResult<T, MaybePromise<string>> | undefined {\r\n    \treturn this._inputValidator\r\n    }\r\n\r\n    get validator(): GetValueResult<T, MaybePromise<string>> | undefined {\r\n    \treturn this._validator\r\n    }\r\n\r\n    clone(): SmallDialogInputEditor<T> {\r\n    \treturn new SmallDialogInputEditor(this)\r\n    }\r\n\r\n    onInputCellInternal(grid: ListGridAPI<T>, cell: CellAddress, inputValue: string): void {\r\n    \tattachInput(grid, cell, this, inputValue)\r\n    }\r\n\r\n    onOpenCellInternal(grid: ListGridAPI<T>, cell: CellAddress): void {\r\n    \tgrid.doGetCellValue(cell.col, cell.row, (value) => {\r\n    \t\tattachInput(grid, cell, this, value)\r\n    \t})\r\n    }\r\n\r\n    onChangeSelectCellInternal(_grid: ListGridAPI<T>, _cell: CellAddress, _selected: boolean): void {\r\n    \t// cancel input\r\n    \tdetachInput()\r\n    }\r\n\r\n    onGridScrollInternal(_grid: ListGridAPI<T>): void {\r\n    \t// cancel input\r\n    \tdetachInput(true)\r\n    }\r\n\r\n    onChangeDisabledInternal(): void {\r\n    \t// cancel input\r\n    \tdetachInput(true)\r\n    }\r\n\r\n    onChangeReadOnlyInternal(): void {\r\n    \t// cancel input\r\n    \tdetachInput(true)\r\n    }\r\n\r\n    onSetInputAttrsInternal(grid: ListGridAPI<T>, _cell: CellAddress, input: HTMLInputElement): void {\r\n    \tSmallDialogInputElement.setInputAttrs(this, grid, input)\r\n    }\r\n}\r\n","import type {ListGridAPI, RecordBoolean} from '../../ts-types';\r\nimport {isPromise} from '../../internal/utils';\r\n\r\nexport function isDisabledRecord<T>(option: RecordBoolean, grid: ListGridAPI<T>, row: number): boolean {\r\n\tif (grid.disabled) {\r\n\t\treturn true;\r\n\t}\r\n\treturn getBooleanOptionOfRecord(option, grid, row);\r\n}\r\nexport function isReadOnlyRecord<T>(option: RecordBoolean, grid: ListGridAPI<T>, row: number): boolean {\r\n\tif (grid.readOnly) {\r\n\t\treturn true;\r\n\t}\r\n\treturn getBooleanOptionOfRecord(option, grid, row);\r\n}\r\n\r\nexport function toggleValue(val: number): number;\r\nexport function toggleValue(val: string): string;\r\nexport function toggleValue(val: unknown): boolean;\r\nexport function toggleValue(val: number | string | unknown): number | string | boolean {\r\n\tif (typeof val === 'number') {\r\n\t\tif (val === 0) {\r\n\t\t\treturn 1;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t} else if (typeof val === 'string') {\r\n\t\tif (val === 'false') {\r\n\t\t\treturn 'true';\r\n\t\t} else if (val === 'off') {\r\n\t\t\treturn 'on';\r\n\t\t} else if (/^0+$/.exec(val)) {\r\n\t\t\treturn val.replace(/^(0*)0$/, '$11');\r\n\t\t} else if (val === 'true') {\r\n\t\t\treturn 'false';\r\n\t\t} else if (val === 'on') {\r\n\t\t\treturn 'off';\r\n\t\t} else if (/^0*1$/.exec(val)) {\r\n\t\t\treturn val.replace(/^(0*)1$/, '$10');\r\n\t\t}\r\n\t}\r\n\treturn !val;\r\n}\r\n\r\nfunction getBooleanOptionOfRecord<T>(option: RecordBoolean, grid: ListGridAPI<T>, row: number): boolean {\r\n\tif (typeof option === 'function') {\r\n\t\tconst record = grid.getRowRecord(row);\r\n\t\tif (isPromise(record)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn !!option(record);\r\n\t}\r\n\treturn !!option;\r\n}\r\n","import type { CellAddress, EventListenerId, LayoutObjectId, ListGridAPI } from '../../ts-types'\r\nimport { event, isPromise } from '../../internal/utils'\r\nimport { DG_EVENT_TYPE } from '../../core/DG_EVENT_TYPE'\r\n\r\nconst KEY_ENTER = 13\r\nconst KEY_SPACE = 32\r\n\r\nexport function bindCellClickAction<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tcellId: LayoutObjectId,\r\n\t\t{\r\n\t\t\taction,\r\n\t\t\tmouseOver,\r\n\t\t\tmouseOut\r\n\t\t}: {\r\n        action: (cell: CellAddress) => void;\r\n        mouseOver: (cell: CellAddress) => boolean;\r\n        mouseOut: (cell: CellAddress) => void;\r\n    }\r\n): EventListenerId[] {\r\n\tfunction isTarget(col: number, row: number): boolean {\r\n\t\treturn grid.getLayoutCellId(col, row) === cellId\r\n\t}\r\n\r\n\treturn [\r\n\t\t// click\r\n\t\tgrid.listen(DG_EVENT_TYPE.CLICK_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (isPromise(grid.getRowRecord(e.row))) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\taction({\r\n\t\t\t\tcol: e.col,\r\n\t\t\t\trow: e.row\r\n\t\t\t})\r\n\t\t}),\r\n\t\t// mouse move\r\n\t\tgrid.listen(DG_EVENT_TYPE.MOUSEOVER_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (isPromise(grid.getRowRecord(e.row))) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (mouseOver) {\r\n\t\t\t\tif (\r\n\t\t\t\t\t!mouseOver({\r\n\t\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\t\trow: e.row\r\n\t\t\t\t\t})\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tgrid.getElement().style.cursor = 'pointer'\r\n\t\t}),\r\n\t\tgrid.listen(DG_EVENT_TYPE.MOUSEOUT_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (mouseOut) {\r\n\t\t\t\tmouseOut({\r\n\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\trow: e.row\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tgrid.getElement().style.cursor = ''\r\n\t\t})\r\n\t]\r\n}\r\n\r\nexport function bindCellKeyAction<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tcellId: LayoutObjectId,\r\n\t\t{\r\n\t\t\taction,\r\n\t\t\tacceptKeys = []\r\n\t\t}: {\r\n        action: (cell: CellAddress) => void;\r\n        acceptKeys?: number[];\r\n    }\r\n): EventListenerId[] {\r\n\tfunction isTarget(col: number, row: number): boolean {\r\n\t\treturn grid.getLayoutCellId(col, row) === cellId\r\n\t}\r\n\r\n\tacceptKeys = [ ...acceptKeys, KEY_ENTER, KEY_SPACE ]\r\n\treturn [\r\n\t\t// enter key down\r\n\t\tgrid.listen(DG_EVENT_TYPE.KEYDOWN, (e) => {\r\n\t\t\tif (acceptKeys.indexOf(e.keyCode) === -1) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (grid.keyboardOptions?.moveCellOnEnter && e.keyCode === KEY_ENTER) {\r\n\t\t\t\t// When moving with the enter key, no action is taken with the enter key.\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tconst sel = grid.selection.select\r\n\t\t\tif (!isTarget(sel.col, sel.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (isPromise(grid.getRowRecord(sel.row))) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\taction({\r\n\t\t\t\tcol: sel.col,\r\n\t\t\t\trow: sel.row\r\n\t\t\t})\r\n\t\t\tevent.cancel(e.event)\r\n\t\t})\r\n\t]\r\n}\r\n","import { EventHandler } from '../../../internal/EventHandler'\r\nimport type { ListGridAPI } from '../../../ts-types'\r\nimport { createElement } from '../../../internal/dom'\r\nimport { event } from '../../../internal/utils'\r\nimport { setInputValue } from './input-value-handler'\r\n\r\nconst KEY_TAB = 9\r\nconst KEY_ENTER = 13\r\n\r\nconst CLASSNAME = 'cheetah-grid__inline-input'\r\nimport './InlineInputElement.css'\r\n\r\nfunction createInputElement(): HTMLInputElement {\r\n\t// require('@/columns/action/internal/InlineInputElement.css')\r\n\treturn createElement('input', { classList: CLASSNAME })\r\n}\r\n\r\ntype EditorProps = { type?: string; classList?: string[] };\r\n\r\ntype ActiveData<T> = {\r\n    grid: ListGridAPI<T>;\r\n    col: number;\r\n    row: number;\r\n    editor: EditorProps;\r\n};\r\n\r\nfunction setInputAttrs<T>(editor: EditorProps, _grid: ListGridAPI<T>, input: HTMLInputElement): void {\r\n\tconst { classList, type } = editor\r\n\tif (classList) {\r\n\t\tinput.classList.add(...classList)\r\n\t}\r\n\tinput.type = type || ''\r\n}\r\n\r\nexport class InlineInputElement<T> {\r\n    private _handler: EventHandler\r\n\r\n    private _input: HTMLInputElement\r\n\r\n    private _beforePropEditor?: EditorProps | null\r\n\r\n    private _activeData?: ActiveData<T> | null\r\n\r\n    private _attaching?: boolean\r\n\r\n    static setInputAttrs<T>(editor: { type?: string; classList?: string[] }, grid: ListGridAPI<T>, input: HTMLInputElement): void {\r\n    \tsetInputAttrs(editor, grid, input)\r\n    }\r\n\r\n    constructor() {\r\n    \tthis._handler = new EventHandler()\r\n    \tthis._input = createInputElement()\r\n    \tthis._bindInputEvents()\r\n    }\r\n\r\n    dispose(): void {\r\n    \tconst input = this._input\r\n    \tthis.detach()\r\n    \tthis._handler.dispose()\r\n    \tdelete this._input\r\n    \tthis._beforePropEditor = null\r\n    \tinput.parentElement?.removeChild(input)\r\n    }\r\n\r\n    attach(grid: ListGridAPI<T>, editor: EditorProps, col: number, row: number, value: string): void {\r\n    \tconst input = this._input\r\n    \tconst handler = this._handler\r\n\r\n    \tif (this._beforePropEditor) {\r\n    \t\tconst { classList } = this._beforePropEditor\r\n    \t\tif (classList) {\r\n    \t\t\tinput.classList.remove(...classList)\r\n    \t\t}\r\n    \t}\r\n\r\n    \tinput.style.font = grid.font || '16px sans-serif'\r\n\r\n    \tconst { element, rect } = grid.getAttachCellsArea(grid.getCellRange(col, row))\r\n    \tinput.style.top = `${ rect.top.toFixed() }px`\r\n    \tinput.style.left = `${ rect.left.toFixed() }px`\r\n    \tinput.style.width = `${ rect.width.toFixed() }px`\r\n    \tinput.style.height = `${ rect.height.toFixed() }px`\r\n    \telement.appendChild(input)\r\n\r\n    \tsetInputAttrs(editor, grid, input)\r\n\r\n    \tsetInputValue(input, value)\r\n\r\n    \tthis._activeData = { grid, col, row, editor }\r\n    \tthis._beforePropEditor = editor\r\n\r\n    \tconst focus = (): void => {\r\n    \t\tinput.focus()\r\n\r\n    \t\tconst end = input.value.length\r\n    \t\ttry {\r\n    \t\t\tif (typeof input.selectionStart !== 'undefined') {\r\n    \t\t\t\tinput.selectionStart = end\r\n    \t\t\t\tinput.selectionEnd = end\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t} catch (e) {\r\n    \t\t\t//ignore\r\n    \t\t}\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tif ((document as any).selection) {\r\n    \t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t\tconst range = (input as any).createTextRange()\r\n    \t\t\trange.collapse()\r\n    \t\t\trange.moveEnd('character', end)\r\n    \t\t\trange.moveStart('character', end)\r\n    \t\t\trange.select()\r\n    \t\t}\r\n    \t}\r\n    \thandler.tryWithOffEvents(input, 'blur', () => {\r\n    \t\tfocus()\r\n    \t})\r\n\r\n    \tthis._attaching = true\r\n    \tsetTimeout(() => {\r\n    \t\tdelete this._attaching\r\n    \t})\r\n    }\r\n\r\n    detach(gridFocus?: boolean): void {\r\n    \tif (this._isActive()) {\r\n    \t\tconst { grid, col, row } = this._activeData!\r\n    \t\tconst input = this._input\r\n    \t\tthis._handler.tryWithOffEvents(input, 'blur', () => {\r\n    \t\t\tinput.parentElement?.removeChild(input)\r\n    \t\t})\r\n    \t\tconst range = grid.getCellRange(col, row)\r\n    \t\tgrid.invalidateCellRange(range)\r\n    \t\tif (gridFocus) {\r\n    \t\t\tgrid.focus()\r\n    \t\t}\r\n    \t}\r\n    \tthis._activeData = null\r\n    }\r\n\r\n    doChangeValue(): void {\r\n    \tif (!this._isActive()) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst input = this._input\r\n    \tconst { value } = input\r\n    \tconst { grid, col, row } = this._activeData!\r\n    \tgrid.doChangeValue(col, row, () => value)\r\n    }\r\n\r\n    _isActive(): boolean {\r\n    \tconst input = this._input\r\n    \tif (!input || !input.parentElement) {\r\n    \t\treturn false\r\n    \t}\r\n    \tif (!this._activeData) {\r\n    \t\treturn false\r\n    \t}\r\n    \treturn true\r\n    }\r\n\r\n    _bindInputEvents(): void {\r\n    \tconst handler = this._handler\r\n    \tconst input = this._input\r\n    \tconst stopPropagationOnly = (e: Event): void => e.stopPropagation() // grid\r\n    \thandler.on(input, 'click', stopPropagationOnly)\r\n    \thandler.on(input, 'mousedown', stopPropagationOnly)\r\n    \thandler.on(input, 'touchstart', stopPropagationOnly)\r\n    \thandler.on(input, 'dblclick', stopPropagationOnly)\r\n\r\n    \thandler.on(input, 'compositionstart', (_e) => {\r\n    \t\tinput.classList.add('composition')\r\n    \t})\r\n    \thandler.on(input, 'compositionend', (_e) => {\r\n    \t\tinput.classList.remove('composition')\r\n    \t})\r\n    \thandler.on(input, 'keydown', (e) => {\r\n    \t\tif (input.classList.contains('composition')) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst keyCode = event.getKeyCode(e)\r\n    \t\tif (keyCode === KEY_ENTER) {\r\n    \t\t\tthis._onKeydownEnter(e)\r\n    \t\t} else if (keyCode === KEY_TAB) {\r\n    \t\t\tthis._onKeydownTab(e)\r\n    \t\t}\r\n    \t})\r\n    \thandler.on(input, 'blur', (_e) => {\r\n    \t\tthis.doChangeValue()\r\n    \t\tthis.detach()\r\n    \t})\r\n    }\r\n\r\n    _onKeydownEnter(e: KeyboardEvent): void {\r\n    \tif (!this._isActive() || this._attaching) {\r\n    \t\treturn\r\n    \t}\r\n\r\n    \tconst { grid } = this._activeData!\r\n\r\n    \tthis.doChangeValue()\r\n    \tthis.detach(true)\r\n    \tevent.cancel(e)\r\n\r\n    \tif (grid.keyboardOptions?.moveCellOnEnter) {\r\n    \t\tgrid.onKeyDownMove(e)\r\n    \t}\r\n    }\r\n\r\n    _onKeydownTab(e: KeyboardEvent): void {\r\n    \tif (!this._isActive()) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst { grid } = this._activeData!\r\n    \tif (!grid.keyboardOptions?.moveCellOnTab) {\r\n    \t\treturn\r\n    \t}\r\n    \tthis.doChangeValue()\r\n    \tthis.detach(true)\r\n    \tgrid.onKeyDownMove(e)\r\n    }\r\n}\r\n","import type {ColumnMenuItemOption, ListGridAPI, RectProps} from '../../../ts-types';\r\nimport {appendHtml, createElement, disableFocus, empty, findNextSiblingFocusable, findPrevSiblingFocusable, isFocusable} from '../../../internal/dom';\r\nimport {EventHandler} from '../../../internal/EventHandler';\r\nimport type {Rect} from '../../../internal/Rect';\r\nimport {event} from '../../../internal/utils';\r\n\r\nconst KEY_TAB = 9;\r\nconst KEY_ENTER = 13;\r\nconst KEY_UP = 38;\r\nconst KEY_DOWN = 40;\r\nconst KEY_ESC = 27;\r\n\r\nconst CLASSNAME = 'cheetah-grid__inline-menu';\r\nconst ITEM_CLASSNAME = `${CLASSNAME}__menu-item`;\r\nconst HIDDEN_CLASSNAME = `${CLASSNAME}--hidden`;\r\nconst SHOWN_CLASSNAME = `${CLASSNAME}--shown`;\r\nconst EMPTY_ITEM_CLASSNAME = `${ITEM_CLASSNAME}--empty`;\r\n\r\nfunction findItemParents(target: HTMLElement | null): HTMLElement | null {\r\n\tlet el: HTMLElement | null = target;\r\n\twhile (el && !el.classList.contains(ITEM_CLASSNAME)) {\r\n\t\tel = el.parentElement;\r\n\t\tif (!el || el.classList.contains(CLASSNAME)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\treturn el;\r\n}\r\n\r\nimport './InlineMenuElement.css';\r\n\r\nfunction createMenuElement(): HTMLUListElement {\r\n\t// require(\"@/columns/action/internal/InlineMenuElement.css\");\r\n\treturn createElement('ul', {classList: CLASSNAME});\r\n}\r\n\r\nfunction attachElement(element: HTMLElement, rect: RectProps, menu: HTMLUListElement): void {\r\n\tmenu.style.top = `${rect.top.toFixed()}px`;\r\n\tmenu.style.left = `${rect.left.toFixed()}px`;\r\n\tmenu.style.width = `${rect.width.toFixed()}px`;\r\n\tmenu.style.lineHeight = `${rect.height.toFixed()}px`;\r\n\telement.appendChild(menu);\r\n}\r\n\r\nfunction optionToLi({classList, label, value, html}: ColumnMenuItemOption, index: number): HTMLLIElement {\r\n\tconst item = createElement('li', {classList: ITEM_CLASSNAME});\r\n\titem.tabIndex = 0;\r\n\titem.dataset.valueindex = `${index}`;\r\n\tif (classList) {\r\n\t\titem.classList.add(...(Array.isArray(classList) ? classList : [classList]));\r\n\t}\r\n\r\n\tif (label) {\r\n\t\tconst span = createElement('span', {text: label});\r\n\t\titem.appendChild(span);\r\n\t} else if (html) {\r\n\t\tappendHtml(item, html);\r\n\t}\r\n\r\n\tif (value === '' || value == null) {\r\n\t\titem.classList.add(EMPTY_ITEM_CLASSNAME);\r\n\t}\r\n\r\n\treturn item;\r\n}\r\n\r\nfunction openMenu<T>(grid: ListGridAPI<T>, editor: EditorProps<T>, col: number, row: number, value: string, options: ColumnMenuItemOption[], menu: HTMLUListElement): void {\r\n\tconst {classList} = editor;\r\n\tmenu.classList.remove(SHOWN_CLASSNAME);\r\n\tmenu.classList.add(HIDDEN_CLASSNAME);\r\n\tempty(menu);\r\n\tmenu.style.font = grid.font || '16px sans-serif';\r\n\tlet emptyItemEl: null | HTMLElement = null;\r\n\tlet valueItemEl: null | HTMLElement = null;\r\n\r\n\toptions.forEach((option, i) => {\r\n\t\tconst item = optionToLi(option, i);\r\n\t\tmenu.appendChild(item);\r\n\t\tif (option.value === value) {\r\n\t\t\tvalueItemEl = item;\r\n\t\t\titem.dataset.select = 'select';\r\n\t\t}\r\n\t\tif (item.classList.contains(EMPTY_ITEM_CLASSNAME)) {\r\n\t\t\temptyItemEl = item;\r\n\t\t}\r\n\t});\r\n\tconst focusEl = valueItemEl || emptyItemEl || (menu.children[0] as HTMLElement);\r\n\tif (classList) {\r\n\t\tmenu.classList.add(...classList);\r\n\t}\r\n\tconst children = Array.prototype.slice.call(menu.children, 0);\r\n\tconst focusIndex = children.indexOf(focusEl);\r\n\tconst {element, rect} = grid.getAttachCellsArea(grid.getCellRange(col, row));\r\n\r\n\t// Cover the right line\r\n\trect.width++;\r\n\r\n\t// append for calculation\r\n\tattachElement(element, rect, menu);\r\n\r\n\t// Make the selection item at the middle\r\n\tlet offset = 0;\r\n\tlet allHeight = 0;\r\n\tfor (let i = 0; i < children.length; i++) {\r\n\t\tconst {offsetHeight} = children[i];\r\n\t\tif (i < focusIndex) {\r\n\t\t\toffset += offsetHeight;\r\n\t\t}\r\n\t\tallHeight += offsetHeight;\r\n\t}\r\n\t(rect as Rect).offsetTop(-offset);\r\n\tmenu.style.transformOrigin = `center ${offset + Math.ceil(children[focusIndex].offsetHeight / 2)}px 0px`;\r\n\tattachElement(element, rect, menu);\r\n\r\n\t// Control not to overflow the screen range\r\n\tconst menuClientRect = menu.getBoundingClientRect();\r\n\tconst scaleDiff = (allHeight - menuClientRect.height) / 2;\r\n\tconst orgMenuTop = menuClientRect.top - scaleDiff;\r\n\tlet menuTop = orgMenuTop;\r\n\tconst menuBottom = menuTop + allHeight;\r\n\tconst winBottom = window.innerHeight;\r\n\tconst winMargin = 20;\r\n\tif (menuBottom > winBottom - winMargin) {\r\n\t\tconst diff = menuBottom - winBottom + winMargin;\r\n\t\tmenuTop -= diff;\r\n\t}\r\n\tif (menuTop < 0 /*winTop*/ + winMargin) {\r\n\t\tmenuTop = winMargin;\r\n\t}\r\n\tif (menuTop !== orgMenuTop) {\r\n\t\t(rect as Rect).offsetTop(-(orgMenuTop - menuTop));\r\n\t\t// re update\r\n\t\tattachElement(element, rect, menu);\r\n\t}\r\n\r\n\tif (focusEl) {\r\n\t\tfocusEl.focus();\r\n\t}\r\n\tmenu.classList.remove(HIDDEN_CLASSNAME);\r\n\tmenu.classList.add(SHOWN_CLASSNAME);\r\n}\r\n\r\nfunction closeMenu<T>(_grid: ListGridAPI<T>, _col: number, _row: number, menu: HTMLUListElement): void {\r\n\tmenu.classList.remove(SHOWN_CLASSNAME);\r\n\tmenu.classList.add(HIDDEN_CLASSNAME);\r\n\tdisableFocus(menu);\r\n}\r\n\r\ntype EditorProps<T> = {\r\n  classList?: string[];\r\n  options: (record: T | undefined) => ColumnMenuItemOption[];\r\n};\r\ntype ActiveData<T> = {\r\n  grid: ListGridAPI<T>;\r\n  col: number;\r\n  row: number;\r\n  editor: EditorProps<T>;\r\n  options: ColumnMenuItemOption[];\r\n};\r\n\r\nexport class InlineMenuElement<T> {\r\n  private _handler: EventHandler;\r\n\r\n  private _menu: HTMLUListElement;\r\n\r\n  private _beforePropEditor?: EditorProps<T> | null;\r\n\r\n  private _activeData?: ActiveData<T> | null;\r\n\r\n  constructor() {\r\n  \tthis._handler = new EventHandler();\r\n  \tthis._menu = createMenuElement();\r\n  \tthis._bindMenuEvents();\r\n  }\r\n\r\n  dispose(): void {\r\n  \tconst menu = this._menu;\r\n  \tthis.detach();\r\n  \tthis._handler.dispose();\r\n  \tdelete this._menu;\r\n  \tthis._beforePropEditor = null;\r\n  \tmenu.parentElement?.removeChild(menu);\r\n  }\r\n\r\n  attach(grid: ListGridAPI<T>, editor: EditorProps<T>, col: number, row: number, value: string, record: T | undefined): void {\r\n  \tconst menu = this._menu;\r\n\r\n  \tif (this._beforePropEditor) {\r\n  \t\tconst {classList} = this._beforePropEditor;\r\n  \t\tif (classList) {\r\n  \t\t\tmenu.classList.remove(...classList);\r\n  \t\t}\r\n  \t}\r\n\r\n  \tconst options = editor.options(record);\r\n\r\n  \topenMenu(grid, editor, col, row, value, options, menu);\r\n  \tthis._activeData = {grid, col, row, editor, options};\r\n  \tthis._beforePropEditor = editor;\r\n  }\r\n\r\n  detach(gridFocus?: boolean): void {\r\n  \tif (this._isActive()) {\r\n  \t\tconst {grid, col, row} = this._activeData!;\r\n  \t\tconst menu = this._menu;\r\n  \t\tcloseMenu(grid, col, row, menu);\r\n\r\n  \t\tconst range = grid.getCellRange(col, row);\r\n  \t\tgrid.invalidateCellRange(range);\r\n  \t\tif (gridFocus) {\r\n  \t\t\tgrid.focus();\r\n  \t\t}\r\n  \t}\r\n  \tthis._activeData = null;\r\n  }\r\n\r\n  _doChangeValue(valueindex: number | string): void {\r\n  \tif (!this._isActive()) {\r\n  \t\treturn;\r\n  \t}\r\n  \tconst {grid, col, row, options} = this._activeData!;\r\n  \tconst option = options[Number(valueindex)];\r\n  \tif (option) {\r\n  \t\tconst {value} = option;\r\n  \t\tgrid.doChangeValue(col, row, () => value);\r\n  \t}\r\n  }\r\n\r\n  _isActive(): boolean {\r\n  \tconst menu = this._menu;\r\n  \tif (!menu || !menu.parentElement) {\r\n  \t\treturn false;\r\n  \t}\r\n  \tif (!this._activeData) {\r\n  \t\treturn false;\r\n  \t}\r\n  \treturn true;\r\n  }\r\n\r\n  _bindMenuEvents(): void {\r\n  \tconst handler = this._handler;\r\n  \tconst menu = this._menu;\r\n\r\n  \tconst stopPropagationOnly = (e: Event): void => e.stopPropagation(); // grid\r\n\r\n  \thandler.on(menu, 'mousedown', stopPropagationOnly);\r\n  \thandler.on(menu, 'touchstart', stopPropagationOnly);\r\n  \thandler.on(menu, 'dblclick', stopPropagationOnly);\r\n\r\n  \thandler.on(menu, 'click', (e) => {\r\n  \t\te.stopPropagation();\r\n  \t\tconst item = findItemParents(e.target as HTMLElement);\r\n  \t\tif (!item) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tconst {valueindex} = item.dataset;\r\n  \t\tthis._doChangeValue(valueindex || '');\r\n  \t\tthis.detach(true);\r\n  \t});\r\n  \thandler.on(menu, 'keydown', (e) => {\r\n  \t\tconst item = findItemParents(e.target as HTMLElement);\r\n  \t\tif (!item) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tconst keyCode = event.getKeyCode(e);\r\n  \t\tif (keyCode === KEY_ENTER) {\r\n  \t\t\tthis._onKeydownEnter(menu, item, e);\r\n  \t\t} else if (keyCode === KEY_ESC) {\r\n  \t\t\tthis.detach(true);\r\n  \t\t\tevent.cancel(e);\r\n  \t\t} else if (keyCode === KEY_UP) {\r\n  \t\t\tconst n = findPrevSiblingFocusable(item);\r\n  \t\t\tif (n) {\r\n  \t\t\t\tn.focus();\r\n  \t\t\t\tevent.cancel(e);\r\n  \t\t\t}\r\n  \t\t} else if (keyCode === KEY_DOWN) {\r\n  \t\t\tconst n = findNextSiblingFocusable(item);\r\n  \t\t\tif (n) {\r\n  \t\t\t\tn.focus();\r\n  \t\t\t\tevent.cancel(e);\r\n  \t\t\t}\r\n  \t\t} else if (keyCode === KEY_TAB) {\r\n  \t\t\tthis._onKeydownTab(menu, item, e);\r\n  \t\t}\r\n  \t});\r\n  }\r\n\r\n  _onKeydownEnter(_menu: HTMLUListElement, item: HTMLElement, e: KeyboardEvent): void {\r\n  \tconst grid = this._isActive() ? this._activeData!.grid : null;\r\n  \tconst {valueindex} = item.dataset;\r\n  \tthis._doChangeValue(valueindex || '');\r\n  \tthis.detach(true);\r\n  \tevent.cancel(e);\r\n\r\n  \tif (grid) {\r\n  \t\tif (grid.keyboardOptions?.moveCellOnEnter) {\r\n  \t\t\tgrid.onKeyDownMove(e);\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  _onKeydownTab(menu: HTMLUListElement, item: HTMLElement, e: KeyboardEvent): void {\r\n  \tif (this._isActive()) {\r\n  \t\tconst {grid} = this._activeData!;\r\n  \t\tif (grid.keyboardOptions?.moveCellOnTab) {\r\n  \t\t\tconst {valueindex} = item.dataset;\r\n  \t\t\tthis._doChangeValue(valueindex || '');\r\n  \t\t\tthis.detach(true);\r\n  \t\t\tgrid.onKeyDownMove(e);\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tif (!e.shiftKey) {\r\n  \t\tif (!findNextSiblingFocusable(item)) {\r\n  \t\t\tlet n: HTMLElement | null = menu.querySelector(`.${ITEM_CLASSNAME}`) as HTMLElement;\r\n  \t\t\tif (!isFocusable(n)) {\r\n  \t\t\t\tn = findNextSiblingFocusable(n);\r\n  \t\t\t}\r\n  \t\t\tif (n) {\r\n  \t\t\t\tn.focus();\r\n  \t\t\t\tevent.cancel(e);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t} else {\r\n  \t\tif (!findPrevSiblingFocusable(item)) {\r\n  \t\t\tconst items = menu.querySelectorAll(`.${ITEM_CLASSNAME}`);\r\n  \t\t\tlet n: HTMLElement | null = items[items.length - 1] as HTMLElement;\r\n  \t\t\tif (!isFocusable(n)) {\r\n  \t\t\t\tn = findPrevSiblingFocusable(n);\r\n  \t\t\t}\r\n  \t\t\tif (n) {\r\n  \t\t\t\tn.focus();\r\n  \t\t\t\tevent.cancel(e);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n  }\r\n}\r\n","import type { ListGridAPI, MaybePromise } from '../../../ts-types'\r\nimport { browser, event, then } from '../../../internal/utils'\r\nimport { EventHandler } from '../../../internal/EventHandler'\r\nimport { createElement } from '../../../internal/dom'\r\nimport { setInputValue } from './input-value-handler'\r\n\r\nconst CLASSNAME = 'cheetah-grid__small-dialog-input'\r\nconst INPUT_CLASSNAME = `${ CLASSNAME }__input`\r\nconst HIDDEN_CLASSNAME = `${ CLASSNAME }--hidden`\r\nconst SHOWN_CLASSNAME = `${ CLASSNAME }--shown`\r\n\r\nconst KEY_ENTER = 13\r\nconst KEY_ESC = 27\r\n\r\nfunction _focus(input: HTMLInputElement, handler: EventHandler): void {\r\n\tconst focus = (): void => {\r\n\t\tinput.focus()\r\n\r\n\t\tconst end = input.value.length\r\n\t\ttry {\r\n\t\t\tif (typeof input.selectionStart !== 'undefined') {\r\n\t\t\t\tinput.selectionStart = end\r\n\t\t\t\tinput.selectionEnd = end\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t//ignore\r\n\t\t}\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tif ((document as any).selection) {\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\tconst range = (input as any).createTextRange()\r\n\t\t\trange.collapse()\r\n\t\t\trange.moveEnd('character', end)\r\n\t\t\trange.moveStart('character', end)\r\n\t\t\trange.select()\r\n\t\t}\r\n\t}\r\n\thandler.tryWithOffEvents(input, 'blur', () => {\r\n\t\tfocus()\r\n\t})\r\n}\r\n\r\nimport './SmallDialogInputElement.css'\r\n\r\nfunction createDialogElement(): HTMLDivElement {\r\n\t// require('@/columns/action/internal/SmallDialogInputElement.css')\r\n\tconst element = createElement('div', {\r\n\t\tclassList: [ CLASSNAME, HIDDEN_CLASSNAME ]\r\n\t})\r\n\tconst input = createElement('input', { classList: INPUT_CLASSNAME })\r\n\tinput.readOnly = true\r\n\tinput.tabIndex = -1\r\n\telement.appendChild(input)\r\n\treturn element\r\n}\r\n\r\ntype GetValueResult<T, R> = (value: string, info: { grid: ListGridAPI<T>; col: number; row: number }) => R;\r\n\r\ntype EditorProps<T> = {\r\n    type?: string;\r\n    classList?: string[];\r\n    helperText?: string | GetValueResult<T, string>;\r\n    inputValidator?: GetValueResult<T, MaybePromise<string>>;\r\n    validator?: GetValueResult<T, MaybePromise<string>>;\r\n};\r\n\r\ntype ActiveData<T> = {\r\n    grid: ListGridAPI<T>;\r\n    col: number;\r\n    row: number;\r\n    editor: EditorProps<T>;\r\n};\r\n\r\nfunction bindProps<T>(grid: ListGridAPI<T>, dialog: HTMLDivElement, input: HTMLInputElement, editor: EditorProps<T>): void {\r\n\tconst { classList, helperText } = editor\r\n\tif (classList) {\r\n\t\tdialog.classList.add(...classList)\r\n\t}\r\n\tif (helperText && typeof helperText !== 'function') {\r\n\t\tdialog.dataset.helperText = helperText\r\n\t}\r\n\tsetInputAttrs(editor, grid, input)\r\n}\r\n\r\nfunction unbindProps<T>(_grid: ListGridAPI<T>, dialog: HTMLDivElement, input: HTMLInputElement, editor: EditorProps<T>): void {\r\n\tconst { classList } = editor\r\n\tif (classList) {\r\n\t\tdialog.classList.remove(...classList)\r\n\t}\r\n\tdelete dialog.dataset.helperText\r\n\tinput.type = ''\r\n}\r\n\r\nfunction setInputAttrs<T>(editor: EditorProps<T>, _grid: ListGridAPI<T>, input: HTMLInputElement): void {\r\n\tconst { type } = editor\r\n\tinput.type = type || ''\r\n}\r\n\r\nexport class SmallDialogInputElement<T> {\r\n    private _handler: EventHandler\r\n\r\n    private _dialog: HTMLDivElement\r\n\r\n    private _input: HTMLInputElement\r\n\r\n    private _beforePropEditor?: EditorProps<T> | null\r\n\r\n    private _activeData?: ActiveData<T> | null\r\n\r\n    private _attaching?: boolean\r\n\r\n    private _beforeValue?: string | null\r\n\r\n    static setInputAttrs<T>(editor: EditorProps<T>, grid: ListGridAPI<T>, input: HTMLInputElement): void {\r\n    \tsetInputAttrs(editor, grid, input)\r\n    }\r\n\r\n    constructor() {\r\n    \tthis._handler = new EventHandler()\r\n    \tthis._dialog = createDialogElement()\r\n    \tthis._input = this._dialog.querySelector(`.${ INPUT_CLASSNAME }`) as HTMLInputElement\r\n    \tthis._bindDialogEvents()\r\n    }\r\n\r\n    dispose(): void {\r\n    \tconst dialog = this._dialog\r\n    \tthis.detach()\r\n    \tthis._handler.dispose()\r\n    \tdelete this._dialog\r\n    \tdelete this._input\r\n    \tthis._beforePropEditor = null\r\n    \tif (dialog.parentElement) {\r\n    \t\tdialog.parentElement.removeChild(dialog)\r\n    \t}\r\n    }\r\n\r\n    attach(grid: ListGridAPI<T>, editor: EditorProps<T>, col: number, row: number, value: string): void {\r\n    \tconst handler = this._handler\r\n    \tconst dialog = this._dialog\r\n    \tconst input = this._input\r\n\r\n    \tif (this._beforePropEditor) {\r\n    \t\tunbindProps(grid, dialog, input, this._beforePropEditor)\r\n    \t}\r\n\r\n    \tdelete dialog.dataset.errorMessage\r\n    \tdialog.classList.remove(SHOWN_CLASSNAME)\r\n    \tdialog.classList.add(HIDDEN_CLASSNAME)\r\n    \tinput.readOnly = true\r\n    \tinput.tabIndex = 0\r\n    \tconst { element, rect } = grid.getAttachCellsArea(grid.getCellRange(col, row))\r\n    \tdialog.style.top = `${ rect.top.toFixed() }px`\r\n    \tdialog.style.left = `${ rect.left.toFixed() }px`\r\n    \tdialog.style.width = `${ rect.width.toFixed() }px`\r\n    \tinput.style.height = `${ rect.height.toFixed() }px`\r\n    \telement.appendChild(dialog)\r\n\r\n    \tsetInputValue(input, value)\r\n\r\n    \tinput.style.font = grid.font || '16px sans-serif'\r\n    \tconst activeData = { grid, col, row, editor }\r\n    \tthis._onInputValue(input, activeData)\r\n    \tif (!browser.IE) {\r\n    \t\t_focus(input, handler)\r\n    \t} else {\r\n    \t\t// On the paste-event on IE, since it may not be focused, it will be delayed and focused.\r\n    \t\tsetTimeout(() => _focus(input, handler))\r\n    \t}\r\n    \tdialog.classList.add(SHOWN_CLASSNAME)\r\n    \tdialog.classList.remove(HIDDEN_CLASSNAME)\r\n    \tinput.readOnly = false\r\n\r\n    \tbindProps(grid, dialog, input, editor)\r\n\r\n    \tthis._activeData = activeData\r\n    \tthis._beforePropEditor = editor\r\n\r\n    \tthis._attaching = true\r\n    \tsetTimeout(() => {\r\n    \t\tdelete this._attaching\r\n    \t})\r\n    }\r\n\r\n    detach(gridFocus?: boolean): void {\r\n    \tif (this._isActive()) {\r\n    \t\tconst dialog = this._dialog\r\n    \t\tconst input = this._input\r\n\r\n    \t\tdialog.classList.remove(SHOWN_CLASSNAME)\r\n    \t\tdialog.classList.add(HIDDEN_CLASSNAME)\r\n    \t\tinput.readOnly = true\r\n    \t\tinput.tabIndex = -1\r\n\r\n    \t\tconst { grid, col, row } = this._activeData!\r\n\r\n    \t\tconst range = grid.getCellRange(col, row)\r\n    \t\tgrid.invalidateCellRange(range)\r\n    \t\tif (gridFocus) {\r\n    \t\t\tgrid.focus()\r\n    \t\t}\r\n    \t}\r\n    \tthis._activeData = null\r\n    \tthis._beforeValue = null\r\n    }\r\n\r\n    _doChangeValue(): MaybePromise<boolean> {\r\n    \tif (!this._isActive()) {\r\n    \t\treturn false\r\n    \t}\r\n    \tconst input = this._input\r\n    \tconst { value } = input\r\n    \treturn then(this._validate(value), (res) => {\r\n    \t\tif (res && value === input.value) {\r\n    \t\t\tconst { grid, col, row } = this._activeData!\r\n    \t\t\tgrid.doChangeValue(col, row, () => value)\r\n    \t\t\treturn true\r\n    \t\t}\r\n    \t\treturn false\r\n    \t})\r\n    }\r\n\r\n    _isActive(): boolean {\r\n    \tconst dialog = this._dialog\r\n    \tif (!dialog || !dialog.parentElement) {\r\n    \t\treturn false\r\n    \t}\r\n    \tif (!this._activeData) {\r\n    \t\treturn false\r\n    \t}\r\n    \treturn true\r\n    }\r\n\r\n    _bindDialogEvents(): void {\r\n    \tconst handler = this._handler\r\n    \tconst dialog = this._dialog\r\n    \tconst input = this._input\r\n    \tconst stopPropagationOnly = (e: Event): void => e.stopPropagation() // grid\r\n    \thandler.on(dialog, 'click', stopPropagationOnly)\r\n    \thandler.on(dialog, 'dblclick', stopPropagationOnly)\r\n    \thandler.on(dialog, 'mousedown', stopPropagationOnly)\r\n    \thandler.on(dialog, 'touchstart', stopPropagationOnly)\r\n\r\n    \thandler.on(input, 'compositionstart', (_e) => {\r\n    \t\tinput.classList.add('composition')\r\n    \t})\r\n    \thandler.on(input, 'compositionend', (_e) => {\r\n    \t\tinput.classList.remove('composition')\r\n    \t\tthis._onInputValue(input)\r\n    \t})\r\n    \tconst onKeyupAndPress = (_e: KeyboardEvent): void => {\r\n    \t\tif (input.classList.contains('composition')) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tthis._onInputValue(input)\r\n    \t}\r\n    \thandler.on(input, 'keyup', onKeyupAndPress)\r\n    \thandler.on(input, 'keypress', onKeyupAndPress)\r\n    \thandler.on(input, 'keydown', (e) => {\r\n    \t\tif (input.classList.contains('composition')) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst keyCode = event.getKeyCode(e)\r\n    \t\tif (keyCode === KEY_ESC) {\r\n    \t\t\tthis.detach(true)\r\n    \t\t\tevent.cancel(e)\r\n    \t\t} else if (keyCode === KEY_ENTER) {\r\n    \t\t\tthis._onKeydownEnter(e)\r\n    \t\t} else {\r\n    \t\t\tthis._onInputValue(input)\r\n    \t\t}\r\n    \t})\r\n    }\r\n\r\n    _onKeydownEnter(e: KeyboardEvent): void {\r\n    \tif (this._attaching) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst input = this._input\r\n    \tconst { value } = input\r\n    \tthen(this._doChangeValue(), (r) => {\r\n    \t\tif (r && value === input.value) {\r\n    \t\t\tconst grid = this._isActive() ? this._activeData!.grid : null\r\n    \t\t\tthis.detach(true)\r\n\r\n    \t\t\tif (grid?.keyboardOptions?.moveCellOnEnter) {\r\n    \t\t\t\tgrid.onKeyDownMove(e)\r\n    \t\t\t}\r\n    \t\t}\r\n    \t})\r\n    \tevent.cancel(e)\r\n    }\r\n\r\n    _onInputValue(input: HTMLInputElement, activeData?: ActiveData<T>): void {\r\n    \tconst before = this._beforeValue\r\n    \tconst { value } = input\r\n    \tif (before !== value) {\r\n    \t\tthis._onInputValueChange(value, activeData)\r\n    \t}\r\n    \tthis._beforeValue = value\r\n    }\r\n\r\n    _onInputValueChange(after: string, activeData?: ActiveData<T>): void {\r\n    \tactiveData = (activeData || this._activeData)!\r\n    \tconst dialog = this._dialog\r\n    \tconst { grid, col, row, editor } = activeData\r\n    \tif (typeof editor.helperText === 'function') {\r\n    \t\tconst helperText = editor.helperText(after, { grid, col, row })\r\n    \t\tif (helperText) {\r\n    \t\t\tdialog.dataset.helperText = helperText\r\n    \t\t} else {\r\n    \t\t\tdelete dialog.dataset.helperText\r\n    \t\t}\r\n    \t}\r\n    \tif ('errorMessage' in dialog.dataset) {\r\n    \t\tthis._validate(after, true)\r\n    \t}\r\n    }\r\n\r\n    _validate(value: string, inputOnly?: boolean): MaybePromise<boolean> {\r\n    \tconst dialog = this._dialog\r\n    \tconst input = this._input\r\n    \tconst { grid, col, row, editor } = this._activeData!\r\n    \tlet message: MaybePromise<string> = ''\r\n    \tif (editor.inputValidator) {\r\n    \t\tmessage = editor.inputValidator(value, { grid, col, row })\r\n    \t}\r\n    \treturn then(message, (message: MaybePromise<string>) => {\r\n    \t\tif (!message && editor.validator && !inputOnly) {\r\n    \t\t\tmessage = editor.validator(value, { grid, col, row })\r\n    \t\t}\r\n    \t\treturn then(message, (message) => {\r\n    \t\t\tif (message && value === input.value) {\r\n    \t\t\t\tdialog.dataset.errorMessage = message\r\n    \t\t\t} else {\r\n    \t\t\t\tdelete dialog.dataset.errorMessage\r\n    \t\t\t}\r\n    \t\t\treturn !message\r\n    \t\t})\r\n    \t})\r\n    }\r\n}\r\n","import { EventHandler } from '../../../internal/EventHandler'\r\n\r\nexport function setInputValue(input: HTMLInputElement, value: string): void {\r\n\tconst sign = input.type === 'number' && value === '-'\r\n\tif (sign) {\r\n\t\t// When `type=\"number\"`, the minus sign is not accepted, so change it to `type=\"text\"` once.\r\n\t\tinput.type = ''\r\n\t\tlet handler: EventHandler | null = new EventHandler()\r\n\t\tconst dispose = (): void => {\r\n\t\t\tif (handler) {\r\n\t\t\t\thandler.dispose()\r\n\t\t\t\thandler = null\r\n\t\t\t}\r\n\t\t}\r\n\t\thandler.once(input, 'input', (_e) => {\r\n\t\t\tinput.type = 'number'\r\n\t\t\tdispose()\r\n\t\t})\r\n\t\thandler.once(input, 'blur', (_e) => {\r\n\t\t\tdispose()\r\n\t\t})\r\n\t}\r\n\r\n\tinput.value = value ?? ''\r\n}\r\n","import type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, MessageObject } from '../../ts-types'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport type { MessageElement } from './internal/MessageElement'\r\n\r\nexport abstract class BaseMessage<T> {\r\n    private _grid: ListGridAPI<T>\r\n\r\n    private _messageElement: MessageElement | null = null\r\n\r\n    constructor(grid: ListGridAPI<T>) {\r\n    \tthis._grid = grid\r\n    }\r\n\r\n    dispose(): void {\r\n    \tthis.detachMessageElement()\r\n    \tif (this._messageElement) {\r\n    \t\tthis._messageElement.dispose()\r\n    \t}\r\n    \tthis._messageElement = null\r\n    }\r\n\r\n    _getMessageElement(): MessageElement {\r\n    \treturn this._messageElement || (this._messageElement = this.createMessageElementInternal())\r\n    }\r\n\r\n    abstract createMessageElementInternal(): MessageElement;\r\n\r\n    abstract drawCellMessageInternal(message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;\r\n\r\n    attachMessageElement(col: number, row: number, message: MessageObject): void {\r\n    \tconst messageElement = this._getMessageElement()\r\n    \tmessageElement.attach(this._grid, col, row, message)\r\n    }\r\n\r\n    moveMessageElement(col: number, row: number): void {\r\n    \tconst messageElement = this._getMessageElement()\r\n    \tmessageElement.move(this._grid, col, row)\r\n    }\r\n\r\n    detachMessageElement(): void {\r\n    \tconst messageElement = this._getMessageElement()\r\n    \tmessageElement._detach()\r\n    }\r\n\r\n    drawCellMessage(message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void {\r\n    \tthis.drawCellMessageInternal(message, context, style, helper, grid, info)\r\n    }\r\n}\r\n","import * as messageUtils from './messageUtils'\r\nimport type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, MessageObject } from '../../ts-types'\r\nimport { BaseMessage } from './BaseMessage'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { ErrorMessageElement } from './internal/ErrorMessageElement'\r\nimport { cellInRange } from '../../internal/utils'\r\n\r\nconst RED_A100 = '#ff8a80'\r\n\r\nexport class ErrorMessage<T> extends BaseMessage<T> {\r\n\tcreateMessageElementInternal(): ErrorMessageElement {\r\n\t\treturn new ErrorMessageElement()\r\n\t}\r\n\r\n\tdrawCellMessageInternal(_message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, _info: DrawCellInfo<T>): void {\r\n\t\tconst { bgColor } = style\r\n\t\tconst { select } = context.getSelection()\r\n\t\tif (!cellInRange(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {\r\n\t\t\thelper.drawBorderWithClip(context, (ctx: CanvasRenderingContext2D): void => {\r\n\t\t\t\tmessageUtils.drawExclamationMarkBox(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbgColor: helper.getColor(helper.theme.messages.errorBgColor, context.col, context.row, ctx) || RED_A100,\r\n\t\t\t\t\t\t\tcolor: bgColor\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\thelper\r\n\t\t\t\t)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n","import * as messageUtils from './messageUtils'\r\nimport type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, MessageObject } from '../../ts-types'\r\nimport { BaseMessage } from './BaseMessage'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { MessageElement } from './internal/MessageElement'\r\nimport { cellInRange } from '../../internal/utils'\r\n\r\nconst GREY_L2 = '#e0e0e0'\r\n\r\nexport class InfoMessage<T> extends BaseMessage<T> {\r\n\tcreateMessageElementInternal(): MessageElement {\r\n\t\treturn new MessageElement()\r\n\t}\r\n\r\n\tdrawCellMessageInternal(_message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, _info: DrawCellInfo<T>): void {\r\n\t\tconst { bgColor } = style\r\n\t\tconst { select } = context.getSelection()\r\n\t\tif (!cellInRange(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {\r\n\t\t\thelper.drawBorderWithClip(context, (ctx: CanvasRenderingContext2D): void => {\r\n\t\t\t\tmessageUtils.drawInformationMarkBox(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbgColor: helper.getColor(helper.theme.messages.infoBgColor, context.col, context.row, ctx) || GREY_L2,\r\n\t\t\t\t\t\t\tcolor: bgColor\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\thelper\r\n\t\t\t\t)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n","import type { MessageHandler as Base, DrawCellInfo } from '../../ts-types-internal'\r\nimport type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, Message, MessageObject } from '../../ts-types'\r\nimport type { BaseMessage } from './BaseMessage'\r\nimport { ErrorMessage } from './ErrorMessage'\r\nimport { InfoMessage } from './InfoMessage'\r\nimport { LG_EVENT_TYPE } from '../../list-grid/LG_EVENT_TYPE'\r\nimport { WarningMessage } from './WarningMessage'\r\nimport { isPromise } from '../../internal/utils'\r\n\r\nconst EMPTY_MESSAGE: MessageObject = {\r\n\ttype: 'error',\r\n\tmessage: null\r\n}\r\n\r\nconst MESSAGE_INSTANCE_FACTORY = {\r\n\terror<T>(grid: ListGridAPI<T>): BaseMessage<T> {\r\n\t\treturn new ErrorMessage(grid)\r\n\t},\r\n\tinfo<T>(grid: ListGridAPI<T>): BaseMessage<T> {\r\n\t\treturn new InfoMessage(grid)\r\n\t},\r\n\twarning<T>(grid: ListGridAPI<T>): BaseMessage<T> {\r\n\t\treturn new WarningMessage(grid)\r\n\t}\r\n}\r\n\r\nfunction normalizeMessage(message: Message): MessageObject {\r\n\tif (!message || isPromise(message)) {\r\n\t\treturn EMPTY_MESSAGE\r\n\t}\r\n\tif (typeof message === 'string') {\r\n\t\treturn {\r\n\t\t\ttype: 'error',\r\n\t\t\tmessage,\r\n\t\t\toriginal: message\r\n\t\t}\r\n\t}\r\n\tconst type = message.type || 'error'\r\n\tif (type && type in MESSAGE_INSTANCE_FACTORY) {\r\n\t\treturn {\r\n\t\t\ttype: type.toLowerCase() as MessageObject['type'],\r\n\t\t\tmessage: message.message,\r\n\t\t\toriginal: message\r\n\t\t}\r\n\t}\r\n\treturn {\r\n\t\ttype: 'error',\r\n\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n\t\tmessage: `${ message }`,\r\n\t\toriginal: message\r\n\t}\r\n}\r\n\r\nexport function hasMessage(message: Message): boolean {\r\n\treturn !!normalizeMessage(message).message\r\n}\r\n\r\nexport class MessageHandler<T> implements Base<T> {\r\n    private _grid: ListGridAPI<T>\r\n\r\n    private _messageInstances: {\r\n        [k in MessageObject['type']]?: BaseMessage<T>;\r\n    }\r\n\r\n    private _attachInfo: {\r\n        col: number;\r\n        row: number;\r\n        instance: BaseMessage<T>;\r\n    } | null = null\r\n\r\n    constructor(grid: ListGridAPI<T>, getMessage: (col: number, row: number) => Message) {\r\n    \tthis._grid = grid\r\n    \tthis._messageInstances = {}\r\n    \tthis._bindGridEvent(grid, getMessage)\r\n    }\r\n\r\n    dispose(): void {\r\n    \tconst messageInstances = this._messageInstances\r\n    \tfor (const k in messageInstances) {\r\n    \t\tmessageInstances[k as MessageObject['type']]?.dispose()\r\n    \t}\r\n    \tdelete this._messageInstances\r\n    \tdelete this._attachInfo\r\n    }\r\n\r\n    drawCellMessage(message: Message, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void {\r\n    \tif (!hasMessage(message)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst instance = this._getMessageInstanceOfMessage(message)\r\n    \tinstance.drawCellMessage(normalizeMessage(message), context, style, helper, grid, info)\r\n    }\r\n\r\n    _attach(col: number, row: number, message: Message): void {\r\n    \tconst info = this._attachInfo\r\n    \tconst instance = this._getMessageInstanceOfMessage(message)\r\n    \tif (info && info.instance !== instance) {\r\n    \t\tinfo.instance.detachMessageElement()\r\n    \t}\r\n    \tinstance.attachMessageElement(col, row, normalizeMessage(message))\r\n    \tthis._attachInfo = { col, row, instance }\r\n    }\r\n\r\n    _move(col: number, row: number): void {\r\n    \tconst info = this._attachInfo\r\n    \tif (!info || info.col !== col || info.row !== row) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst { instance } = info\r\n    \tinstance.moveMessageElement(col, row)\r\n    }\r\n\r\n    _detach(): void {\r\n    \tconst info = this._attachInfo\r\n    \tif (!info) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst { instance } = info\r\n    \tinstance.detachMessageElement()\r\n    \tthis._attachInfo = null\r\n    }\r\n\r\n    _bindGridEvent(grid: ListGridAPI<T>, getMessage: (col: number, row: number) => Message): void {\r\n    \tconst onSelectMessage = (sel: { col: number; row: number }): void => {\r\n    \t\tconst setMessageData = (msg: Message) => {\r\n    \t\t\tif (!hasMessage(msg)) {\r\n    \t\t\t\tthis._detach()\r\n    \t\t\t} else {\r\n    \t\t\t\tthis._attach(sel.col, sel.row, msg)\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\tconst message = getMessage(sel.col, sel.row)\r\n    \t\tif (isPromise(message)) {\r\n    \t\t\tthis._detach()\r\n    \t\t\tmessage.then((msg) => {\r\n    \t\t\t\tconst newSel = grid.selection.select\r\n    \t\t\t\tif (newSel.col !== sel.col || newSel.row !== sel.row) {\r\n    \t\t\t\t\treturn\r\n    \t\t\t\t}\r\n    \t\t\t\tsetMessageData(msg)\r\n    \t\t\t})\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tsetMessageData(message)\r\n    \t}\r\n    \tgrid.listen(LG_EVENT_TYPE.SELECTED_CELL, (e) => {\r\n    \t\tif (!e.selected) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tif (e.before.col === e.col && e.before.row === e.row) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tonSelectMessage(e)\r\n    \t})\r\n    \tgrid.listen(LG_EVENT_TYPE.SCROLL, () => {\r\n    \t\tconst sel = grid.selection.select\r\n    \t\tthis._move(sel.col, sel.row)\r\n    \t})\r\n    \tgrid.listen(LG_EVENT_TYPE.CHANGED_VALUE, (e) => {\r\n    \t\tconst sel = grid.selection.select\r\n    \t\tif (sel.col !== e.col || sel.row !== e.row) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tonSelectMessage(e)\r\n    \t})\r\n    \tgrid.listen(LG_EVENT_TYPE.FOCUS_GRID, (_e) => {\r\n    \t\tconst sel = grid.selection.select\r\n    \t\tonSelectMessage(sel)\r\n    \t})\r\n    \tgrid.listen(LG_EVENT_TYPE.BLUR_GRID, (_e) => {\r\n    \t\tthis._detach()\r\n    \t})\r\n    }\r\n\r\n    _getMessageInstanceOfMessage(message: Message): BaseMessage<T> {\r\n    \tconst messageInstances = this._messageInstances\r\n    \tconst { type } = normalizeMessage(message)\r\n    \treturn messageInstances[type] || (messageInstances[type] = MESSAGE_INSTANCE_FACTORY[type](this._grid))\r\n    }\r\n}\r\n","import * as messageUtils from './messageUtils'\r\nimport type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, MessageObject } from '../../ts-types'\r\nimport { BaseMessage } from './BaseMessage'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { WarningMessageElement } from './internal/WarningMessageElement'\r\nimport { cellInRange } from '../../internal/utils'\r\n\r\nconst DEEP_ORANGE_A100 = '#ff9e80'\r\n\r\nexport class WarningMessage<T> extends BaseMessage<T> {\r\n\tcreateMessageElementInternal(): WarningMessageElement {\r\n\t\treturn new WarningMessageElement()\r\n\t}\r\n\r\n\tdrawCellMessageInternal(_message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, _info: DrawCellInfo<T>): void {\r\n\t\tconst { bgColor } = style\r\n\t\tconst { select } = context.getSelection()\r\n\t\tif (!cellInRange(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {\r\n\t\t\thelper.drawBorderWithClip(context, (ctx: CanvasRenderingContext2D): void => {\r\n\t\t\t\tmessageUtils.drawExclamationMarkBox(\r\n\t\t\t\t\t\tcontext,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbgColor: helper.getColor(helper.theme.messages.warnBgColor, context.col, context.row, ctx) || DEEP_ORANGE_A100,\r\n\t\t\t\t\t\t\tcolor: bgColor\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\thelper\r\n\t\t\t\t)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n","import { MessageElement } from './MessageElement'\r\n\r\nconst CLASSNAME = 'cheetah-grid__error-message-element'\r\nconst MESSAGE_CLASSNAME = `${ CLASSNAME }__message`\r\nimport './ErrorMessageElement.css'\r\n\r\nexport class ErrorMessageElement extends MessageElement {\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t\t// require('@/columns/message/internal/ErrorMessageElement.css')\r\n\t\tthis._rootElement.classList.add(CLASSNAME)\r\n\t\tthis._messageElement.classList.add(MESSAGE_CLASSNAME)\r\n\t}\r\n}\r\n","import type {ListGridAPI, MessageObject} from '../../../ts-types';\r\nimport {EventHandler} from '../../../internal/EventHandler';\r\nimport {createElement} from '../../../internal/dom';\r\n\r\nconst CLASSNAME = 'cheetah-grid__message-element';\r\nconst MESSAGE_CLASSNAME = `${CLASSNAME}__message`;\r\nconst HIDDEN_CLASSNAME = `${CLASSNAME}--hidden`;\r\nconst SHOWN_CLASSNAME = `${CLASSNAME}--shown`;\r\nimport './MessageElement.css';\r\nfunction createMessageDomElement(): HTMLElement {\r\n\t// require(\"@/columns/message/internal/MessageElement.css\");\r\n\tconst rootElement = createElement('div', {\r\n\t\tclassList: [CLASSNAME, HIDDEN_CLASSNAME]\r\n\t});\r\n\tconst messageElement = createElement('span', {\r\n\t\tclassList: [MESSAGE_CLASSNAME]\r\n\t});\r\n\trootElement.appendChild(messageElement);\r\n\treturn rootElement;\r\n}\r\n\r\nexport class MessageElement {\r\n  private _handler: EventHandler;\r\n\r\n  protected _rootElement: HTMLElement;\r\n\r\n  protected _messageElement: HTMLElement;\r\n\r\n  constructor() {\r\n  \tthis._handler = new EventHandler();\r\n  \tconst rootElement = (this._rootElement = createMessageDomElement());\r\n  \tthis._messageElement = rootElement.querySelector(`.${MESSAGE_CLASSNAME}`) as HTMLElement;\r\n  }\r\n\r\n  dispose(): void {\r\n  \tthis.detach();\r\n  \tthis._handler.dispose();\r\n  \tdelete this._rootElement;\r\n  \tdelete this._messageElement;\r\n  }\r\n\r\n  attach<T>(grid: ListGridAPI<T>, col: number, row: number, message: MessageObject): void {\r\n  \tconst rootElement = this._rootElement;\r\n  \tconst messageElement = this._messageElement;\r\n\r\n  \trootElement.classList.remove(SHOWN_CLASSNAME);\r\n  \trootElement.classList.add(HIDDEN_CLASSNAME);\r\n\r\n  \tif (this._attachCell(grid, col, row)) {\r\n  \t\trootElement.classList.add(SHOWN_CLASSNAME);\r\n  \t\trootElement.classList.remove(HIDDEN_CLASSNAME);\r\n\r\n  \t\tmessageElement.textContent = message.message;\r\n  \t} else {\r\n  \t\tthis._detach();\r\n  \t}\r\n  }\r\n\r\n  move<T>(grid: ListGridAPI<T>, col: number, row: number): void {\r\n  \tconst rootElement = this._rootElement;\r\n  \tif (this._attachCell(grid, col, row)) {\r\n  \t\trootElement.classList.add(SHOWN_CLASSNAME);\r\n  \t\trootElement.classList.remove(HIDDEN_CLASSNAME);\r\n  \t} else {\r\n  \t\tthis._detach();\r\n  \t}\r\n  }\r\n\r\n  detach(): void {\r\n  \tthis._detach();\r\n  }\r\n\r\n  _detach(): void {\r\n  \tconst rootElement = this._rootElement;\r\n  \tif (rootElement.parentElement) {\r\n  \t\trootElement.parentElement.removeChild(rootElement);\r\n  \t\trootElement.classList.remove(SHOWN_CLASSNAME);\r\n  \t\trootElement.classList.add(HIDDEN_CLASSNAME);\r\n  \t}\r\n  }\r\n\r\n  _attachCell<T>(grid: ListGridAPI<T>, col: number, row: number): boolean {\r\n  \tconst rootElement = this._rootElement;\r\n  \tconst {element, rect} = grid.getAttachCellsArea(grid.getCellRange(col, row));\r\n\r\n  \tconst {bottom: top, left, width} = rect;\r\n  \tconst {frozenRowCount, frozenColCount} = grid;\r\n  \tif (row >= frozenRowCount && frozenRowCount > 0) {\r\n  \t\tconst {rect: frozenRect} = grid.getAttachCellsArea(grid.getCellRange(col, frozenRowCount - 1));\r\n  \t\tif (top < frozenRect.bottom) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t} else {\r\n  \t\tif (top < 0) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t}\r\n  \tif (col >= frozenColCount && frozenColCount > 0) {\r\n  \t\tconst {rect: frozenRect} = grid.getAttachCellsArea(grid.getCellRange(frozenColCount - 1, row));\r\n  \t\tif (left < frozenRect.right) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t} else {\r\n  \t\tif (left < 0) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t}\r\n  \tconst {offsetHeight, offsetWidth} = element;\r\n  \tif (offsetHeight < top) {\r\n  \t\treturn false; //\r\n  \t}\r\n  \tif (offsetWidth < left) {\r\n  \t\treturn false; //\r\n  \t}\r\n\r\n  \trootElement.style.top = `${top.toFixed()}px`;\r\n  \trootElement.style.left = `${left.toFixed()}px`;\r\n  \trootElement.style.width = `${width.toFixed()}px`;\r\n  \tif (rootElement.parentElement !== element) {\r\n  \t\telement.appendChild(rootElement);\r\n  \t}\r\n  \treturn true;\r\n  }\r\n}\r\n","import { MessageElement } from './MessageElement'\r\n\r\nconst CLASSNAME = 'cheetah-grid__warning-message-element'\r\nconst MESSAGE_CLASSNAME = `${ CLASSNAME }__message`\r\nimport './WarningMessageElement.css'\r\n\r\nexport class WarningMessageElement extends MessageElement {\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t\t// require(\"@/columns/message/internal/WarningMessageElement.css\");\r\n\t\tthis._rootElement.classList.add(CLASSNAME)\r\n\t\tthis._messageElement.classList.add(MESSAGE_CLASSNAME)\r\n\t}\r\n}\r\n","import type { CellContext, ColorDef, GridCanvasHelperAPI } from '../../ts-types'\r\nimport { Rect } from '../../internal/Rect'\r\n\r\nexport function drawExclamationMarkBox(\r\n\t\tcontext: CellContext,\r\n\t\tstyle: {\r\n        bgColor: ColorDef;\r\n        color?: ColorDef;\r\n    },\r\n\t\thelper: GridCanvasHelperAPI\r\n): void {\r\n\tconst { bgColor, color } = style\r\n\tconst ctx = context.getContext()\r\n\tconst rect = context.getRect()\r\n\t// draw box\r\n\tctx.fillStyle = bgColor\r\n\tconst boxRect = (rect as Rect).copy()\r\n\tboxRect.left = boxRect.right - 24\r\n\tctx.fillRect(boxRect.left, boxRect.top, boxRect.width, boxRect.height - 1)\r\n\r\n\t// draw exclamation mark\r\n\tconst fillColor = color\r\n\tconst height = 20\r\n\tconst width = height / 5\r\n\tconst left = boxRect.left + (boxRect.width - width) / 2\r\n\tconst top = boxRect.top + (boxRect.height - height) / 2\r\n\thelper.fillRectWithState(new Rect(left, top, width, (height / 5) * 3), context, { fillColor })\r\n\thelper.fillRectWithState(new Rect(left, top + (height / 5) * 4, width, height / 5), context, { fillColor })\r\n}\r\n\r\nexport function drawInformationMarkBox(\r\n\t\tcontext: CellContext,\r\n\t\tstyle: {\r\n        bgColor: ColorDef;\r\n        color?: ColorDef;\r\n    },\r\n\t\thelper: GridCanvasHelperAPI\r\n): void {\r\n\tconst { bgColor, color } = style\r\n\tconst ctx = context.getContext()\r\n\tconst rect = context.getRect()\r\n\t// draw box\r\n\tctx.fillStyle = bgColor\r\n\tconst boxRect = (rect as Rect).copy()\r\n\tboxRect.left = boxRect.right - 24\r\n\tctx.fillRect(boxRect.left, boxRect.top, boxRect.width, boxRect.height - 1)\r\n\r\n\t// draw i mark\r\n\tconst fillColor = color\r\n\tconst height = 20\r\n\tconst width = height / 5\r\n\tconst left = boxRect.left + (boxRect.width - width) / 2\r\n\tconst top = boxRect.top + (boxRect.height - height) / 2\r\n\thelper.fillRectWithState(new Rect(left, top, width, height / 5), context, {\r\n\t\tfillColor\r\n\t})\r\n\thelper.fillRectWithState(new Rect(left, top + (height / 5) * 2, width, (height / 5) * 3), context, { fillColor })\r\n}\r\n","import type {\r\n\tBaseStyleOption,\r\n\tButtonStyleOption,\r\n\tCheckStyleOption,\r\n\tColumnStyleOption,\r\n\tIconStyleOption,\r\n\tImageStyleOption,\r\n\tMenuStyleOption,\r\n\tMultilineTextStyleOption,\r\n\tNumberStyleOption,\r\n\tPercentCompleteBarStyleOption,\r\n\tStyleOption\r\n} from '../ts-types'\r\nimport { BaseStyle } from './style/BaseStyle'\r\nimport { ButtonStyle } from './style/ButtonStyle'\r\nimport { CheckStyle } from './style/CheckStyle'\r\nimport { IconStyle } from './style/IconStyle'\r\nimport { ImageStyle } from './style/ImageStyle'\r\nimport { MenuStyle } from './style/MenuStyle'\r\nimport { MultilineTextStyle } from './style/MultilineTextStyle'\r\nimport { NumberStyle } from './style/NumberStyle'\r\nimport { PercentCompleteBarStyle } from './style/PercentCompleteBarStyle'\r\nimport { RadioStyle } from './style/RadioStyle'\r\nimport { Style } from './style/Style'\r\n\r\nconst { EVENT_TYPE } = BaseStyle\r\nexport {\r\n\tEVENT_TYPE,\r\n\tBaseStyle,\r\n\tStyle,\r\n\tNumberStyle,\r\n\tCheckStyle,\r\n\tRadioStyle,\r\n\tButtonStyle,\r\n\tImageStyle,\r\n\tIconStyle,\r\n\tPercentCompleteBarStyle,\r\n\tMultilineTextStyle,\r\n\tMenuStyle,\r\n\t// types\r\n\tBaseStyleOption,\r\n\tButtonStyleOption,\r\n\tCheckStyleOption,\r\n\tIconStyleOption,\r\n\tImageStyleOption,\r\n\tMenuStyleOption,\r\n\tMultilineTextStyleOption,\r\n\tNumberStyleOption,\r\n\tPercentCompleteBarStyleOption,\r\n\tStyleOption\r\n}\r\n\r\nexport function of(\r\n\t\tcolumnStyle: ColumnStyleOption | null | undefined,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\trecord: any,\r\n\t\tStyleClassDef: typeof BaseStyle = Style\r\n): BaseStyle {\r\n\tif (columnStyle) {\r\n\t\tif (columnStyle instanceof BaseStyle) {\r\n\t\t\treturn columnStyle\r\n\t\t} else if (typeof columnStyle === 'function') {\r\n\t\t\treturn of(columnStyle(record), record, StyleClassDef)\r\n\t\t} else if (record && (columnStyle as symbol) in record) {\r\n\t\t\treturn of(record[columnStyle as string], record, StyleClassDef)\r\n\t\t}\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\treturn new StyleClassDef(columnStyle as any)\r\n\t} else {\r\n\t\treturn StyleClassDef.DEFAULT\r\n\t}\r\n}\r\n","import type { BaseStyleOption, ColorDef, ColumnStyle } from '../../ts-types'\r\nimport { EventTarget } from '../../core/EventTarget'\r\n\r\nconst STYLE_EVENT_TYPE = {\r\n\tCHANGE_STYLE: 'change_style' as const\r\n}\r\n\r\nlet defaultStyle: BaseStyle\r\n\r\nexport class BaseStyle extends EventTarget implements ColumnStyle {\r\n    private _bgColor?: ColorDef\r\n\r\n    static get EVENT_TYPE(): { CHANGE_STYLE: 'change_style' } {\r\n    \treturn STYLE_EVENT_TYPE\r\n    }\r\n\r\n    static get DEFAULT(): BaseStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new BaseStyle())\r\n    }\r\n\r\n    constructor({ bgColor }: BaseStyleOption = {}) {\r\n    \tsuper()\r\n    \tthis._bgColor = bgColor\r\n    }\r\n\r\n    get bgColor(): ColorDef | undefined {\r\n    \treturn this._bgColor\r\n    }\r\n\r\n    set bgColor(bgColor: ColorDef | undefined) {\r\n    \tthis._bgColor = bgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    doChangeStyle(): void {\r\n    \tthis.fireListeners(STYLE_EVENT_TYPE.CHANGE_STYLE)\r\n    }\r\n\r\n    clone(): BaseStyle {\r\n    \treturn new BaseStyle(this)\r\n    }\r\n}\r\n","import type { BranchGraphStyleOption, ColorDef } from '../../ts-types'\r\nimport { BaseStyle } from './BaseStyle'\r\n\r\nlet defaultStyle: BranchGraphStyle\r\n\r\nconst DEFAULT_BRANCH_COLORS = (_name: string, index: number): string => {\r\n\tswitch (index % 3) {\r\n\tcase 0:\r\n\t\treturn '#979797'\r\n\tcase 1:\r\n\t\treturn '#008fb5'\r\n\tcase 2:\r\n\t\treturn '#f1c109'\r\n\tdefault:\r\n\t}\r\n\treturn '#979797'\r\n}\r\n\r\nexport class BranchGraphStyle extends BaseStyle {\r\n    private _branchColors: ColorDef | ((name: string, index: number) => ColorDef)\r\n\r\n    private _margin: number\r\n\r\n    private _circleSize: number\r\n\r\n    private _branchLineWidth: number\r\n\r\n    private _mergeStyle: 'straight' | 'bezier'\r\n\r\n    static get DEFAULT(): BranchGraphStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new BranchGraphStyle())\r\n    }\r\n\r\n    constructor(style: BranchGraphStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._branchColors = style.branchColors || DEFAULT_BRANCH_COLORS\r\n    \tthis._margin = style.margin || 4\r\n    \tthis._circleSize = style.circleSize || 16\r\n    \tthis._branchLineWidth = style.branchLineWidth || 4\r\n    \tthis._mergeStyle = style.mergeStyle === 'straight' ? 'straight' : 'bezier'\r\n    }\r\n\r\n    get branchColors(): ColorDef | ((name: string, index: number) => ColorDef) {\r\n    \treturn this._branchColors\r\n    }\r\n\r\n    set branchColors(branchColors: ColorDef | ((name: string, index: number) => ColorDef)) {\r\n    \tthis._branchColors = branchColors\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get margin(): number {\r\n    \treturn this._margin\r\n    }\r\n\r\n    set margin(margin: number) {\r\n    \tthis._margin = margin\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get circleSize(): number {\r\n    \treturn this._circleSize\r\n    }\r\n\r\n    set circleSize(circleSize: number) {\r\n    \tthis._circleSize = circleSize\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get branchLineWidth(): number {\r\n    \treturn this._branchLineWidth\r\n    }\r\n\r\n    set branchLineWidth(branchLineWidth: number) {\r\n    \tthis._branchLineWidth = branchLineWidth\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get mergeStyle(): 'straight' | 'bezier' {\r\n    \treturn this._mergeStyle\r\n    }\r\n\r\n    set mergeStyle(mergeStyle: 'straight' | 'bezier') {\r\n    \tthis._mergeStyle = mergeStyle\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): BranchGraphStyle {\r\n    \treturn new BranchGraphStyle(this)\r\n    }\r\n}\r\n","import type { ButtonStyleOption, ColorDef } from '../../ts-types'\r\nimport { Style } from './Style'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: ButtonStyle\r\n\r\nexport class ButtonStyle extends Style {\r\n    private _buttonBgColor?: ColorDef\r\n\r\n    static get DEFAULT(): ButtonStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new ButtonStyle())\r\n    }\r\n\r\n    constructor(style: ButtonStyleOption = {}) {\r\n    \tsuper(defaults(style, { textAlign: 'center' }))\r\n    \tconst { buttonBgColor } = style\r\n    \tthis._buttonBgColor = buttonBgColor\r\n    }\r\n\r\n    get buttonBgColor(): ColorDef | undefined {\r\n    \treturn this._buttonBgColor\r\n    }\r\n\r\n    set buttonBgColor(buttonBgColor: ColorDef | undefined) {\r\n    \tthis._buttonBgColor = buttonBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): ButtonStyle {\r\n    \treturn new ButtonStyle(this)\r\n    }\r\n}\r\n","import type { CheckStyleOption, ColorDef } from '../../ts-types'\r\nimport { StdBaseStyle } from './StdBaseStyle'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: CheckStyle\r\n\r\nexport class CheckStyle extends StdBaseStyle {\r\n    private _uncheckBgColor?: ColorDef\r\n\r\n    private _checkBgColor?: ColorDef\r\n\r\n    private _borderColor?: ColorDef\r\n\r\n    static get DEFAULT(): CheckStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new CheckStyle())\r\n    }\r\n\r\n    constructor(style: CheckStyleOption = {}) {\r\n    \tsuper(defaults(style, { textAlign: 'center' }))\r\n    \tconst { uncheckBgColor, checkBgColor, borderColor } = style\r\n    \tthis._uncheckBgColor = uncheckBgColor\r\n    \tthis._checkBgColor = checkBgColor\r\n    \tthis._borderColor = borderColor\r\n    }\r\n\r\n    get uncheckBgColor(): ColorDef | undefined {\r\n    \treturn this._uncheckBgColor\r\n    }\r\n\r\n    set uncheckBgColor(uncheckBgColor: ColorDef | undefined) {\r\n    \tthis._uncheckBgColor = uncheckBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get checkBgColor(): ColorDef | undefined {\r\n    \treturn this._checkBgColor\r\n    }\r\n\r\n    set checkBgColor(checkBgColor: ColorDef | undefined) {\r\n    \tthis._checkBgColor = checkBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get borderColor(): ColorDef | undefined {\r\n    \treturn this._borderColor\r\n    }\r\n\r\n    set borderColor(borderColor: ColorDef | undefined) {\r\n    \tthis._borderColor = borderColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): CheckStyle {\r\n    \treturn new CheckStyle(this)\r\n    }\r\n}\r\n","import type { IconStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: IconStyle\r\n\r\nexport class IconStyle extends Style {\r\n\tstatic get DEFAULT(): IconStyle {\r\n\t\treturn defaultStyle ? defaultStyle : (defaultStyle = new IconStyle())\r\n\t}\r\n\r\n\tconstructor(style: IconStyleOption = {}) {\r\n\t\tsuper(defaults(style, { textAlign: 'center' }))\r\n\t}\r\n\r\n\tclone(): IconStyle {\r\n\t\treturn new IconStyle(this)\r\n\t}\r\n}\r\n","import type { ImageStyleOption } from '../../ts-types'\r\nimport { StdBaseStyle } from './StdBaseStyle'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: ImageStyle\r\n\r\nexport class ImageStyle extends StdBaseStyle {\r\n    private _imageSizing?: 'keep-aspect-ratio'\r\n\r\n    private _margin: number\r\n\r\n    static get DEFAULT(): ImageStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new ImageStyle())\r\n    }\r\n\r\n    constructor(style: ImageStyleOption = {}) {\r\n    \tsuper(defaults(style, { textAlign: 'center' }))\r\n    \tthis._imageSizing = style.imageSizing\r\n    \tthis._margin = style.margin || 4\r\n    }\r\n\r\n    get imageSizing(): 'keep-aspect-ratio' | undefined {\r\n    \treturn this._imageSizing\r\n    }\r\n\r\n    set imageSizing(imageSizing: 'keep-aspect-ratio' | undefined) {\r\n    \tthis._imageSizing = imageSizing\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get margin(): number {\r\n    \treturn this._margin\r\n    }\r\n\r\n    set margin(margin: number) {\r\n    \tthis._margin = margin\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): ImageStyle {\r\n    \treturn new ImageStyle(this)\r\n    }\r\n}\r\n","import type { MenuStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\n\r\nlet defaultStyle: MenuStyle\r\n\r\nexport class MenuStyle extends Style {\r\n    private _appearance?: 'menulist-button' | 'none'\r\n\r\n    static get DEFAULT(): MenuStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new MenuStyle())\r\n    }\r\n\r\n    constructor(style: MenuStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tconst { appearance } = style\r\n    \tthis._appearance = appearance\r\n    }\r\n\r\n    get appearance(): 'menulist-button' | 'none' | undefined {\r\n    \treturn this._appearance || 'menulist-button'\r\n    }\r\n\r\n    set appearance(appearance: 'menulist-button' | 'none' | undefined) {\r\n    \tthis._appearance = appearance\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): MenuStyle {\r\n    \treturn new MenuStyle(this)\r\n    }\r\n}\r\n","import type { LineClamp, MultilineTextStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: MultilineTextStyle\r\n\r\nexport class MultilineTextStyle extends Style {\r\n    private _lineHeight: string | number\r\n\r\n    private _autoWrapText: boolean\r\n\r\n    private _lineClamp?: LineClamp\r\n\r\n    static get DEFAULT(): MultilineTextStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new MultilineTextStyle())\r\n    }\r\n\r\n    constructor(style: MultilineTextStyleOption = {}) {\r\n    \tsuper(defaults(style, { textBaseline: 'top' }))\r\n    \tthis._lineHeight = style.lineHeight || '1em'\r\n    \tthis._autoWrapText = style.autoWrapText || false\r\n    \tthis._lineClamp = style.lineClamp\r\n    }\r\n\r\n    clone(): MultilineTextStyle {\r\n    \treturn new MultilineTextStyle(this)\r\n    }\r\n\r\n    get lineHeight(): string | number {\r\n    \treturn this._lineHeight\r\n    }\r\n\r\n    set lineHeight(lineHeight: string | number) {\r\n    \tthis._lineHeight = lineHeight\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get lineClamp(): LineClamp | undefined {\r\n    \treturn this._lineClamp\r\n    }\r\n\r\n    set lineClamp(lineClamp: LineClamp | undefined) {\r\n    \tthis._lineClamp = lineClamp\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get autoWrapText(): boolean {\r\n    \treturn this._autoWrapText\r\n    }\r\n\r\n    set autoWrapText(autoWrapText: boolean) {\r\n    \tthis._autoWrapText = autoWrapText\r\n    \tthis.doChangeStyle()\r\n    }\r\n}\r\n","import type { NumberStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: NumberStyle\r\n\r\nexport class NumberStyle extends Style {\r\n\tstatic get DEFAULT(): NumberStyle {\r\n\t\treturn defaultStyle ? defaultStyle : (defaultStyle = new NumberStyle())\r\n\t}\r\n\r\n\tconstructor(style: NumberStyleOption = {}) {\r\n\t\tsuper(defaults(style, { textAlign: 'right' }))\r\n\t}\r\n\r\n\tclone(): NumberStyle {\r\n\t\treturn new NumberStyle(this)\r\n\t}\r\n}\r\n","import type { ColorDef, PercentCompleteBarStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\n\r\nlet defaultStyle: PercentCompleteBarStyle\r\nconst DEFAULT_BAR_COLOR = (num: number): string => {\r\n\tif (num > 80) {\r\n\t\treturn '#20a8d8'\r\n\t}\r\n\tif (num > 50) {\r\n\t\treturn '#4dbd74'\r\n\t}\r\n\tif (num > 20) {\r\n\t\treturn '#ffc107'\r\n\t}\r\n\treturn '#f86c6b'\r\n}\r\n\r\nexport class PercentCompleteBarStyle extends Style {\r\n    private _barColor: ColorDef | ((num: number) => ColorDef)\r\n\r\n    private _barBgColor: ColorDef\r\n\r\n    private _barHeight: number\r\n\r\n    static get DEFAULT(): PercentCompleteBarStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new PercentCompleteBarStyle())\r\n    }\r\n\r\n    constructor(style: PercentCompleteBarStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._barColor = style.barColor || DEFAULT_BAR_COLOR\r\n    \tthis._barBgColor = style.barBgColor || '#f0f3f5'\r\n    \tthis._barHeight = style.barHeight || 3\r\n    }\r\n\r\n    get barColor(): ColorDef | ((num: number) => ColorDef) {\r\n    \treturn this._barColor\r\n    }\r\n\r\n    set barColor(barColor: ColorDef | ((num: number) => ColorDef)) {\r\n    \tthis._barColor = barColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get barBgColor(): ColorDef {\r\n    \treturn this._barBgColor\r\n    }\r\n\r\n    set barBgColor(barBgColor: ColorDef) {\r\n    \tthis._barBgColor = barBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get barHeight(): number {\r\n    \treturn this._barHeight\r\n    }\r\n\r\n    set barHeight(barHeight: number) {\r\n    \tthis._barHeight = barHeight\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): PercentCompleteBarStyle {\r\n    \treturn new PercentCompleteBarStyle(this)\r\n    }\r\n}\r\n","import type { ColorDef, RadioStyleOption } from '../../ts-types'\r\nimport { StdBaseStyle } from './StdBaseStyle'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: RadioStyle\r\n\r\nexport class RadioStyle extends StdBaseStyle {\r\n    private _checkColor?: ColorDef\r\n\r\n    private _uncheckBorderColor?: ColorDef\r\n\r\n    private _checkBorderColor?: ColorDef\r\n\r\n    private _uncheckBgColor?: ColorDef\r\n\r\n    private _checkBgColor?: ColorDef\r\n\r\n    static get DEFAULT(): RadioStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new RadioStyle())\r\n    }\r\n\r\n    constructor(style: RadioStyleOption = {}) {\r\n    \tsuper(defaults(style, { textAlign: 'center' }))\r\n    \tconst { checkColor, uncheckBorderColor, checkBorderColor, uncheckBgColor, checkBgColor } = style\r\n    \tthis._checkColor = checkColor\r\n    \tthis._uncheckBorderColor = uncheckBorderColor\r\n    \tthis._checkBorderColor = checkBorderColor\r\n    \tthis._uncheckBgColor = uncheckBgColor\r\n    \tthis._checkBgColor = checkBgColor\r\n    }\r\n\r\n    get checkColor(): ColorDef | undefined {\r\n    \treturn this._checkColor\r\n    }\r\n\r\n    set checkColor(checkColor: ColorDef | undefined) {\r\n    \tthis._checkColor = checkColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get uncheckBorderColor(): ColorDef | undefined {\r\n    \treturn this._uncheckBorderColor\r\n    }\r\n\r\n    set uncheckBorderColor(uncheckBorderColor: ColorDef | undefined) {\r\n    \tthis._uncheckBorderColor = uncheckBorderColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get checkBorderColor(): ColorDef | undefined {\r\n    \treturn this._checkBorderColor\r\n    }\r\n\r\n    set checkBorderColor(checkBorderColor: ColorDef | undefined) {\r\n    \tthis._checkBorderColor = checkBorderColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get uncheckBgColor(): ColorDef | undefined {\r\n    \treturn this._uncheckBgColor\r\n    }\r\n\r\n    set uncheckBgColor(uncheckBgColor: ColorDef | undefined) {\r\n    \tthis._uncheckBgColor = uncheckBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get checkBgColor(): ColorDef | undefined {\r\n    \treturn this._checkBgColor\r\n    }\r\n\r\n    set checkBgColor(checkBgColor: ColorDef | undefined) {\r\n    \tthis._checkBgColor = checkBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): RadioStyle {\r\n    \treturn new RadioStyle(this)\r\n    }\r\n}\r\n","import { BaseStyle } from './BaseStyle'\r\nimport type { StdBaseStyleOption } from '../../ts-types'\r\n\r\nlet defaultStyle: StdBaseStyle\r\n\r\nexport class StdBaseStyle extends BaseStyle {\r\n    private _textAlign: CanvasTextAlign\r\n\r\n    private _textBaseline: CanvasTextBaseline\r\n\r\n    static get DEFAULT(): StdBaseStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new StdBaseStyle())\r\n    }\r\n\r\n    constructor(style: StdBaseStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._textAlign = style.textAlign || 'left'\r\n    \tthis._textBaseline = style.textBaseline || 'middle'\r\n    }\r\n\r\n    get textAlign(): CanvasTextAlign {\r\n    \treturn this._textAlign\r\n    }\r\n\r\n    set textAlign(textAlign: CanvasTextAlign) {\r\n    \tthis._textAlign = textAlign\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get textBaseline(): CanvasTextBaseline {\r\n    \treturn this._textBaseline\r\n    }\r\n\r\n    set textBaseline(textBaseline: CanvasTextBaseline) {\r\n    \tthis._textBaseline = textBaseline\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): StdBaseStyle {\r\n    \treturn new StdBaseStyle(this)\r\n    }\r\n}\r\n","import type { ColorDef, StyleOption, TextOverflow } from '../../ts-types'\r\nimport { StdBaseStyle } from './StdBaseStyle'\r\n\r\nlet defaultStyle: Style\r\n\r\nexport class Style extends StdBaseStyle {\r\n    private _color?: ColorDef\r\n\r\n    private _font?: string\r\n\r\n    private _padding: number | string | (number | string)[] | undefined\r\n\r\n    private _textOverflow: TextOverflow\r\n\r\n    static get DEFAULT(): Style {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new Style())\r\n    }\r\n\r\n    constructor(style: StyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._color = style.color\r\n    \tthis._font = style.font\r\n    \tthis._padding = style.padding\r\n    \tthis._textOverflow = style.textOverflow || 'clip'\r\n    }\r\n\r\n    get color(): ColorDef | undefined {\r\n    \treturn this._color\r\n    }\r\n\r\n    set color(color: ColorDef | undefined) {\r\n    \tthis._color = color\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get font(): string | undefined {\r\n    \treturn this._font\r\n    }\r\n\r\n    set font(font: string | undefined) {\r\n    \tthis._font = font\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get padding(): number | string | (number | string)[] | undefined {\r\n    \treturn this._padding\r\n    }\r\n\r\n    set padding(padding: number | string | (number | string)[] | undefined) {\r\n    \tthis._padding = padding\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get textOverflow(): TextOverflow {\r\n    \treturn this._textOverflow\r\n    }\r\n\r\n    set textOverflow(textOverflow: TextOverflow) {\r\n    \tthis._textOverflow = textOverflow\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): Style {\r\n    \treturn new Style(this)\r\n    }\r\n}\r\n","import type {\r\n\tBaseColumnOption,\r\n\tBranchGraphColumnOption,\r\n\tButtonColumnOption,\r\n\tColumnTypeOption,\r\n\tIconColumnOption,\r\n\tMenuColumnOption,\r\n\tNumberColumnOption,\r\n\tPercentCompleteBarColumnOption\r\n} from '../ts-types'\r\nimport type { BaseColumn } from './type/BaseColumn'\r\nimport { BranchGraphColumn } from './type/BranchGraphColumn'\r\nimport { ButtonColumn } from './type/ButtonColumn'\r\nimport { CheckColumn } from './type/CheckColumn'\r\nimport { Column } from './type/Column'\r\nimport { IconColumn } from './type/IconColumn'\r\nimport { ImageColumn } from './type/ImageColumn'\r\nimport { MenuColumn } from './type/MenuColumn'\r\nimport { MultilineTextColumn } from './type/MultilineTextColumn'\r\nimport { NumberColumn } from './type/NumberColumn'\r\nimport { PercentCompleteBarColumn } from './type/PercentCompleteBarColumn'\r\nimport { RadioColumn } from './type/RadioColumn'\r\n\r\nconst TYPES = {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tDEFAULT: new Column<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tNUMBER: new NumberColumn<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tCHECK: new CheckColumn<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tRADIO: new RadioColumn<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tBUTTON: new ButtonColumn<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tIMAGE: new ImageColumn<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tMULTILINETEXT: new MultilineTextColumn<any>()\r\n}\r\n\r\n/**\r\n * column types\r\n * @namespace cheetahGrid.columns.type\r\n * @memberof cheetahGrid.columns\r\n */\r\nexport {\r\n\tColumn,\r\n\tNumberColumn,\r\n\tCheckColumn,\r\n\tRadioColumn,\r\n\tButtonColumn,\r\n\tImageColumn,\r\n\tPercentCompleteBarColumn,\r\n\tIconColumn,\r\n\tBranchGraphColumn,\r\n\tMenuColumn,\r\n\tMultilineTextColumn,\r\n\t// types\r\n\tBaseColumnOption,\r\n\tBranchGraphColumnOption,\r\n\tButtonColumnOption,\r\n\tIconColumnOption,\r\n\tMenuColumnOption,\r\n\tNumberColumnOption,\r\n\tPercentCompleteBarColumnOption\r\n}\r\n\r\nexport function of<T>(\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tcolumnType: ColumnTypeOption | BaseColumn<T, any> | null | undefined\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n): BaseColumn<T, any> {\r\n\tif (!columnType) {\r\n\t\treturn TYPES.DEFAULT\r\n\t} else if (typeof columnType === 'string') {\r\n\t\tconst key = columnType.toUpperCase() as keyof typeof TYPES\r\n\t\treturn TYPES[key] || of(null)\r\n\t} else {\r\n\t\treturn columnType\r\n\t}\r\n}\r\n","import * as styleContents from '../style'\r\nimport type { BaseColumnOption, CellAddress, CellContext, ColumnTypeAPI, EventListenerId, GridCanvasHelperAPI, LayoutObjectId, ListGridAPI, MaybePromise, Message } from '../../ts-types'\r\nimport type { ColumnFadeinState, DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { isPromise, obj } from '../../internal/utils'\r\nimport { BaseStyle } from '../style/BaseStyle'\r\nimport { animate } from '../../internal/animate'\r\nimport { getColumnFadeinStateId } from '../../internal/symbolManager'\r\n\r\nconst { setReadonly } = obj\r\nconst COLUMN_FADEIN_STATE_ID = getColumnFadeinStateId()\r\n\r\nfunction isFadeinWhenCallbackInPromise<T>(column: BaseColumn<T, unknown>, grid: ListGridAPI<T>): boolean {\r\n\tif (column.fadeinWhenCallbackInPromise != null) {\r\n\t\treturn column.fadeinWhenCallbackInPromise\r\n\t}\r\n\treturn !!grid.configure('fadeinWhenCallbackInPromise')\r\n}\r\n\r\nfunction getFadeinState<T>(grid: GridInternal<T>): ColumnFadeinState {\r\n\tlet state = grid[COLUMN_FADEIN_STATE_ID]\r\n\tif (!state) {\r\n\t\tstate = { cells: {} }\r\n\t\tsetReadonly(grid, COLUMN_FADEIN_STATE_ID, state)\r\n\t}\r\n\treturn state\r\n}\r\n\r\nfunction _generateFadeinPointAction<T>(grid: ListGridAPI<T>, col: number, row: number, context: CellContext, drawInternal: () => void, drawCellBase: () => void): (point: number) => void {\r\n\treturn (point: number): void => {\r\n\t\tconst state = getFadeinState(grid)\r\n\t\tconst stateKey = `${ row }:${ col }`\r\n\t\tif (point === 1) {\r\n\t\t\tdelete state.cells[stateKey]\r\n\t\t} else {\r\n\t\t\tstate.cells[stateKey] = {\r\n\t\t\t\topacity: point\r\n\t\t\t}\r\n\t\t}\r\n\t\tdrawCellBase()\r\n\r\n\t\tdrawInternal()\r\n\r\n\t\tconst cellState = state.cells[stateKey]\r\n\t\tif (cellState) {\r\n\t\t\t//\r\n\t\t\tconst ctx = context.getContext()\r\n\t\t\tctx.globalAlpha = 1 - cellState.opacity\r\n\t\t\ttry {\r\n\t\t\t\tdrawCellBase()\r\n\t\t\t} finally {\r\n\t\t\t\tctx.globalAlpha = 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst fadeinMgr = {\r\n\tanimate<T>(grid: ListGridAPI<T>, col: number, row: number, context: CellContext, drawInternal: () => void, drawCellBase: () => void): void {\r\n\t\t// fadein animation\r\n\t\tconst state = getFadeinState(grid)\r\n\r\n\t\tconst activeFadeins = [ _generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase) ]\r\n\t\tstate.activeFadeins = activeFadeins\r\n\r\n\t\tanimate(500, (point: number) => {\r\n\t\t\tactiveFadeins.forEach((f) => f(point))\r\n\t\t\tif (point === 1) {\r\n\t\t\t\tdelete state.activeFadeins\r\n\t\t\t}\r\n\t\t})\r\n\t},\r\n\tmargeAnimate<T>(grid: ListGridAPI<T>, col: number, row: number, context: CellContext, drawInternal: () => void, drawCellBase: () => void): void {\r\n\t\tconst state = getFadeinState(grid)\r\n\t\tif (state.activeFadeins) {\r\n\t\t\tstate.activeFadeins.push(_generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase))\r\n\t\t} else {\r\n\t\t\tdrawInternal()\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport abstract class BaseColumn<T, V> implements ColumnTypeAPI {\r\n    private _fadeinWhenCallbackInPromise?: boolean | null\r\n\r\n    constructor(option?: BaseColumnOption) {\r\n    \tthis.onDrawCell = this.onDrawCell.bind(this) //\r\n\r\n    \t//Promisecallback\r\n    \tthis._fadeinWhenCallbackInPromise = option?.fadeinWhenCallbackInPromise\r\n    }\r\n\r\n    get fadeinWhenCallbackInPromise(): boolean | undefined | null {\r\n    \treturn this._fadeinWhenCallbackInPromise\r\n    }\r\n\r\n    get StyleClass(): typeof BaseStyle {\r\n    \treturn BaseStyle\r\n    }\r\n\r\n    onDrawCell(cellValue: MaybePromise<unknown>, info: DrawCellInfo<T>, context: CellContext, grid: ListGridAPI<T>): void | Promise<void> {\r\n    \tconst { style, getRecord, drawCellBase } = info\r\n    \tconst helper = grid.getGridCanvasHelper()\r\n    \tdrawCellBase()\r\n\r\n    \tconst record = getRecord()\r\n    \tlet promise\r\n    \tif (isPromise(record)) {\r\n    \t\tpromise = record\r\n    \t} else if (isPromise(cellValue)) {\r\n    \t\tpromise = cellValue\r\n    \t} else {\r\n    \t\tconst msg = info.getMessage()\r\n    \t\tif (isPromise(msg)) {\r\n    \t\t\tpromise = msg\r\n    \t\t}\r\n    \t}\r\n    \t//\r\n    \tif (promise) {\r\n    \t\tconst start = Date.now()\r\n    \t\treturn Promise.all([ record, cellValue, promise.then(() => cellValue).then(() => info.getMessage()) ]).then(({ 0: record, 1: val, 2: message }) => {\r\n    \t\t\tconst currentContext = context.toCurrentContext()\r\n    \t\t\tconst drawRect = currentContext.getDrawRect()\r\n    \t\t\tif (!drawRect) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst time = Date.now() - start\r\n\r\n    \t\t\tconst drawInternal = (): void => {\r\n    \t\t\t\tconst currentContext = context.toCurrentContext()\r\n    \t\t\t\tconst drawRect = currentContext.getDrawRect()\r\n    \t\t\t\tif (!drawRect) {\r\n    \t\t\t\t\treturn\r\n    \t\t\t\t}\r\n\r\n    \t\t\t\tconst actStyle = styleContents.of(style, record, this.StyleClass)\r\n    \t\t\t\tthis.drawInternal(this.convertInternal(val), currentContext, actStyle, helper, grid, info)\r\n    \t\t\t\tthis.drawMessageInternal(message, currentContext, actStyle, helper, grid, info)\r\n    \t\t\t}\r\n\r\n    \t\t\tif (!isFadeinWhenCallbackInPromise(this, grid)) {\r\n    \t\t\t\tdrawInternal() //\r\n    \t\t\t} else {\r\n    \t\t\t\tconst { col, row } = context\r\n    \t\t\t\tif (time < 80) {\r\n    \t\t\t\t\t//80msPromiseCallback\r\n    \t\t\t\t\tfadeinMgr.margeAnimate(grid, col, row, context, drawInternal, drawCellBase)\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\t//\r\n    \t\t\t\t\tfadeinMgr.animate(grid, col, row, context, drawInternal, drawCellBase)\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t})\r\n    \t} else {\r\n    \t\tconst actStyle = styleContents.of(style, record, this.StyleClass)\r\n    \t\tthis.drawInternal(this.convertInternal(cellValue), context, actStyle, helper, grid, info)\r\n    \t\tthis.drawMessageInternal(info.getMessage(), context, actStyle, helper, grid, info)\r\n    \t\t//\r\n    \t\tconst { col, row } = context\r\n    \t\tconst stateKey = `${ col }:${ row }`\r\n    \t\tconst cellState = (grid as GridInternal<T>)[COLUMN_FADEIN_STATE_ID]?.cells[stateKey]\r\n    \t\tif (cellState) {\r\n    \t\t\tconst ctx = context.getContext()\r\n    \t\t\tctx.globalAlpha = 1 - cellState.opacity\r\n    \t\t\ttry {\r\n    \t\t\t\tdrawCellBase()\r\n    \t\t\t} finally {\r\n    \t\t\t\tctx.globalAlpha = 1\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\treturn undefined\r\n    \t}\r\n    }\r\n\r\n    abstract clone(): BaseColumn<T, V>;\r\n\r\n    convertInternal(value: unknown): V {\r\n    \treturn (value != null ? value : '') as V\r\n    }\r\n\r\n    abstract drawInternal(value: V, context: CellContext, style: BaseStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;\r\n\r\n    drawMessageInternal(message: Message, context: CellContext, style: BaseStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void {\r\n    \tinfo.messageHandler.drawCellMessage(message, context, style, helper, grid, info)\r\n    }\r\n\r\n    bindGridEvent(_grid: ListGridAPI<T>, _cellId: LayoutObjectId): EventListenerId[] {\r\n    \treturn []\r\n    }\r\n\r\n    getCopyCellValue(value: V, _grid: ListGridAPI<T>, _cell: CellAddress): string {\r\n    \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \treturn value as any\r\n    }\r\n}\r\n","import type {\r\n\tBranchGraphColumnOption,\r\n\tBranchGraphCommand,\r\n\tCellContext,\r\n\tColorDef,\r\n\tFieldDef,\r\n\tGridCanvasHelperAPI,\r\n\tListGridAPI,\r\n\tMaybePromise,\r\n\tMaybePromiseOrUndef\r\n} from '../../ts-types'\r\nimport type { DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { getOrApply, isPromise, obj } from '../../internal/utils'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport { BranchGraphStyle } from '../style/BranchGraphStyle'\r\nimport { getBranchGraphColumnStateId } from '../../internal/symbolManager'\r\n\r\nconst _ = getBranchGraphColumnStateId()\r\n\r\ntype Timelines = { timeline: BranchPoint[][]; branches: string[] };\r\n\r\nfunction getAllColumnData<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tfield: FieldDef<T>,\r\n\t\tcallback: (allData: BranchGraphCommand[]) => void\r\n): void {\r\n\tconst { dataSource } = grid\r\n\tconst allData: BranchGraphCommand[] = []\r\n\tlet promise\r\n\tfor (let index = 0; index < dataSource.length; index++) {\r\n\t\tconst data = dataSource.getField(\r\n\t\t\t\tindex,\r\n\t\t\t\tfield\r\n\t\t) as MaybePromiseOrUndef<BranchGraphCommand>\r\n\t\tif (isPromise(data)) {\r\n\t\t\tconst dataIndex = allData.length\r\n\t\t\tallData.push(undefined)\r\n\t\t\tif (!promise) {\r\n\t\t\t\tpromise = data.then((d) => {\r\n\t\t\t\t\tallData[dataIndex] = d\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tpromise = promise.then(() => data).then((d) => {\r\n\t\t\t\t\tallData[dataIndex] = d\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tallData.push(data)\r\n\t\t}\r\n\t}\r\n\r\n\tif (promise) {\r\n\t\tpromise.then(() => callback(allData))\r\n\t} else {\r\n\t\tcallback(allData)\r\n\t}\r\n}\r\n\r\nclass BranchLine {\r\n    readonly fromIndex?: number\r\n\r\n    toIndex?: number\r\n\r\n    readonly colorIndex: number\r\n\r\n    readonly point?: BranchPoint\r\n\r\n    constructor({\r\n    \tfromIndex,\r\n    \ttoIndex,\r\n    \tcolorIndex,\r\n    \tpoint\r\n    }: {\r\n        fromIndex?: number;\r\n        toIndex?: number;\r\n        colorIndex: number;\r\n        point?: BranchPoint;\r\n    }) {\r\n    \tthis.fromIndex = fromIndex\r\n    \tthis.toIndex = toIndex\r\n    \tthis.colorIndex = colorIndex\r\n    \tthis.point = point\r\n    }\r\n}\r\n\r\nclass BranchPoint {\r\n    readonly index: number\r\n\r\n    readonly commit: boolean\r\n\r\n    lines: BranchLine[]\r\n\r\n    readonly tag?: string\r\n\r\n    constructor({\r\n    \tindex,\r\n    \tcommit = false,\r\n    \tlines = [],\r\n    \ttag\r\n    }: {\r\n        index: number;\r\n        commit?: boolean;\r\n        lines?: BranchLine[];\r\n        tag?: string;\r\n    }) {\r\n    \tthis.index = index\r\n    \tthis.commit = commit\r\n    \tthis.lines = lines\r\n    \tthis.tag = tag\r\n    }\r\n\r\n    static mergeLines(lines: BranchLine[]): BranchLine[] {\r\n    \tconst result = lines.filter(\r\n    \t\t\t(l) => l.fromIndex != null && l.toIndex != null\r\n    \t)\r\n\r\n    \tconst froms = lines.filter((l) => l.fromIndex != null && l.toIndex == null)\r\n    \tconst tos = lines.filter((l) => l.fromIndex == null && l.toIndex != null)\r\n\r\n    \tfroms.forEach((f) => {\r\n    \t\tfor (let i = 0; i < tos.length; i++) {\r\n    \t\t\tconst t = tos[i]\r\n    \t\t\tif (t.point) {\r\n    \t\t\t\tcontinue\r\n    \t\t\t}\r\n    \t\t\tif (f.colorIndex === t.colorIndex) {\r\n    \t\t\t\tf.toIndex = t.toIndex\r\n    \t\t\t\ttos.splice(i, 1)\r\n    \t\t\t\tbreak\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\tresult.push(f)\r\n    \t})\r\n\r\n    \treturn result.concat(tos)\r\n    }\r\n\r\n    static merge(a: BranchPoint, b: BranchPoint): BranchPoint {\r\n    \tif (!a) {\r\n    \t\treturn b\r\n    \t}\r\n    \treturn new BranchPoint({\r\n    \t\tindex: a.index,\r\n    \t\tcommit: a.commit || b.commit,\r\n    \t\tlines: BranchPoint.mergeLines(a.lines.concat(b.lines)),\r\n    \t\ttag: a.tag || b.tag\r\n    \t})\r\n    }\r\n}\r\n\r\nfunction joinLine(timeline: BranchPoint[][], branchIndex: number): boolean {\r\n\tconst reverse = [ ...timeline ].reverse()\r\n\tfor (let i = 0; i < reverse.length; i++) {\r\n\t\tconst f = reverse[i][branchIndex]\r\n\t\tif (f) {\r\n\t\t\tf.lines = BranchPoint.mergeLines(\r\n\t\t\t\t\tf.lines.concat([\r\n\t\t\t\t\t\tnew BranchLine({\r\n\t\t\t\t\t\t\ttoIndex: branchIndex,\r\n\t\t\t\t\t\t\tcolorIndex: branchIndex\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t])\r\n\t\t\t)\r\n\r\n\t\t\tfor (let j = 0; j < i; j++) {\r\n\t\t\t\tconst tl = reverse[j]\r\n\t\t\t\ttl[branchIndex] = new BranchPoint({\r\n\t\t\t\t\tindex: branchIndex,\r\n\t\t\t\t\tlines: [\r\n\t\t\t\t\t\tnew BranchLine({\r\n\t\t\t\t\t\t\tfromIndex: branchIndex,\r\n\t\t\t\t\t\t\ttoIndex: branchIndex,\r\n\t\t\t\t\t\t\tcolorIndex: branchIndex\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunction branch(\r\n\t\t{ timeline, branches }: Timelines,\r\n\t\tfrom: string | null,\r\n\t\tto: string\r\n): BranchPoint | null {\r\n\tconst fromIndex = from != null ? branches.indexOf(from) : -1\r\n\tlet toIndex = branches.indexOf(to)\r\n\tif (toIndex < 0) {\r\n\t\ttoIndex = branches.length\r\n\t\tbranches.push(to)\r\n\t}\r\n\r\n\tfunction findBranchRootIndex(): number {\r\n\t\tfor (let index = timeline.length - 1; index >= 0; index--) {\r\n\t\t\tconst tl = timeline[index]\r\n\t\t\tconst from = tl[fromIndex]\r\n\t\t\tif (from && from.commit) {\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1\r\n\t}\r\n\r\n\tif (fromIndex < 0) {\r\n\t\treturn new BranchPoint({\r\n\t\t\tindex: toIndex\r\n\t\t})\r\n\t} else {\r\n\t\tconst fromTargetIndex = findBranchRootIndex()\r\n\t\tif (fromTargetIndex === -1) {\r\n\t\t\treturn null\r\n\t\t}\r\n\t\tconst branchTargetFromIndex = fromTargetIndex + 1\r\n\t\tconst branchPoint = new BranchPoint({\r\n\t\t\tindex: toIndex,\r\n\t\t\tlines: [\r\n\t\t\t\tnew BranchLine({\r\n\t\t\t\t\tfromIndex,\r\n\t\t\t\t\tcolorIndex: toIndex\r\n\t\t\t\t})\r\n\t\t\t]\r\n\t\t})\r\n\t\tlet point\r\n\t\tlet result = null\r\n\t\tif (branchTargetFromIndex < timeline.length) {\r\n\t\t\tconst targetLine = timeline[branchTargetFromIndex]\r\n\t\t\tpoint = targetLine[toIndex] = BranchPoint.merge(\r\n\t\t\t\t\ttargetLine[toIndex],\r\n\t\t\t\t\tbranchPoint\r\n\t\t\t)\r\n\t\t} else {\r\n\t\t\tpoint = branchPoint\r\n\t\t\tresult = branchPoint\r\n\t\t}\r\n\t\tconst from = timeline[fromTargetIndex][fromIndex]\r\n\t\tfrom.lines = BranchPoint.mergeLines(\r\n\t\t\t\tfrom.lines.concat([\r\n\t\t\t\t\tnew BranchLine({\r\n\t\t\t\t\t\ttoIndex,\r\n\t\t\t\t\t\tcolorIndex: toIndex,\r\n\t\t\t\t\t\tpoint\r\n\t\t\t\t\t})\r\n\t\t\t\t])\r\n\t\t)\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\nfunction commit(\r\n\t\t{ timeline, branches }: Timelines,\r\n\t\tname: string\r\n): BranchPoint | null {\r\n\tconst index = branches.indexOf(name)\r\n\tif (index < 0) {\r\n\t\treturn null\r\n\t}\r\n\tconst result = new BranchPoint({\r\n\t\tindex,\r\n\t\tcommit: true\r\n\t})\r\n\r\n\tif (joinLine(timeline, index)) {\r\n\t\tresult.lines = BranchPoint.mergeLines(\r\n\t\t\t\tresult.lines.concat([\r\n\t\t\t\t\tnew BranchLine({\r\n\t\t\t\t\t\tfromIndex: index,\r\n\t\t\t\t\t\tcolorIndex: index\r\n\t\t\t\t\t})\r\n\t\t\t\t])\r\n\t\t)\r\n\t}\r\n\treturn result\r\n}\r\n\r\nfunction commitTag(\r\n\t\t{ branches }: Timelines,\r\n\t\tname: string,\r\n\t\ttag: string\r\n): BranchPoint {\r\n\tlet index = branches.indexOf(name)\r\n\tif (index < 0) {\r\n\t\tindex = branches.length\r\n\t\tbranches.push(name)\r\n\t}\r\n\treturn new BranchPoint({\r\n\t\tindex,\r\n\t\ttag\r\n\t})\r\n}\r\n\r\nfunction commitMerge(\r\n\t\t{ timeline, branches }: Timelines,\r\n\t\tfrom: string,\r\n\t\tto: string\r\n): BranchPoint {\r\n\tconst fromIndex = branches.indexOf(from)\r\n\tconst toIndex = branches.indexOf(to)\r\n\tif (toIndex < 0 || fromIndex < 0) {\r\n\t\treturn new BranchPoint({\r\n\t\t\tindex: toIndex,\r\n\t\t\tcommit: true\r\n\t\t})\r\n\t}\r\n\tconst result = new BranchPoint({\r\n\t\tindex: toIndex,\r\n\t\tcommit: true,\r\n\t\tlines: [\r\n\t\t\tnew BranchLine({\r\n\t\t\t\tfromIndex,\r\n\t\t\t\tcolorIndex: fromIndex\r\n\t\t\t}),\r\n\t\t\tnew BranchLine({\r\n\t\t\t\tfromIndex: toIndex,\r\n\t\t\t\tcolorIndex: toIndex\r\n\t\t\t})\r\n\t\t]\r\n\t})\r\n\tconst froms = [ ...timeline ]\r\n\tconst fromTargetLine = froms.pop()\r\n\tif (fromTargetLine) {\r\n\t\tfromTargetLine[fromIndex] = BranchPoint.merge(\r\n\t\t\t\tfromTargetLine[fromIndex],\r\n\t\t\t\tnew BranchPoint({\r\n\t\t\t\t\tindex: toIndex,\r\n\t\t\t\t\tlines: [\r\n\t\t\t\t\t\tnew BranchLine({\r\n\t\t\t\t\t\t\ttoIndex,\r\n\t\t\t\t\t\t\tcolorIndex: fromIndex\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t})\r\n\t\t)\r\n\t}\r\n\r\n\tif (joinLine(froms, fromIndex) && fromTargetLine) {\r\n\t\tfromTargetLine[fromIndex].lines = BranchPoint.mergeLines(\r\n\t\t\t\tfromTargetLine[fromIndex].lines.concat([\r\n\t\t\t\t\tnew BranchLine({\r\n\t\t\t\t\t\tfromIndex,\r\n\t\t\t\t\t\tcolorIndex: fromIndex\r\n\t\t\t\t\t})\r\n\t\t\t\t])\r\n\t\t)\r\n\t}\r\n\tjoinLine(timeline, toIndex)\r\n\r\n\treturn result\r\n}\r\n\r\nfunction calcCommand(info: Timelines, command: BranchGraphCommand): void {\r\n\tconst { timeline } = info\r\n\tconst timelineData: BranchPoint[] = []\r\n\t// const last = timeline.length > 0 ? timeline[timeline.length - 1] : null;\r\n\tconst commands = Array.isArray(command) ? command : [ command ]\r\n\tcommands.forEach((cmd) => {\r\n\t\tif (!cmd) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tlet point\r\n\t\tif (cmd.command === 'branch') {\r\n\t\t\tconst from = obj.isObject(cmd.branch) ? cmd.branch.from : null\r\n\t\t\tconst to = obj.isObject(cmd.branch) ? cmd.branch.to : cmd.branch\r\n\t\t\tpoint = branch(info, from, to)\r\n\t\t} else if (cmd.command === 'commit') {\r\n\t\t\tconst { branch } = cmd\r\n\t\t\tpoint = commit(info, branch)\r\n\t\t} else if (cmd.command === 'merge') {\r\n\t\t\tconst { from, to } = cmd.branch\r\n\t\t\tpoint = commitMerge(info, from, to)\r\n\t\t} else if (cmd.command === 'tag') {\r\n\t\t\tconst { branch, tag } = cmd\r\n\t\t\tpoint = commitTag(info, branch, tag)\r\n\t\t}\r\n\t\tif (point && point.index > -1) {\r\n\t\t\ttimelineData[point.index] = BranchPoint.merge(\r\n\t\t\t\t\ttimelineData[point.index],\r\n\t\t\t\t\tpoint\r\n\t\t\t)\r\n\t\t}\r\n\t})\r\n\ttimeline.push(timelineData)\r\n}\r\n\r\nfunction calcBranchesInfo<T>(\r\n\t\tstart: 'top' | 'bottom',\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tfield: FieldDef<T>\r\n): Timelines {\r\n\tconst result = {\r\n\t\tbranches: [] as any[],\r\n\t\ttimeline: [] as any[]\r\n\t}\r\n\tgetAllColumnData(grid, field, (data) => {\r\n\t\tif (start !== 'top') {\r\n\t\t\tdata = [ ...data ].reverse()\r\n\t\t}\r\n\t\tdata.forEach((command) => {\r\n\t\t\tcalcCommand(result, command)\r\n\t\t})\r\n\t})\r\n\treturn result\r\n}\r\n\r\nfunction calcBranchXPoints(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tleft: number,\r\n\t\twidth: number,\r\n\t\tradius: number,\r\n\t\tbranches: string[],\r\n\t\ttimeline: BranchPoint[][]\r\n): number[] {\r\n\tlet w = Math.max(width / branches.length + 1, 5)\r\n\ttimeline.forEach((tl) => {\r\n\t\ttl.forEach((p, index) => {\r\n\t\t\tif (index <= 0) {\r\n\t\t\t\t// \r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (p.tag) {\r\n\t\t\t\tconst textWidth = ctx.measureText(p.tag).width\r\n\t\t\t\tif (w * index + radius * 2 + 4 + textWidth > width) {\r\n\t\t\t\t\tw = Math.max((width - radius * 2 - 4 - textWidth) / index, 5)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n\tconst result: number[] = []\r\n\tlet x = left\r\n\tbranches.forEach(() => {\r\n\t\tresult.push(Math.ceil(x + radius))\r\n\t\tx += w\r\n\t})\r\n\treturn result\r\n}\r\n\r\nfunction renderMerge<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\tupLineIndex: number | undefined,\r\n\t\tdownLineIndex: number | undefined,\r\n\t\tcolorIndex: number,\r\n\t\t{\r\n\t\t\tbranchXPoints,\r\n\t\t\t// margin,\r\n\t\t\tbranchColors,\r\n\t\t\tbranchLineWidth,\r\n\t\t\tmergeStyle\r\n\t\t}: {\r\n        branchXPoints: number[];\r\n        margin: number;\r\n        branchColors: ColorDef | ((name: string, index: number) => ColorDef);\r\n        branchLineWidth: number;\r\n        mergeStyle: 'straight' | 'bezier';\r\n    },\r\n\t\t{\r\n\t\t\t// width,\r\n\t\t\tcol,\r\n\t\t\trow,\r\n\t\t\tbranches\r\n\t\t}: {\r\n        width: number;\r\n        col: number;\r\n        row: number;\r\n        branches: string[];\r\n    }\r\n): void {\r\n\tif (upLineIndex != null || downLineIndex != null) {\r\n\t\tctx.strokeStyle = getOrApply(\r\n\t\t\t\tbranchColors,\r\n\t\t\t\tbranches[colorIndex],\r\n\t\t\t\tcolorIndex\r\n\t\t)\r\n\t\tctx.lineWidth = branchLineWidth\r\n\t\tctx.lineCap = 'round'\r\n\t\tctx.beginPath()\r\n\r\n\t\tif (upLineIndex != null) {\r\n\t\t\tconst upX = branchXPoints[upLineIndex]\r\n\t\t\tconst upRect = grid.getCellRelativeRect(col, row - 1)\r\n\t\t\tconst upY = upRect.top + upRect.height / 2\r\n\t\t\tctx.moveTo(upX, upY)\r\n\t\t\tif (mergeStyle === 'bezier') {\r\n\t\t\t\tctx.bezierCurveTo(upX, (y + upY) / 2, x, (y + upY) / 2, x, y)\r\n\t\t\t} else {\r\n\t\t\t\tctx.lineTo(x, y)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tctx.moveTo(x, y)\r\n\t\t}\r\n\r\n\t\tif (downLineIndex != null) {\r\n\t\t\tconst downX = branchXPoints[downLineIndex]\r\n\t\t\tconst downRect = grid.getCellRelativeRect(col, row + 1)\r\n\t\t\tconst downY = downRect.top + downRect.height / 2\r\n\t\t\tif (mergeStyle === 'bezier') {\r\n\t\t\t\tctx.bezierCurveTo(\r\n\t\t\t\t\t\tx,\r\n\t\t\t\t\t\t(y + downY) / 2,\r\n\t\t\t\t\t\tdownX,\r\n\t\t\t\t\t\t(y + downY) / 2,\r\n\t\t\t\t\t\tdownX,\r\n\t\t\t\t\t\tdownY\r\n\t\t\t\t)\r\n\t\t\t} else {\r\n\t\t\t\tctx.lineTo(downX, downY)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.stroke()\r\n\t}\r\n}\r\n\r\n/**\r\n * BranchGraphColumn\r\n *\r\n * Data commands\r\n * - mastar branch or orphan branch\r\n *\r\n * ```js\r\n * {\r\n * \tcommand: 'branch',\r\n * \tbranch: 'branch name A',\r\n * }\r\n * ```\r\n *\r\n * - commit\r\n *\r\n * ```js\r\n * {\r\n * \tcommand: 'commit',\r\n * \tbranch: 'branch name A'\r\n * }\r\n * ```\r\n *\r\n * - branch\r\n *\r\n * ```js\r\n * {\r\n * \tcommand: 'branch',\r\n * \tbranch: {\r\n * \t\tfrom: 'branch name A',\r\n * \t\tto: 'branch name B'\r\n * \t}\r\n * }\r\n * ```\r\n *\r\n * - merge\r\n *\r\n * ```js\r\n * {\r\n * \tcommand: 'merge',\r\n * \tbranch: {\r\n * \t\tfrom: 'branch name B',\r\n * \t\tto: 'branch name A'\r\n * \t}\r\n * }\r\n * ```\r\n *\r\n * - tag\r\n *\r\n * ```js\r\n * {\r\n * \tcommand: 'tag',\r\n * \tbranch: 'branch name A',\r\n * \ttag: 'tag name'\r\n * }\r\n * ```\r\n *\r\n * @memberof cheetahGrid.columns.type\r\n */\r\nexport class BranchGraphColumn<T> extends BaseColumn<T, unknown> {\r\n    private _start: 'top' | 'bottom'\r\n\r\n    private _cache: boolean\r\n\r\n    constructor(option: BranchGraphColumnOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._start = option.start || 'bottom'\r\n    \tthis._cache = option.cache != null ? option.cache : false\r\n    }\r\n\r\n    get StyleClass(): typeof BranchGraphStyle {\r\n    \treturn BranchGraphStyle\r\n    }\r\n\r\n    clearCache(grid: GridInternal<T>): void {\r\n    \tdelete grid[_]\r\n    }\r\n\r\n    onDrawCell(\r\n    \t\tcellValue: MaybePromise<unknown>,\r\n    \t\tinfo: DrawCellInfo<T>,\r\n    \t\tcontext: CellContext,\r\n    \t\tgrid: GridInternal<T>\r\n    ): void | Promise<void> {\r\n    \tif (this._cache) {\r\n    \t\tconst state = grid[_] || (grid[_] = new Map())\r\n    \t\tconst { col, row } = context\r\n    \t\tconst field = grid.getField(col, row) as FieldDef<T>\r\n    \t\tif (!state.has(field)) {\r\n    \t\t\tstate.set(field, calcBranchesInfo(this._start, grid, field))\r\n    \t\t}\r\n    \t}\r\n    \treturn super.onDrawCell(cellValue, info, context, grid)\r\n    }\r\n\r\n    clone(): BranchGraphColumn<T> {\r\n    \treturn new BranchGraphColumn(this)\r\n    }\r\n\r\n    drawInternal(\r\n    \t\t_value: unknown,\r\n    \t\tcontext: CellContext,\r\n    \t\tstyle: BranchGraphStyle,\r\n    \t\thelper: GridCanvasHelperAPI,\r\n    \t\tgrid: GridInternal<T>,\r\n    \t\t{ drawCellBase }: DrawCellInfo<T>\r\n    ): void {\r\n    \tconst { col, row } = context\r\n    \tconst field = grid.getField(col, row) as FieldDef<T>\r\n    \tconst { timeline, branches } =\r\n        (this._cache ? grid[_]?.get(field) : null) ??\r\n        calcBranchesInfo(this._start, grid, field)\r\n\r\n    \tconst {\r\n    \t\tupLineIndexKey,\r\n    \t\tdownLineIndexKey\r\n    \t}: {\r\n            upLineIndexKey: 'fromIndex' | 'toIndex';\r\n            downLineIndexKey: 'fromIndex' | 'toIndex';\r\n        } =\r\n            this._start !== 'top'\r\n            \t? { upLineIndexKey: 'toIndex', downLineIndexKey: 'fromIndex' }\r\n            \t: { upLineIndexKey: 'fromIndex', downLineIndexKey: 'toIndex' }\r\n    \tconst data =\r\n            this._start !== 'top'\r\n            \t? timeline[timeline.length - (row - grid.frozenRowCount) - 1]\r\n            \t: timeline[row - grid.frozenRowCount]\r\n\r\n    \tconst {\r\n    \t\tbranchColors,\r\n    \t\tbranchLineWidth,\r\n    \t\tcircleSize,\r\n    \t\tmergeStyle,\r\n    \t\tmargin,\r\n    \t\tbgColor\r\n    \t} = style\r\n    \tif (bgColor) {\r\n    \t\tdrawCellBase({\r\n    \t\t\tbgColor\r\n    \t\t})\r\n    \t}\r\n\r\n    \tconst rect = context.getRect()\r\n    \tconst radius = circleSize / 2\r\n    \tconst width = rect.width - margin * 2\r\n\r\n    \thelper.drawWithClip(context, (ctx) => {\r\n    \t\tctx.textAlign = 'left'\r\n    \t\tctx.textBaseline = 'middle'\r\n    \t\tconst branchXPoints = calcBranchXPoints(\r\n    \t\t\t\tctx,\r\n    \t\t\t\trect.left + margin,\r\n    \t\t\t\twidth,\r\n    \t\t\t\tradius,\r\n    \t\t\t\tbranches,\r\n    \t\t\t\ttimeline\r\n    \t\t)\r\n\r\n    \t\tconst y = rect.top + rect.height / 2\r\n\r\n    \t\t// draw join lines\r\n    \t\tdata.map((point, index) => point\r\n    \t\t\t? point.lines.map((line) => ({\r\n    \t\t\t\tcolorIndex: line.colorIndex,\r\n    \t\t\t\tupLineIndex: line[upLineIndexKey],\r\n    \t\t\t\tdownLineIndex: line[downLineIndexKey],\r\n    \t\t\t\tpointIndex: index\r\n    \t\t\t}))\r\n    \t\t\t: []\r\n    \t\t).reduce((p, c) => p.concat(c), []). // flatMap\r\n    \t\t// order of overlap\r\n    \t\t\tsort((a, b) => b.colorIndex - a.colorIndex).forEach((line) => {\r\n    \t\t\t\tconst x = branchXPoints[line.pointIndex]\r\n    \t\t\t\trenderMerge(\r\n    \t\t\t\t\t\tgrid,\r\n    \t\t\t\t\t\tctx,\r\n    \t\t\t\t\t\tx,\r\n    \t\t\t\t\t\ty,\r\n    \t\t\t\t\t\tline.upLineIndex,\r\n    \t\t\t\t\t\tline.downLineIndex,\r\n    \t\t\t\t\t\tline.colorIndex,\r\n    \t\t\t\t\t\t{\r\n    \t\t\t\t\t\t\tmargin,\r\n    \t\t\t\t\t\t\tbranchXPoints,\r\n    \t\t\t\t\t\t\tbranchLineWidth,\r\n    \t\t\t\t\t\t\tbranchColors,\r\n    \t\t\t\t\t\t\tmergeStyle\r\n    \t\t\t\t\t\t},\r\n    \t\t\t\t\t\t{\r\n    \t\t\t\t\t\t\twidth,\r\n    \t\t\t\t\t\t\tcol,\r\n    \t\t\t\t\t\t\trow,\r\n    \t\t\t\t\t\t\tbranches\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t)\r\n    \t\t\t})\r\n    \t\t// draw commit points\r\n    \t\tdata.forEach((p, index) => {\r\n    \t\t\tif (p && p.commit) {\r\n    \t\t\t\tconst x = branchXPoints[index]\r\n    \t\t\t\tctx.fillStyle = getOrApply(branchColors, branches[index], index)\r\n    \t\t\t\tctx.beginPath()\r\n    \t\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2, true)\r\n    \t\t\t\tctx.fill()\r\n    \t\t\t\tctx.closePath()\r\n    \t\t\t}\r\n    \t\t})\r\n    \t\t// draw tags\r\n    \t\tdata.forEach((p, index) => {\r\n    \t\t\tif (p && p.tag) {\r\n    \t\t\t\tctx.fillStyle = getOrApply(branchColors, branches[index], index)\r\n    \t\t\t\tctx.fillText(p.tag, branchXPoints[index] + radius + 4, y)\r\n    \t\t\t}\r\n    \t\t})\r\n    \t})\r\n    }\r\n}\r\n","import * as utils from './columnUtils'\r\nimport type { ButtonColumnOption, CellContext, GridCanvasHelperAPI } from '../../ts-types'\r\nimport type { DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { ButtonStyle } from '../style/ButtonStyle'\r\nimport { Column } from './Column'\r\nimport { cellInRange } from '../../internal/utils'\r\nimport { getButtonColumnStateId } from '../../internal/symbolManager'\r\n\r\nconst BUTTON_COLUMN_STATE_ID = getButtonColumnStateId()\r\n\r\nexport class ButtonColumn<T> extends Column<T> {\r\n    private _caption?: string\r\n\r\n    constructor(option: ButtonColumnOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._caption = option.caption\r\n    }\r\n\r\n    get StyleClass(): typeof ButtonStyle {\r\n    \treturn ButtonStyle\r\n    }\r\n\r\n    get caption(): string | undefined {\r\n    \treturn this._caption\r\n    }\r\n\r\n    withCaption(caption: string): ButtonColumn<T> {\r\n    \tconst c = this.clone()\r\n    \tc._caption = caption\r\n    \treturn c\r\n    }\r\n\r\n    clone(): ButtonColumn<T> {\r\n    \treturn new ButtonColumn(this)\r\n    }\r\n\r\n    convertInternal(value: unknown): string {\r\n    \treturn this._caption || super.convertInternal(value)\r\n    }\r\n\r\n    drawInternal(value: string, context: CellContext, style: ButtonStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void {\r\n    \tconst { textAlign, textBaseline, bgColor, color, buttonBgColor, font, padding, textOverflow } = style\r\n    \tif (bgColor) {\r\n    \t\tdrawCellBase({\r\n    \t\t\tbgColor\r\n    \t\t})\r\n    \t}\r\n    \thelper.testFontLoad(font, value, context)\r\n    \tconst { col, row } = context\r\n    \tconst range = grid.getCellRange(col, row)\r\n    \tlet active = false\r\n    \tconst state = grid[BUTTON_COLUMN_STATE_ID]\r\n\r\n    \tif (state) {\r\n    \t\tif (state.mouseActiveCell && cellInRange(range, state.mouseActiveCell.col, state.mouseActiveCell.row)) {\r\n    \t\t\tactive = true\r\n    \t\t} else {\r\n    \t\t\tconst { select } = context.getSelection()\r\n    \t\t\tif (cellInRange(range, select.col, select.row)) {\r\n    \t\t\t\tactive = true\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n\r\n    \tutils.loadIcons(getIcon(), context, helper, (icons, context) => {\r\n    \t\thelper.button(value, context, {\r\n    \t\t\ttextAlign,\r\n    \t\t\ttextBaseline,\r\n    \t\t\tbgColor: buttonBgColor,\r\n    \t\t\tcolor,\r\n    \t\t\tfont,\r\n    \t\t\tpadding,\r\n    \t\t\tshadow: active\r\n    \t\t\t\t? {\r\n    \t\t\t\t\tcolor: 'rgba(0, 0, 0, 0.48)',\r\n    \t\t\t\t\tblur: 6,\r\n    \t\t\t\t\toffsetY: 3\r\n    \t\t\t\t}\r\n    \t\t\t\t: {},\r\n    \t\t\ttextOverflow,\r\n    \t\t\ticons\r\n    \t\t})\r\n    \t})\r\n    }\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI } from '../../ts-types'\r\nimport type { DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport { CheckStyle } from '../style/CheckStyle'\r\nimport { getCheckColumnStateId } from '../../internal/symbolManager'\r\nimport { toBoolean } from '../utils'\r\n\r\nconst CHECK_COLUMN_STATE_ID = getCheckColumnStateId()\r\n\r\nexport class CheckColumn<T> extends BaseColumn<T, boolean> {\r\n\tget StyleClass(): typeof CheckStyle {\r\n\t\treturn CheckStyle\r\n\t}\r\n\r\n\tclone(): CheckColumn<T> {\r\n\t\treturn new CheckColumn(this)\r\n\t}\r\n\r\n\tconvertInternal(value: unknown): boolean {\r\n\t\treturn toBoolean(value)\r\n\t}\r\n\r\n\tdrawInternal(value: boolean, context: CellContext, style: CheckStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline, borderColor, checkBgColor, uncheckBgColor, bgColor } = style\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tconst { col, row } = context\r\n\t\tconst range = grid.getCellRange(col, row)\r\n\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\t\tconst elapsed = grid[CHECK_COLUMN_STATE_ID]?.elapsed[cellKey]\r\n\r\n\t\tconst opt: Parameters<GridCanvasHelperAPI['checkbox']>[2] = {\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tborderColor,\r\n\t\t\tcheckBgColor,\r\n\t\t\tuncheckBgColor\r\n\t\t}\r\n\t\tif (elapsed != null) {\r\n\t\t\topt.animElapsedTime = elapsed\r\n\t\t}\r\n\t\thelper.checkbox(value, context, opt)\r\n\t}\r\n}\r\n","import * as utils from './columnUtils'\r\nimport type { CellContext, GridCanvasHelperAPI, ListGridAPI } from '../../ts-types'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { Style } from '../style/Style'\r\n\r\nexport class Column<T> extends BaseColumn<T, string> {\r\n\tget StyleClass(): typeof Style {\r\n\t\treturn Style\r\n\t}\r\n\r\n\tclone(): Column<T> {\r\n\t\treturn new Column(this)\r\n\t}\r\n\r\n\tdrawInternal(value: string, context: CellContext, style: Style, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline, color, font, bgColor, padding, textOverflow } = style\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\t\thelper.testFontLoad(font, value, context)\r\n\t\tutils.loadIcons(getIcon(), context, helper, (icons, context) => {\r\n\t\t\thelper.text(value, context, {\r\n\t\t\t\ttextAlign,\r\n\t\t\t\ttextBaseline,\r\n\t\t\t\tcolor,\r\n\t\t\t\tfont,\r\n\t\t\t\tpadding,\r\n\t\t\t\ttextOverflow,\r\n\t\t\t\ticons\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n}\r\n","import * as icons from '../../internal/icons'\r\nimport type { CellContext, ColumnIconOption, GridCanvasHelperAPI, IconColumnOption, ListGridAPI } from '../../ts-types'\r\nimport { Column } from './Column'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { IconStyle } from '../style/IconStyle'\r\n\r\nfunction repeatArray(val: ColumnIconOption<unknown>, count: number): ColumnIconOption<unknown>[] {\r\n\tif (count === Infinity) {\r\n\t\tcount = 0\r\n\t}\r\n\tconst a = []\r\n\tfor (let i = 0; i < count; i++) {\r\n\t\ta.push(val)\r\n\t}\r\n\treturn a\r\n}\r\n\r\nexport class IconColumn<T> extends Column<T> {\r\n    private _tagName?: string\r\n\r\n    private _className?: string\r\n\r\n    private _content?: string\r\n\r\n    private _name?: string\r\n\r\n    private _iconWidth?: number\r\n\r\n    constructor(option: IconColumnOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._tagName = option.tagName || 'i'\r\n    \tthis._className = option.className\r\n    \tthis._content = option.content\r\n    \tthis._name = option.name\r\n    \tthis._iconWidth = option.iconWidth\r\n    }\r\n\r\n    get StyleClass(): typeof IconStyle {\r\n    \treturn IconStyle\r\n    }\r\n\r\n    clone(): IconColumn<T> {\r\n    \treturn new IconColumn(this)\r\n    }\r\n\r\n    drawInternal(value: string, context: CellContext, style: IconStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void {\r\n    \tconst num = Number(value)\r\n    \tif (!isNaN(num)) {\r\n    \t\tconst icon: IconColumnOption & { width?: number } = {}\r\n    \t\ticons.iconPropKeys.forEach((k) => {\r\n    \t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t\t(icon as any)[k] = (style as any)[k]\r\n    \t\t})\r\n    \t\ticon.className = this._className\r\n    \t\ticon.tagName = this._tagName\r\n    \t\tif (this._content) {\r\n    \t\t\ticon.content = this._content\r\n    \t\t}\r\n    \t\ticon.name = this._name\r\n    \t\tif (this._iconWidth) {\r\n    \t\t\ticon.width = this._iconWidth\r\n    \t\t}\r\n\r\n    \t\tinfo.getIcon = (): ColumnIconOption<unknown>[] => repeatArray(icon as ColumnIconOption<unknown>, num)\r\n    \t} else {\r\n    \t\tinfo.getIcon = (): null => null\r\n    \t}\r\n    \tsuper.drawInternal('', context, style, helper, grid, info)\r\n    }\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI, ListGridAPI, MaybePromise } from '../../ts-types'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { ImageStyle } from '../style/ImageStyle'\r\nimport { calcStartPosition } from '../../internal/canvases'\r\nimport { getCacheOrLoad } from '../../internal/imgs'\r\n\r\nconst MAX_LRU_CACHE_SIZE = 50\r\n\r\nfunction getImage(url: MaybePromise<string>): MaybePromise<HTMLImageElement> {\r\n\treturn getCacheOrLoad('ImageColumn', MAX_LRU_CACHE_SIZE, url)\r\n}\r\n\r\nfunction calcKeepAspectRatioSize(\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\tmaxWidth: number,\r\n\t\tmaxHeight: number\r\n): {\r\n    width: number;\r\n    height: number;\r\n} {\r\n\tlet newWidth = width\r\n\tlet newHeight = height\r\n\tif (newWidth > maxWidth) {\r\n\t\tnewWidth = maxWidth\r\n\t\tnewHeight = (newWidth * height) / width\r\n\t}\r\n\tif (newHeight > maxHeight) {\r\n\t\tnewHeight = maxHeight\r\n\t\tnewWidth = (newHeight * width) / height\r\n\t}\r\n\treturn {\r\n\t\twidth: newWidth,\r\n\t\theight: newHeight\r\n\t}\r\n}\r\n\r\nexport class ImageColumn<T> extends BaseColumn<T, HTMLImageElement> {\r\n\tget StyleClass(): typeof ImageStyle {\r\n\t\treturn ImageStyle\r\n\t}\r\n\r\n\tonDrawCell(cellValue: MaybePromise<string>, info: DrawCellInfo<T>, context: CellContext, grid: ListGridAPI<T>): void | Promise<void> {\r\n\t\treturn super.onDrawCell(getImage(cellValue), info, context, grid)\r\n\t}\r\n\r\n\tclone(): ImageColumn<T> {\r\n\t\treturn new ImageColumn(this)\r\n\t}\r\n\r\n\tdrawInternal(value: HTMLImageElement, context: CellContext, style: ImageStyle, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase }: DrawCellInfo<T>): void {\r\n\t\tif (value) {\r\n\t\t\tconst { textAlign, textBaseline, margin, bgColor } = style\r\n\t\t\tif (bgColor) {\r\n\t\t\t\tdrawCellBase({\r\n\t\t\t\t\tbgColor\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\thelper.drawWithClip(context, (ctx) => {\r\n\t\t\t\tctx.textAlign = textAlign\r\n\t\t\t\tctx.textBaseline = textBaseline\r\n\t\t\t\tconst rect = context.getRect()\r\n\t\t\t\tif (style.imageSizing === 'keep-aspect-ratio') {\r\n\t\t\t\t\tconst { width, height } = calcKeepAspectRatioSize(value.width, value.height, rect.width - margin * 2, rect.height - margin * 2)\r\n\t\t\t\t\tconst pos = calcStartPosition(ctx, rect, width, height, {\r\n\t\t\t\t\t\toffset: margin\r\n\t\t\t\t\t})\r\n\t\t\t\t\tctx.drawImage(value, 0, 0, value.width, value.height, pos.x, pos.y, width, height)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tctx.drawImage(value, 0, 0, value.width, value.height, rect.left + margin, rect.top + margin, rect.width - margin * 2, rect.height - margin * 2)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n","import * as utils from './columnUtils'\r\nimport type { CellContext, ColumnMenuItemOptions, GridCanvasHelperAPI, ListGridAPI, MenuColumnOption, SimpleColumnMenuItemOption } from '../../ts-types'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { MenuStyle } from '../style/MenuStyle'\r\nimport { normalize } from '../../internal/menu-items'\r\n\r\nexport class MenuColumn<T> extends BaseColumn<T, unknown> {\r\n    private _options: SimpleColumnMenuItemOption[]\r\n\r\n    constructor(option: MenuColumnOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._options = normalize(option.options)\r\n    }\r\n\r\n    get StyleClass(): typeof MenuStyle {\r\n    \treturn MenuStyle\r\n    }\r\n\r\n    clone(): MenuColumn<T> {\r\n    \treturn new MenuColumn(this)\r\n    }\r\n\r\n    get options(): SimpleColumnMenuItemOption[] {\r\n    \treturn this._options\r\n    }\r\n\r\n    withOptions(options: ColumnMenuItemOptions): MenuColumn<T> {\r\n    \tconst c = this.clone()\r\n    \tc._options = normalize(options)\r\n    \treturn c\r\n    }\r\n\r\n    drawInternal(value: string, context: CellContext, style: MenuStyle, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void {\r\n    \tconst { textAlign, textBaseline, font, bgColor, padding, textOverflow, appearance } = style\r\n    \tlet { color } = style\r\n    \tif (bgColor) {\r\n    \t\tdrawCellBase({\r\n    \t\t\tbgColor\r\n    \t\t})\r\n    \t}\r\n    \tconst text = this._convertInternal(value)\r\n    \thelper.testFontLoad(font, text, context)\r\n    \tutils.loadIcons(getIcon(), context, helper, (icons, context) => {\r\n    \t\tconst basePadding = helper.toBoxPixelArray(padding || 0, context, font)\r\n    \t\tconst textPadding = basePadding.slice(0)\r\n    \t\ttextPadding[1] += 26 // icon padding\r\n    \t\tconst iconPadding = basePadding.slice(0)\r\n    \t\ticonPadding[1] += 8\r\n    \t\tif (color == null && (value == null || value === '')) {\r\n    \t\t\tcolor = 'rgba(0, 0, 0, .38)'\r\n    \t\t}\r\n    \t\thelper.text(text, context, {\r\n    \t\t\ttextAlign,\r\n    \t\t\ttextBaseline,\r\n    \t\t\tcolor,\r\n    \t\t\tfont,\r\n    \t\t\tpadding: textPadding,\r\n    \t\t\ttextOverflow,\r\n    \t\t\ticons\r\n    \t\t})\r\n\r\n    \t\tif (appearance === 'menulist-button') {\r\n    \t\t\t// draw dropdown arrow icon\r\n    \t\t\thelper.text('', context, {\r\n    \t\t\t\ttextAlign: 'right',\r\n    \t\t\t\ttextBaseline,\r\n    \t\t\t\tcolor,\r\n    \t\t\t\tfont,\r\n    \t\t\t\ticons: [\r\n    \t\t\t\t\t{\r\n    \t\t\t\t\t\tpath: 'M0 2 5 7 10 2z',\r\n    \t\t\t\t\t\twidth: 10,\r\n    \t\t\t\t\t\tcolor: 'rgba(0, 0, 0, .54)'\r\n    \t\t\t\t\t}\r\n    \t\t\t\t],\r\n    \t\t\t\tpadding: iconPadding\r\n    \t\t\t})\r\n    \t\t} else if (appearance !== 'none') {\r\n    \t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n    \t\t\tconsole.warn(`unsupported appearance:${ appearance }`)\r\n    \t\t}\r\n    \t})\r\n    }\r\n\r\n    convertInternal(value: unknown): unknown {\r\n    \treturn value\r\n    }\r\n\r\n    _convertInternal(value: unknown): string {\r\n    \tconst options = this._options\r\n    \tfor (let i = 0; i < options.length; i++) {\r\n    \t\tconst option = options[i]\r\n    \t\tif (option.value === value) {\r\n    \t\t\tvalue = option.label\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t}\r\n    \treturn super.convertInternal(value) as string\r\n    }\r\n\r\n    getCopyCellValue(value: unknown): string {\r\n    \treturn this._convertInternal(value)\r\n    }\r\n}\r\n","import * as utils from './columnUtils'\r\nimport type { CellContext, GridCanvasHelperAPI, ListGridAPI } from '../../ts-types'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { MultilineTextStyle } from '../style/MultilineTextStyle'\r\n\r\nexport class MultilineTextColumn<T> extends BaseColumn<T, string> {\r\n\tconstructor(option = {}) {\r\n\t\tsuper(option)\r\n\t}\r\n\r\n\tget StyleClass(): typeof MultilineTextStyle {\r\n\t\treturn MultilineTextStyle\r\n\t}\r\n\r\n\tclone(): MultilineTextColumn<T> {\r\n\t\treturn new MultilineTextColumn(this)\r\n\t}\r\n\r\n\tdrawInternal(value: string, context: CellContext, style: MultilineTextStyle, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline, color, font, bgColor, padding, lineHeight, autoWrapText, lineClamp, textOverflow } = style\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\t\tconst multilines = value.replace(/\\r?\\n/g, '\\n').replace(/\\r/g, '\\n').split('\\n')\r\n\t\thelper.testFontLoad(font, value, context)\r\n\t\tutils.loadIcons(getIcon(), context, helper, (icons, context) => {\r\n\t\t\thelper.multilineText(multilines, context, {\r\n\t\t\t\ttextAlign,\r\n\t\t\t\ttextBaseline,\r\n\t\t\t\tcolor,\r\n\t\t\t\tfont,\r\n\t\t\t\tpadding,\r\n\t\t\t\tlineHeight,\r\n\t\t\t\tautoWrapText,\r\n\t\t\t\tlineClamp,\r\n\t\t\t\ttextOverflow,\r\n\t\t\t\ticons\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n}\r\n","import { Column } from './Column'\r\nimport type { NumberColumnOption } from '../../ts-types'\r\nimport { NumberStyle } from '../style/NumberStyle'\r\n\r\nlet defaultFotmat: Intl.NumberFormat\r\n\r\nexport class NumberColumn<T> extends Column<T> {\r\n    private _format?: Intl.NumberFormat\r\n\r\n    static get defaultFotmat(): Intl.NumberFormat {\r\n    \treturn defaultFotmat || (defaultFotmat = new Intl.NumberFormat())\r\n    }\r\n\r\n    static set defaultFotmat(fmt: Intl.NumberFormat) {\r\n    \tdefaultFotmat = fmt\r\n    }\r\n\r\n    constructor(option: NumberColumnOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._format = option.format\r\n    }\r\n\r\n    get StyleClass(): typeof NumberStyle {\r\n    \treturn NumberStyle\r\n    }\r\n\r\n    clone(): NumberColumn<T> {\r\n    \treturn new NumberColumn(this)\r\n    }\r\n\r\n    get format(): Intl.NumberFormat | undefined {\r\n    \treturn this._format\r\n    }\r\n\r\n    withFormat(format: Intl.NumberFormat): NumberColumn<T> {\r\n    \tconst c = this.clone()\r\n    \tc._format = format\r\n    \treturn c\r\n    }\r\n\r\n    convertInternal(value: undefined): string {\r\n    \tconst num = Number(value)\r\n    \tif (isNaN(num)) {\r\n    \t\treturn super.convertInternal(value)\r\n    \t}\r\n    \tconst format = this._format || NumberColumn.defaultFotmat\r\n    \treturn format.format(num)\r\n    }\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI, ListGridAPI, PercentCompleteBarColumnOption } from '../../ts-types'\r\nimport { getOrApply, str } from '../../internal/utils'\r\nimport { Column } from './Column'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { PercentCompleteBarStyle } from '../style/PercentCompleteBarStyle'\r\n\r\nconst MARGIN = 2\r\n\r\nexport class PercentCompleteBarColumn<T> extends Column<T> {\r\n    private _min: number\r\n\r\n    private _max: number\r\n\r\n    private _formatter: (value: string) => string\r\n\r\n    constructor(option: PercentCompleteBarColumnOption = {}) {\r\n    \tsuper(option)\r\n    \tthis._min = option.min || 0\r\n    \tthis._max = option.max || this._min + 100\r\n    \tthis._formatter = option.formatter || ((v: string): string => v)\r\n    }\r\n\r\n    get StyleClass(): typeof PercentCompleteBarStyle {\r\n    \treturn PercentCompleteBarStyle\r\n    }\r\n\r\n    clone(): PercentCompleteBarColumn<T> {\r\n    \treturn new PercentCompleteBarColumn(this)\r\n    }\r\n\r\n    drawInternal(value: string, context: CellContext, style: PercentCompleteBarStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void {\r\n    \tsuper.drawInternal(this._formatter(value), context, style, helper, grid, info)\r\n    \tconst { barColor, barBgColor, barHeight } = style\r\n\r\n    \tlet svalue = `${ value }`\r\n    \tif (str.endsWith(svalue, '%')) {\r\n    \t\tsvalue = svalue.substr(0, svalue.length - 1)\r\n    \t}\r\n    \tconst num = Number(svalue)\r\n    \tif (isNaN(num)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst rate = num < this._min ? 0 : num > this._max ? 1 : (num - this._min) / (this._max - this._min)\r\n\r\n    \thelper.drawWithClip(context, (ctx) => {\r\n    \t\tconst rect = context.getRect()\r\n\r\n    \t\tconst barMaxWidth = rect.width - MARGIN * 2 - 1 /**/\r\n    \t\tconst barTop = rect.bottom - MARGIN - barHeight - 1 /**/\r\n    \t\tconst barLeft = rect.left + MARGIN\r\n    \t\tctx.fillStyle = getOrApply(barBgColor, rate * 100) || '#f0f3f5'\r\n    \t\tctx.beginPath()\r\n    \t\tctx.rect(barLeft, barTop, barMaxWidth, barHeight)\r\n    \t\tctx.fill()\r\n\r\n    \t\tconst barSize = Math.min(barMaxWidth * rate, barMaxWidth)\r\n    \t\tctx.fillStyle = getOrApply(barColor, rate * 100) || '#20a8d8'\r\n    \t\tctx.beginPath()\r\n    \t\tctx.rect(barLeft, barTop, barSize, barHeight)\r\n    \t\tctx.fill()\r\n    \t})\r\n    }\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI } from '../../ts-types'\r\nimport type { DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { BaseColumn } from './BaseColumn'\r\nimport { RadioStyle } from '../style/RadioStyle'\r\nimport { getRadioColumnStateId } from '../../internal/symbolManager'\r\nimport { toBoolean } from '../utils'\r\n\r\nconst RADIO_COLUMN_STATE_ID = getRadioColumnStateId()\r\n\r\nexport class RadioColumn<T> extends BaseColumn<T, boolean> {\r\n\tget StyleClass(): typeof RadioStyle {\r\n\t\treturn RadioStyle\r\n\t}\r\n\r\n\tclone(): RadioColumn<T> {\r\n\t\treturn new RadioColumn(this)\r\n\t}\r\n\r\n\tconvertInternal(value: unknown): boolean {\r\n\t\treturn toBoolean(value)\r\n\t}\r\n\r\n\tdrawInternal(value: boolean, context: CellContext, style: RadioStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline, checkColor, uncheckBorderColor, checkBorderColor, uncheckBgColor, checkBgColor, bgColor } = style\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tconst { col, row } = context\r\n\t\tconst range = grid.getCellRange(col, row)\r\n\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\t\tconst elapsed = grid[RADIO_COLUMN_STATE_ID]?.elapsed[cellKey]\r\n\r\n\t\tconst opt: Parameters<GridCanvasHelperAPI['radioButton']>[2] = {\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tcheckColor,\r\n\t\t\tuncheckBorderColor,\r\n\t\t\tcheckBorderColor,\r\n\t\t\tuncheckBgColor,\r\n\t\t\tcheckBgColor\r\n\t\t}\r\n\t\tif (elapsed != null) {\r\n\t\t\topt.animElapsedTime = elapsed\r\n\t\t}\r\n\t\thelper.radioButton(value, context, opt)\r\n\t}\r\n}\r\n","import * as icons from '../../internal/icons'\r\nimport type { CellContext, ColumnIconOption, GridCanvasHelperAPI, MaybePromise } from '../../ts-types'\r\nimport type { SimpleColumnIconOption } from '../../ts-types-internal'\r\nimport { isPromise } from '../../internal/utils'\r\n\r\nexport function loadIcons(\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\ticon: MaybePromise<ColumnIconOption<any> | ColumnIconOption<any>[]> | null,\r\n\t\tcontext: CellContext,\r\n\t\thelper: GridCanvasHelperAPI,\r\n\t\tcallback: (icons: SimpleColumnIconOption[] | undefined, context: CellContext) => void\r\n): void {\r\n\tlet argIcon = undefined\r\n\tif (icon) {\r\n\t\tif (isPromise(icon)) {\r\n\t\t\ticon.then((i) => {\r\n\t\t\t\tloadIcons(i, context.toCurrentContext(), helper, callback)\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tconst iconList = icons.toNormarizeArray(icon)\r\n\t\t\ticonList.forEach((i) => {\r\n\t\t\t\tif (i.font && i.content) {\r\n\t\t\t\t\thelper.testFontLoad(i.font, i.content, context)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\targIcon = iconList\r\n\t\t}\r\n\t}\r\n\tcallback(argIcon, context)\r\n}\r\n","export function toBoolean(val: unknown): boolean {\n\tif (typeof val === 'string') {\n\t\tif (val === 'false') {\n\t\t\treturn false\n\t\t} else if (val === 'off') {\n\t\t\treturn false\n\t\t} else if (/^0+$/.exec(val)) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn Boolean(val)\n}\n","import { DrawGrid } from './core/DrawGrid'\r\nimport { DG_EVENT_TYPE as EVENT_TYPE } from './core/DG_EVENT_TYPE'\r\n\r\nexport const core = { DrawGrid, EVENT_TYPE }\r\n","export interface DrawGridEvents {\r\n    /**\r\n     * Indicates when the cell was clicked.\r\n     */\r\n    CLICK_CELL: 'click_cell';\r\n    /**\r\n     * Indicates when the cell was double-clicked.\r\n     */\r\n    DBLCLICK_CELL: 'dblclick_cell';\r\n    /**\r\n     * Indicates when the cell was double-taped.\r\n     */\r\n    DBLTAP_CELL: 'dbltap_cell';\r\n    /**\r\n     * Indicates when pointing device button is pressed in a cell.\r\n     */\r\n    MOUSEDOWN_CELL: 'mousedown_cell';\r\n    /**\r\n     * Indicates when pointing device button is released in a cell.\r\n     */\r\n    MOUSEUP_CELL: 'mouseup_cell';\r\n    /**\r\n     * Indicates the cell selection state has changed.\r\n     */\r\n    SELECTED_CELL: 'selected_cell';\r\n    /**\r\n     * Indicates key-downed.\r\n     */\r\n    KEYDOWN: 'keydown';\r\n    MOUSEMOVE_CELL: 'mousemove_cell';\r\n    MOUSEENTER_CELL: 'mouseenter_cell';\r\n    MOUSELEAVE_CELL: 'mouseleave_cell';\r\n    MOUSEOVER_CELL: 'mouseover_cell';\r\n    MOUSEOUT_CELL: 'mouseout_cell';\r\n    /**\r\n     * Indicates when the user attempts to open a context menu in the cell.\r\n     */\r\n    CONTEXTMENU_CELL: 'contextmenu_cell';\r\n    INPUT_CELL: 'input_cell';\r\n    PASTE_CELL: 'paste_cell';\r\n    DELETE_CELL: 'delete_cell';\r\n    EDITABLEINPUT_CELL: 'editableinput_cell';\r\n    MODIFY_STATUS_EDITABLEINPUT_CELL: 'modify_status_editableinput_cell';\r\n    /**\r\n     * Indicates when the column width has changed.\r\n     */\r\n    RESIZE_COLUMN: 'resize_column';\r\n    /**\r\n     * Indicates when scrolled.\r\n     */\r\n    SCROLL: 'scroll';\r\n    FOCUS_GRID: 'focus_grid';\r\n    BLUR_GRID: 'blur_grid';\r\n}\r\n\r\n/**\r\n * DrawGrid event types\r\n * @classdesc cheetahGrid.core.EVENT_TYPE\r\n * @memberof cheetahGrid.core\r\n */\r\nexport const DG_EVENT_TYPE: DrawGridEvents = {\r\n\tCLICK_CELL: 'click_cell',\r\n\tDBLCLICK_CELL: 'dblclick_cell',\r\n\tDBLTAP_CELL: 'dbltap_cell',\r\n\tMOUSEDOWN_CELL: 'mousedown_cell',\r\n\tMOUSEUP_CELL: 'mouseup_cell',\r\n\tSELECTED_CELL: 'selected_cell',\r\n\tKEYDOWN: 'keydown',\r\n\tMOUSEMOVE_CELL: 'mousemove_cell',\r\n\tMOUSEENTER_CELL: 'mouseenter_cell',\r\n\tMOUSELEAVE_CELL: 'mouseleave_cell',\r\n\tMOUSEOVER_CELL: 'mouseover_cell',\r\n\tMOUSEOUT_CELL: 'mouseout_cell',\r\n\tCONTEXTMENU_CELL: 'contextmenu_cell',\r\n\tINPUT_CELL: 'input_cell',\r\n\tPASTE_CELL: 'paste_cell',\r\n\tDELETE_CELL: 'delete_cell',\r\n\tEDITABLEINPUT_CELL: 'editableinput_cell',\r\n\tMODIFY_STATUS_EDITABLEINPUT_CELL: 'modify_status_editableinput_cell',\r\n\tRESIZE_COLUMN: 'resize_column',\r\n\tSCROLL: 'scroll',\r\n\tFOCUS_GRID: 'focus_grid',\r\n\tBLUR_GRID: 'blur_grid'\r\n} as DrawGridEvents\r\n","import * as calc from '../internal/calc'\r\nimport * as hiDPI from '../internal/hiDPI'\r\nimport * as style from '../internal/style'\r\nimport type {\r\n\tAfterSelectedCellEvent,\r\n\tAnyFunction,\r\n\tBeforeSelectedCellEvent,\r\n\tCellAddress,\r\n\tCellContext,\r\n\tCellRange,\r\n\tDrawGridAPI,\r\n\tDrawGridEventHandlersEventMap,\r\n\tDrawGridEventHandlersReturnMap,\r\n\tDrawGridKeyboardOptions,\r\n\tEventListenerId,\r\n\tKeyboardEventListener,\r\n\tKeydownEvent,\r\n\tPasteCellEvent,\r\n\tPasteRangeBoxValues\r\n} from '../ts-types'\r\nimport { array, browser, event, isDescendantElement, isPromise, isDef } from '../internal/utils'\r\n\r\nimport { DG_EVENT_TYPE } from './DG_EVENT_TYPE'\r\nimport { EventHandler } from '../internal/EventHandler'\r\nimport { EventTarget } from './EventTarget'\r\nimport { NumberMap } from '../internal/NumberMap'\r\nimport { Rect } from '../internal/Rect'\r\nimport { Scrollable } from '../internal/Scrollable'\r\nimport { getFontSize } from '../internal/canvases'\r\n//protected symbol\r\nimport { getProtectedSymbol } from '../internal/symbolManager'\r\nimport { parsePasteRangeBoxValues } from '../internal/paste-utils'\r\n\r\nconst {\r\n\t/** @private */\r\n\tisTouchEvent,\r\n\t/** @private */\r\n\tgetMouseButtons,\r\n\t/** @private */\r\n\tgetKeyCode,\r\n\t/** @private */\r\n\tcancel: cancelEvent\r\n} = event\r\n/** @private */\r\nconst _ = getProtectedSymbol()\r\n\r\n/** @private */\r\nfunction createRootElement(): HTMLElement {\r\n\tconst element = document.createElement('div')\r\n\telement.classList.add('cheetah-grid')\r\n\treturn element\r\n}\r\n\r\n/** @private */\r\nconst KEY_BS = 8\r\n/** @private */\r\nconst KEY_TAB = 9\r\n/** @private */\r\nconst KEY_ENTER = 13\r\n/** @private */\r\nconst KEY_END = 35\r\n/** @private */\r\nconst KEY_HOME = 36\r\n/** @private */\r\nconst KEY_LEFT = 37\r\n/** @private */\r\nconst KEY_UP = 38\r\n/** @private */\r\nconst KEY_RIGHT = 39\r\n/** @private */\r\nconst KEY_DOWN = 40\r\n/** @private */\r\nconst KEY_DEL = 46\r\n/** @private */\r\nconst KEY_ALPHA_A = 65\r\n/** @private */\r\nconst KEY_ALPHA_C = 67\r\n/** @private */\r\nconst KEY_ALPHA_V = 86\r\n\r\n//private methods\r\n/** @private */\r\nfunction _vibrate(e: TouchEvent | MouseEvent): void {\r\n\tif (navigator.vibrate && isTouchEvent(e)) {\r\n\t\tnavigator.vibrate(50)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _getTargetRowAt(this: DrawGrid, absoluteY: number): { row: number; top: number } | null {\r\n\tconst internal = this.getTargetRowAtInternal(absoluteY)\r\n\t// if (internal != null) {\r\n\t// return internal\r\n\t// }\r\n\tif (isDef(internal)) {\r\n\t\treturn internal\r\n\t}\r\n\tconst findBefore = (\r\n\t\t\tstartRow: number,\r\n\t\t\tstartBottom: number\r\n\t): {\r\n        top: number;\r\n        row: number;\r\n    } | null => {\r\n\t\tlet bottom = startBottom\r\n\t\tfor (let row = startRow; row >= 0; row--) {\r\n\t\t\tconst height = _getRowHeight.call(this, row)\r\n\t\t\tconst top = bottom - height\r\n\t\t\tif (top <= absoluteY && absoluteY < bottom) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttop,\r\n\t\t\t\t\trow\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbottom = top\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\tconst findAfter = (\r\n\t\t\tstartRow: number,\r\n\t\t\tstartBottom: number\r\n\t): {\r\n        top: number;\r\n        row: number;\r\n    } | null => {\r\n\t\tlet top = startBottom - _getRowHeight.call(this, startRow)\r\n\t\tconst { rowCount } = this[_]\r\n\t\tfor (let row = startRow; row < rowCount; row++) {\r\n\t\t\tconst height = _getRowHeight.call(this, row)\r\n\t\t\tconst bottom = top + height\r\n\t\t\tif (top <= absoluteY && absoluteY < bottom) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttop,\r\n\t\t\t\t\trow\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttop = bottom\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\tconst candRow = Math.min(Math.ceil(absoluteY / this[_].defaultRowHeight), this.rowCount - 1)\r\n\tconst bottom = _getRowsHeight.call(this, 0, candRow)\r\n\tif (absoluteY >= bottom) {\r\n\t\treturn findAfter(candRow, bottom)\r\n\t} else {\r\n\t\treturn findBefore(candRow, bottom)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _getTargetColAt(\r\n\t\tgrid: DrawGrid,\r\n\t\tabsoluteX: number\r\n): {\r\n    left: number;\r\n    col: number;\r\n} | null {\r\n\tlet left = 0\r\n\tconst { colCount } = grid[_]\r\n\tfor (let col = 0; col < colCount; col++) {\r\n\t\tconst width = _getColWidth(grid, col)\r\n\t\tconst right = left + width\r\n\t\tif (right > absoluteX) {\r\n\t\t\treturn {\r\n\t\t\t\tleft,\r\n\t\t\t\tcol\r\n\t\t\t}\r\n\t\t}\r\n\t\tleft = right\r\n\t}\r\n\treturn null\r\n}\r\n\r\n/** @private */\r\nfunction _getTargetFrozenRowAt(\r\n\t\tgrid: DrawGrid,\r\n\t\tabsoluteY: number\r\n): {\r\n    top: number;\r\n    row: number;\r\n} | null {\r\n\tif (!grid[_].frozenRowCount) {\r\n\t\treturn null\r\n\t}\r\n\tlet { top } = grid[_].scroll\r\n\tconst rowCount = grid[_].frozenRowCount\r\n\tfor (let row = 0; row < rowCount; row++) {\r\n\t\tconst height = _getRowHeight.call(grid, row)\r\n\t\tconst bottom = top + height\r\n\t\tif (bottom > absoluteY) {\r\n\t\t\treturn {\r\n\t\t\t\ttop,\r\n\t\t\t\trow\r\n\t\t\t}\r\n\t\t}\r\n\t\ttop = bottom\r\n\t}\r\n\treturn null\r\n}\r\n\r\n/** @private */\r\nfunction _getTargetFrozenColAt(\r\n\t\tgrid: DrawGrid,\r\n\t\tabsoluteX: number\r\n): {\r\n    left: number;\r\n    col: number;\r\n} | null {\r\n\tif (!grid[_].frozenColCount) {\r\n\t\treturn null\r\n\t}\r\n\tlet { left } = grid[_].scroll\r\n\tconst colCount = grid[_].frozenColCount\r\n\tfor (let col = 0; col < colCount; col++) {\r\n\t\tconst width = _getColWidth(grid, col)\r\n\t\tconst right = left + width\r\n\t\tif (right > absoluteX) {\r\n\t\t\treturn {\r\n\t\t\t\tleft,\r\n\t\t\t\tcol\r\n\t\t\t}\r\n\t\t}\r\n\t\tleft = right\r\n\t}\r\n\treturn null\r\n}\r\n\r\n/** @private */\r\nfunction _getFrozenRowsRect(grid: DrawGrid): Rect | null {\r\n\tif (!grid[_].frozenRowCount) {\r\n\t\treturn null\r\n\t}\r\n\tconst { top } = grid[_].scroll\r\n\tlet height = 0\r\n\tconst rowCount = grid[_].frozenRowCount\r\n\tfor (let row = 0; row < rowCount; row++) {\r\n\t\theight += _getRowHeight.call(grid, row)\r\n\t}\r\n\treturn new Rect(grid[_].scroll.left, top, grid[_].canvas.width, height)\r\n}\r\n\r\n/** @private */\r\nfunction _getFrozenColsRect(grid: DrawGrid): Rect | null {\r\n\tif (!grid[_].frozenColCount) {\r\n\t\treturn null\r\n\t}\r\n\tconst { left } = grid[_].scroll\r\n\tlet width = 0\r\n\tconst colCount = grid[_].frozenColCount\r\n\tfor (let col = 0; col < colCount; col++) {\r\n\t\twidth += _getColWidth(grid, col)\r\n\t}\r\n\treturn new Rect(left, grid[_].scroll.top, width, grid[_].canvas.height)\r\n}\r\n\r\n/** @private */\r\nfunction _getCellDrawing(grid: DrawGrid, col: number, row: number): DrawCellContext | null {\r\n\tif (!grid[_].drawCells[row]) {\r\n\t\treturn null\r\n\t}\r\n\treturn grid[_].drawCells[row][col]\r\n}\r\n\r\n/** @private */\r\nfunction _putCellDrawing(grid: DrawGrid, col: number, row: number, context: DrawCellContext): void {\r\n\tif (!grid[_].drawCells[row]) {\r\n\t\tgrid[_].drawCells[row] = {}\r\n\t}\r\n\tgrid[_].drawCells[row][col] = context\r\n}\r\n\r\n/** @private */\r\nfunction _removeCellDrawing(grid: DrawGrid, col: number, row: number): void {\r\n\tif (!grid[_].drawCells[row]) {\r\n\t\treturn\r\n\t}\r\n\tdelete grid[_].drawCells[row][col]\r\n\tif (Object.keys(grid[_].drawCells[row]).length === 0) {\r\n\t\tdelete grid[_].drawCells[row]\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _drawCell(\r\n\t\tthis: DrawGrid,\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tcol: number,\r\n\t\tabsoluteLeft: number,\r\n\t\twidth: number,\r\n\t\trow: number,\r\n\t\tabsoluteTop: number,\r\n\t\theight: number,\r\n\t\tvisibleRect: Rect,\r\n\t\tskipAbsoluteTop: number,\r\n\t\tskipAbsoluteLeft: number,\r\n\t\tdrawLayers: DrawLayers\r\n): void {\r\n\tconst rect = new Rect(absoluteLeft - visibleRect.left, absoluteTop - visibleRect.top, width, height)\r\n\r\n\tconst drawRect = Rect.bounds(Math.max(absoluteLeft, skipAbsoluteLeft) - visibleRect.left, Math.max(absoluteTop, skipAbsoluteTop) - visibleRect.top, rect.right, rect.bottom)\r\n\r\n\tif (drawRect.height > 0 && drawRect.width > 0) {\r\n\t\tctx.save()\r\n\t\ttry {\r\n\t\t\tconst cellDrawing = _getCellDrawing(this, col, row)\r\n\t\t\tif (cellDrawing) {\r\n\t\t\t\tcellDrawing.cancel()\r\n\t\t\t}\r\n\t\t\tconst dcContext = new DrawCellContext(col, row, ctx, rect, drawRect, !!cellDrawing, this[_].selection, drawLayers)\r\n\t\t\tconst p = this.onDrawCell(col, row, dcContext)\r\n\t\t\tif (isPromise(p)) {\r\n\t\t\t\t//\r\n\t\t\t\t_putCellDrawing(this, col, row, dcContext)\r\n\r\n\t\t\t\tconst pCol = col\r\n\t\t\t\tdcContext._delayMode(this, () => {\r\n\t\t\t\t\t_removeCellDrawing(this, pCol, row)\r\n\t\t\t\t})\r\n\t\t\t\tp.then(() => {\r\n\t\t\t\t\tdcContext.terminate()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tctx.restore()\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _drawRow(\r\n\t\tgrid: DrawGrid,\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tinitFrozenCol: { left: number; col: number } | null,\r\n\t\tinitCol: { left: number; col: number },\r\n\t\tdrawRight: number,\r\n\t\trow: number,\r\n\t\tabsoluteTop: number,\r\n\t\theight: number,\r\n\t\tvisibleRect: Rect,\r\n\t\tskipAbsoluteTop: number,\r\n\t\tdrawLayers: DrawLayers\r\n): void {\r\n\tconst { colCount } = grid[_]\r\n\tconst drawOuter = (col: number, absoluteLeft: number): void => {\r\n\t\t//\r\n\t\tif (col >= colCount - 1 && grid[_].canvas.width > absoluteLeft - visibleRect.left) {\r\n\t\t\tconst outerLeft = absoluteLeft - visibleRect.left\r\n\t\t\tctx.save()\r\n\t\t\tctx.beginPath()\r\n\t\t\tctx.fillStyle = grid.underlayBackgroundColor || '#F6F6F6'\r\n\t\t\tctx.rect(outerLeft, absoluteTop - visibleRect.top, grid[_].canvas.width - outerLeft, height)\r\n\t\t\tctx.fill()\r\n\t\t\tctx.restore()\r\n\t\t}\r\n\t}\r\n\r\n\tlet skipAbsoluteLeft = 0\r\n\tif (initFrozenCol) {\r\n\t\tlet absoluteLeft = initFrozenCol.left\r\n\t\tconst count = grid[_].frozenColCount\r\n\t\tfor (let { col } = initFrozenCol; col < count; col++) {\r\n\t\t\tconst width = _getColWidth(grid, col)\r\n\r\n\t\t\t_drawCell.call(grid, ctx, col, absoluteLeft, width, row, absoluteTop, height, visibleRect, skipAbsoluteTop, 0, drawLayers)\r\n\r\n\t\t\tabsoluteLeft += width\r\n\t\t\tif (drawRight <= absoluteLeft) {\r\n\t\t\t\t//\r\n\t\t\t\tdrawOuter(col, absoluteLeft)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tskipAbsoluteLeft = absoluteLeft\r\n\t}\r\n\r\n\tlet absoluteLeft = initCol.left\r\n\tfor (let { col } = initCol; col < colCount; col++) {\r\n\t\tconst width = _getColWidth(grid, col)\r\n\t\t_drawCell.call(grid, ctx, col, absoluteLeft, width, row, absoluteTop, height, visibleRect, skipAbsoluteTop, skipAbsoluteLeft, drawLayers)\r\n\r\n\t\tabsoluteLeft += width\r\n\t\tif (drawRight <= absoluteLeft) {\r\n\t\t\t//\r\n\t\t\tdrawOuter(col, absoluteLeft)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\tdrawOuter(colCount - 1, absoluteLeft)\r\n}\r\n\r\n/** @private */\r\nfunction _getInitContext(this: DrawGrid): CanvasRenderingContext2D {\r\n\treturn this._getInitContext()\r\n}\r\n\r\n/** @private */\r\nfunction _invalidateRect(grid: DrawGrid, drawRect: Rect): void {\r\n\tconst visibleRect = _getVisibleRect(grid)\r\n\tconst { rowCount } = grid[_]\r\n\tconst ctx = _getInitContext.call(grid)\r\n\r\n\tconst initRow = _getTargetRowAt.call(grid, Math.max(visibleRect.top, drawRect.top)) || {\r\n\t\ttop: _getRowsHeight.call(grid, 0, rowCount - 1),\r\n\t\trow: rowCount\r\n\t}\r\n\tconst initCol = _getTargetColAt(grid, Math.max(visibleRect.left, drawRect.left)) || {\r\n\t\tleft: _getColsWidth(grid, 0, grid[_].colCount - 1),\r\n\t\tcol: grid[_].colCount\r\n\t}\r\n\tconst drawBottom = Math.min(visibleRect.bottom, drawRect.bottom)\r\n\tconst drawRight = Math.min(visibleRect.right, drawRect.right)\r\n\r\n\tconst initFrozenRow = _getTargetFrozenRowAt(grid, Math.max(visibleRect.top, drawRect.top))\r\n\tconst initFrozenCol = _getTargetFrozenColAt(grid, Math.max(visibleRect.left, drawRect.left))\r\n\r\n\tconst drawLayers = new DrawLayers()\r\n\r\n\tconst drawOuter = (row: number, absoluteTop: number): void => {\r\n\t\t//\r\n\t\tif (row >= rowCount - 1 && grid[_].canvas.height > absoluteTop - visibleRect.top) {\r\n\t\t\tconst outerTop = absoluteTop - visibleRect.top\r\n\t\t\tctx.save()\r\n\t\t\tctx.beginPath()\r\n\t\t\tctx.fillStyle = grid.underlayBackgroundColor || '#F6F6F6'\r\n\t\t\tctx.rect(0, outerTop, grid[_].canvas.width, grid[_].canvas.height - outerTop)\r\n\t\t\tctx.fill()\r\n\t\t\tctx.restore()\r\n\t\t}\r\n\t}\r\n\r\n\tlet skipAbsoluteTop = 0\r\n\tif (initFrozenRow) {\r\n\t\tlet absoluteTop = initFrozenRow.top\r\n\t\tconst count = grid[_].frozenRowCount\r\n\t\tfor (let { row } = initFrozenRow; row < count; row++) {\r\n\t\t\tconst height = _getRowHeight.call(grid, row)\r\n\t\t\t_drawRow(grid, ctx, initFrozenCol, initCol, drawRight, row, absoluteTop, height, visibleRect, 0, drawLayers)\r\n\t\t\tabsoluteTop += height\r\n\t\t\tif (drawBottom <= absoluteTop) {\r\n\t\t\t\t//\r\n\t\t\t\tdrawOuter(row, absoluteTop)\r\n\t\t\t\tdrawLayers.draw(ctx)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tskipAbsoluteTop = absoluteTop\r\n\t}\r\n\r\n\tlet absoluteTop = initRow.top\r\n\tfor (let { row } = initRow; row < rowCount; row++) {\r\n\t\tconst height = _getRowHeight.call(grid, row)\r\n\r\n\t\t//\r\n\t\t_drawRow(grid, ctx, initFrozenCol, initCol, drawRight, row, absoluteTop, height, visibleRect, skipAbsoluteTop, drawLayers)\r\n\r\n\t\tabsoluteTop += height\r\n\t\tif (drawBottom <= absoluteTop) {\r\n\t\t\t//\r\n\t\t\tdrawOuter(row, absoluteTop)\r\n\t\t\tdrawLayers.draw(ctx)\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\tdrawOuter(rowCount - 1, absoluteTop)\r\n\r\n\tdrawLayers.draw(ctx)\r\n}\r\n\r\n/** @private */\r\nfunction _toPxWidth(grid: DrawGrid, width: string | number): number {\r\n\treturn Math.round(calc.toPx(width, grid[_].calcWidthContext))\r\n}\r\n\r\n/** @private */\r\nfunction _adjustColWidth(grid: DrawGrid, col: number, orgWidth: number): number {\r\n\tconst limits = _getColWidthLimits(grid, col)\r\n\treturn Math.max(_applyColWidthLimits(limits, orgWidth), 0)\r\n}\r\n\r\n/** @private */\r\nfunction _applyColWidthLimits(limits: { min?: number; max?: number } | void | null, orgWidth: number): number {\r\n\tif (!limits) {\r\n\t\treturn orgWidth\r\n\t}\r\n\r\n\tif (limits.min) {\r\n\t\tif (limits.min > orgWidth) {\r\n\t\t\treturn limits.min\r\n\t\t}\r\n\t}\r\n\tif (limits.max) {\r\n\t\tif (limits.max < orgWidth) {\r\n\t\t\treturn limits.max\r\n\t\t}\r\n\t}\r\n\treturn orgWidth\r\n}\r\n\r\n/**\r\n * Gets the definition of the column width.\r\n * @param {DrawGrid} grid grid instance\r\n * @param {number} col number of column\r\n * @returns {string|number} width definition\r\n * @private\r\n */\r\nfunction _getColWidthDefine(grid: DrawGrid, col: number): string | number {\r\n\tconst width = grid[_].colWidthsMap.get(col)\r\n\tif (width) {\r\n\t\treturn width\r\n\t}\r\n\treturn grid.defaultColWidth\r\n}\r\n\r\n/**\r\n * Gets the column width limits.\r\n * @param {DrawGrid} grid grid instance\r\n * @param {number} col number of column\r\n * @returns {object|null} the column width limits\r\n * @private\r\n */\r\nfunction _getColWidthLimits(\r\n\t\tgrid: DrawGrid,\r\n\t\tcol: number\r\n):\r\n    | {\r\n    min?: undefined;\r\n    minDef?: undefined;\r\n    max?: undefined;\r\n    maxDef?: undefined;\r\n}\r\n    | {\r\n    min: number;\r\n    minDef: string | number;\r\n    max?: undefined;\r\n    maxDef?: undefined;\r\n}\r\n    | {\r\n    min?: undefined;\r\n    minDef?: undefined;\r\n    max: number;\r\n    maxDef: string | number;\r\n}\r\n    | null {\r\n\tconst limit = grid[_].colWidthsLimit[col]\r\n\tif (!limit) {\r\n\t\treturn null\r\n\t}\r\n\r\n\tconst result: {\r\n        min?: number;\r\n        max?: number;\r\n        minDef?: string | number;\r\n        maxDef?: string | number;\r\n    } = {}\r\n\r\n\tif (limit.min) {\r\n\t\tresult.min = _toPxWidth(grid, limit.min)\r\n\t\tresult.minDef = limit.min\r\n\t}\r\n\tif (limit.max) {\r\n\t\tresult.max = _toPxWidth(grid, limit.max)\r\n\t\tresult.maxDef = limit.max\r\n\t}\r\n\treturn result as never\r\n}\r\n\r\n/**\r\n * Checks if the given width definition is `auto`.\r\n * @param {string|number} width width definition to check\r\n * @returns {boolean} `true ` if the given width definition is `auto`\r\n * @private\r\n */\r\nfunction isAutoDefine(width: string | number): width is 'auto' {\r\n\treturn Boolean(width && typeof width === 'string' && width.toLowerCase() === 'auto')\r\n}\r\n\r\n/**\r\n * Creates a formula to calculate the auto width.\r\n * @param {DrawGrid} grid grid instance\r\n * @returns {string} formula\r\n * @private\r\n */\r\nfunction _calcAutoColWidthExpr(grid: DrawGrid, shortCircuit = true): string {\r\n\tconst fullWidth = grid[_].calcWidthContext.full\r\n\tlet sumMin = 0\r\n\tconst others: (string | number)[] = []\r\n\tlet autoCount = 0\r\n\tconst hasLimitsOnAuto = []\r\n\tfor (let col = 0; col < grid[_].colCount; col++) {\r\n\t\tconst def = _getColWidthDefine(grid, col)\r\n\t\tconst limits = _getColWidthLimits(grid, col)\r\n\r\n\t\tif (isAutoDefine(def)) {\r\n\t\t\tif (limits) {\r\n\t\t\t\thasLimitsOnAuto.push(limits)\r\n\t\t\t\tif (limits.min) {\r\n\t\t\t\t\tsumMin += limits.min\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tautoCount++\r\n\t\t} else {\r\n\t\t\tlet expr = def\r\n\t\t\tif (limits) {\r\n\t\t\t\tconst orgWidth = _toPxWidth(grid, expr)\r\n\t\t\t\tconst newWidth = _applyColWidthLimits(limits, orgWidth)\r\n\t\t\t\tif (orgWidth !== newWidth) {\r\n\t\t\t\t\texpr = `${ newWidth }px`\r\n\t\t\t\t}\r\n\t\t\t\tsumMin += newWidth\r\n\t\t\t}\r\n\t\t\tothers.push(expr)\r\n\t\t}\r\n\t\tif (shortCircuit && sumMin > fullWidth) {\r\n\t\t\t// Returns 0px because it has consumed the full width.\r\n\t\t\treturn '0px'\r\n\t\t}\r\n\t}\r\n\tif (hasLimitsOnAuto.length && others.length) {\r\n\t\tconst autoPx = (fullWidth - _toPxWidth(grid, `calc(${ others.map((c) => (typeof c === 'number' ? `${ c }px` : c)).join(' + ') })`)) / autoCount\r\n\t\thasLimitsOnAuto.forEach((limits) => {\r\n\t\t\tif (limits.min && autoPx < limits.min) {\r\n\t\t\t\tothers.push(limits.minDef)\r\n\t\t\t\tautoCount--\r\n\t\t\t} else if (limits.max && limits.max < autoPx) {\r\n\t\t\t\tothers.push(limits.maxDef)\r\n\t\t\t\tautoCount--\r\n\t\t\t}\r\n\t\t})\r\n\t\tif (shortCircuit && autoCount <= 0) {\r\n\t\t\treturn `${ autoPx }px`\r\n\t\t}\r\n\t}\r\n\tif (others.length) {\r\n\t\tconst strDefs: string[] = []\r\n\t\tlet num = 0\r\n\t\tothers.forEach((c) => {\r\n\t\t\tif (typeof c === 'number') {\r\n\t\t\t\tnum += c\r\n\t\t\t} else {\r\n\t\t\t\tstrDefs.push(c)\r\n\t\t\t}\r\n\t\t})\r\n\t\tstrDefs.push(`${ num }px`)\r\n\t\treturn `calc((100% - (${ strDefs.join(' + ') })) / ${ autoCount })`\r\n\t} else {\r\n\t\treturn `${ 100 / autoCount }%`\r\n\t}\r\n}\r\n\r\n/**\r\n * Calculate the pixels of width from the definition of width.\r\n * @param {DrawGrid} grid grid instance\r\n * @param {string|number} width width definition\r\n * @returns {number} the pixels of width\r\n * @private\r\n */\r\nfunction _colWidthDefineToPxWidth(grid: DrawGrid, width: string | number): number {\r\n\tif (isAutoDefine(width)) {\r\n\t\treturn _toPxWidth(grid, _calcAutoColWidthExpr(grid))\r\n\t}\r\n\treturn _toPxWidth(grid, width)\r\n}\r\n\r\n/** @private */\r\nfunction _getColWidth(grid: DrawGrid, col: number): number {\r\n\tconst width = _getColWidthDefine(grid, col)\r\n\treturn _adjustColWidth(grid, col, _colWidthDefineToPxWidth(grid, width))\r\n}\r\n\r\n/** @private */\r\nfunction _setColWidth(grid: DrawGrid, col: number, width: string | number): void {\r\n\tgrid[_].colWidthsMap.put(col, width)\r\n}\r\n\r\n/**\r\n * Overwrites the definition of a column whose width is set to `auto` with the current auto width formula.\r\n * @param {DrawGrid} grid grid instance\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction _storeAutoColWidthExprs(grid: DrawGrid): void {\r\n\tlet expr: string | null = null\r\n\tfor (let col = 0; col < grid[_].colCount; col++) {\r\n\t\tconst def = _getColWidthDefine(grid, col)\r\n\t\tif (isAutoDefine(def)) {\r\n\t\t\t_setColWidth(grid, col, expr || (expr = _calcAutoColWidthExpr(grid, false)))\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _getColsWidth(grid: DrawGrid, startCol: number, endCol: number): number {\r\n\tconst defaultColPxWidth = _colWidthDefineToPxWidth(grid, grid.defaultColWidth)\r\n\tconst colCount = endCol - startCol + 1\r\n\tlet w = defaultColPxWidth * colCount\r\n\tgrid[_].colWidthsMap.each(startCol, endCol, (width, col) => {\r\n\t\tw += _adjustColWidth(grid, col, _colWidthDefineToPxWidth(grid, width)) - defaultColPxWidth\r\n\t})\r\n\tfor (let col = startCol; col <= endCol; col++) {\r\n\t\tif (grid[_].colWidthsMap.has(col)) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tconst adj = _adjustColWidth(grid, col, defaultColPxWidth)\r\n\t\tif (adj !== defaultColPxWidth) {\r\n\t\t\tw += adj - defaultColPxWidth\r\n\t\t}\r\n\t}\r\n\treturn w\r\n}\r\n\r\n/** @private */\r\nfunction _getRowHeight(this: DrawGrid, row: number): number {\r\n\tconst internal = this.getRowHeightInternal(row)\r\n\tif (internal != null) {\r\n\t\treturn Number(internal)\r\n\t}\r\n\tconst height = this[_].rowHeightsMap.get(row)\r\n\tif (height) {\r\n\t\treturn height\r\n\t}\r\n\treturn this[_].defaultRowHeight\r\n}\r\n\r\n/** @private */\r\nfunction _setRowHeight(grid: DrawGrid, row: number, height: number): void {\r\n\tgrid[_].rowHeightsMap.put(row, height)\r\n}\r\n\r\n/** @private */\r\nfunction _getRowsHeight(this: DrawGrid, startRow: number, endRow: number): number {\r\n\tconst internal = this.getRowsHeightInternal(startRow, endRow)\r\n\tif (internal != null) {\r\n\t\treturn Number(internal)\r\n\t}\r\n\tconst rowCount = endRow - startRow + 1\r\n\tlet h = this[_].defaultRowHeight * rowCount\r\n\tthis[_].rowHeightsMap.each(startRow, endRow, (height: number): void => {\r\n\t\th += height - this[_].defaultRowHeight\r\n\t})\r\n\treturn h\r\n}\r\n\r\n/** @private */\r\nfunction _getScrollWidth(grid: DrawGrid): number {\r\n\treturn _getColsWidth(grid, 0, grid[_].colCount - 1)\r\n}\r\n\r\n/** @private */\r\nfunction _getScrollHeight(this: DrawGrid, row?: number): number {\r\n\tconst internal = this.getScrollHeightInternal(row)\r\n\tif (internal != null) {\r\n\t\treturn Number(internal)\r\n\t}\r\n\tlet h = this[_].defaultRowHeight * this[_].rowCount\r\n\tthis[_].rowHeightsMap.each(0, this[_].rowCount - 1, (height) => {\r\n\t\th += height - this[_].defaultRowHeight\r\n\t})\r\n\treturn h\r\n}\r\n\r\n/** @private */\r\nfunction _onScroll(grid: DrawGrid, _e: Event): void {\r\n\tconst lastLeft = grid[_].scroll.left\r\n\tconst lastTop = grid[_].scroll.top\r\n\tconst moveX = grid[_].scrollable.scrollLeft - lastLeft\r\n\tconst moveY = grid[_].scrollable.scrollTop - lastTop\r\n\r\n\t//\r\n\tgrid[_].scroll = {\r\n\t\tleft: grid[_].scrollable.scrollLeft,\r\n\t\ttop: grid[_].scrollable.scrollTop\r\n\t}\r\n\tconst visibleRect = _getVisibleRect(grid)\r\n\tif (Math.abs(moveX) >= visibleRect.width || Math.abs(moveY) >= visibleRect.height) {\r\n\t\t//\r\n\t\t_invalidateRect(grid, visibleRect)\r\n\t} else {\r\n\t\t//\r\n\t\tgrid[_].context.drawImage(grid[_].canvas, -moveX, -moveY)\r\n\r\n\t\tif (moveX !== 0) {\r\n\t\t\t//\r\n\t\t\tconst redrawRect = visibleRect.copy()\r\n\t\t\tif (moveX < 0) {\r\n\t\t\t\tredrawRect.width = -moveX\r\n\t\t\t\tif (grid[_].frozenColCount > 0) {\r\n\t\t\t\t\t//\r\n\t\t\t\t\tconst frozenRect = _getFrozenColsRect(grid)!\r\n\t\t\t\t\tredrawRect.width += frozenRect.width\r\n\t\t\t\t}\r\n\t\t\t} else if (moveX > 0) {\r\n\t\t\t\tredrawRect.left = redrawRect.right - moveX\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\t\t\t_invalidateRect(grid, redrawRect)\r\n\r\n\t\t\tif (moveX > 0) {\r\n\t\t\t\tif (grid[_].frozenColCount > 0) {\r\n\t\t\t\t\t//\r\n\t\t\t\t\t_invalidateRect(grid, _getFrozenColsRect(grid)!)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (moveY !== 0) {\r\n\t\t\t//\r\n\t\t\tconst redrawRect = visibleRect.copy()\r\n\t\t\tif (moveY < 0) {\r\n\t\t\t\tredrawRect.height = -moveY\r\n\t\t\t\tif (grid[_].frozenRowCount > 0) {\r\n\t\t\t\t\t//\r\n\t\t\t\t\tconst frozenRect = _getFrozenRowsRect(grid)!\r\n\t\t\t\t\tredrawRect.height += frozenRect.height\r\n\t\t\t\t}\r\n\t\t\t} else if (moveY > 0) {\r\n\t\t\t\tredrawRect.top = redrawRect.bottom - moveY\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\t\t\t_invalidateRect(grid, redrawRect)\r\n\r\n\t\t\tif (moveY > 0) {\r\n\t\t\t\tif (grid[_].frozenRowCount > 0) {\r\n\t\t\t\t\t//\r\n\t\t\t\t\t_invalidateRect(grid, _getFrozenRowsRect(grid)!)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** @private */\r\n// eslint-disable-next-line complexity\r\nfunction _onKeyDownMove(this: DrawGrid, e: KeyboardEvent): void {\r\n\tconst { shiftKey } = e\r\n\tconst keyCode = getKeyCode(e)\r\n\tconst focusCell = shiftKey ? this.selection.focus : this.selection.select\r\n\tif (keyCode === KEY_LEFT) {\r\n\t\tif (e.ctrlKey || e.metaKey) {\r\n\t\t\tmove(this, null, 'W')\r\n\t\t} else {\r\n\t\t\tif (!hmove.call(this, 'W')) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (keyCode === KEY_UP) {\r\n\t\tif (e.ctrlKey || e.metaKey) {\r\n\t\t\tmove(this, 'N', null)\r\n\t\t} else {\r\n\t\t\tif (!vmove.call(this, 'N')) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (keyCode === KEY_RIGHT) {\r\n\t\tif (e.ctrlKey || e.metaKey) {\r\n\t\t\tmove(this, null, 'E')\r\n\t\t} else {\r\n\t\t\tif (!hmove.call(this, 'E')) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (keyCode === KEY_DOWN) {\r\n\t\tif (e.ctrlKey || e.metaKey) {\r\n\t\t\tmove(this, 'S', null)\r\n\t\t} else {\r\n\t\t\tif (!vmove.call(this, 'S')) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (keyCode === KEY_HOME) {\r\n\t\tif (e.ctrlKey || e.metaKey) {\r\n\t\t\tmove(this, 'N', 'W')\r\n\t\t} else {\r\n\t\t\tmove(this, null, 'W')\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (keyCode === KEY_END) {\r\n\t\tif (e.ctrlKey || e.metaKey) {\r\n\t\t\tmove(this, 'S', 'E')\r\n\t\t} else {\r\n\t\t\tmove(this, null, 'E')\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (this.keyboardOptions?.moveCellOnTab && keyCode === KEY_TAB) {\r\n\t\tif (shiftKey) {\r\n\t\t\tif (!hmove.call(this, 'W', false)) {\r\n\t\t\t\tconst row = this.getMoveUpRowByKeyDownInternal(focusCell)\r\n\t\t\t\tif (0 > row) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t_moveFocusCell.call(this, this.colCount - 1, row, false)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!hmove.call(this, 'E', false)) {\r\n\t\t\t\tconst row = this.getMoveDownRowByKeyDownInternal(focusCell)\r\n\t\t\t\tif (this.rowCount <= row) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t_moveFocusCell.call(this, 0, row, false)\r\n\t\t\t}\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (this.keyboardOptions?.moveCellOnEnter && keyCode === KEY_ENTER) {\r\n\t\tif (shiftKey) {\r\n\t\t\tif (!vmove.call(this, 'N', false)) {\r\n\t\t\t\tconst col = this.getMoveLeftColByKeyDownInternal(focusCell)\r\n\t\t\t\tif (0 > col) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t_moveFocusCell.call(this, col, this.rowCount - 1, false)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!vmove.call(this, 'S', false)) {\r\n\t\t\t\tconst col = this.getMoveRightColByKeyDownInternal(focusCell)\r\n\t\t\t\tif (this.colCount <= col) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t_moveFocusCell.call(this, col, Math.min(this.frozenRowCount, this.rowCount - 1), false)\r\n\t\t\t}\r\n\t\t}\r\n\t\tcancelEvent(e)\r\n\t} else if (this.keyboardOptions?.selectAllOnCtrlA && keyCode === KEY_ALPHA_A && (e.ctrlKey || e.metaKey)) {\r\n\t\tthis.selection.range = {\r\n\t\t\tstart: { col: 0, row: 0 },\r\n\t\t\tend: { col: this.colCount - 1, row: this.rowCount - 1 }\r\n\t\t}\r\n\t\tthis.invalidate()\r\n\t\tcancelEvent(e)\r\n\t}\r\n\r\n\tfunction move(grid: DrawGrid, vDir: 'N' | 'S' | null, hDir: 'W' | 'E' | null): void {\r\n\t\tconst row = vDir === 'S' ? grid.rowCount - 1 : vDir === 'N' ? 0 : focusCell.row\r\n\t\tconst col = hDir === 'E' ? grid.colCount - 1 : hDir === 'W' ? 0 : focusCell.col\r\n\t\t_moveFocusCell.call(grid, col, row, shiftKey)\r\n\t}\r\n\r\n\tfunction vmove(this: DrawGrid, vDir: 'N' | 'S', shiftKeyFlg: boolean = shiftKey): boolean {\r\n\t\tlet row: number\r\n\t\tif (vDir === 'S') {\r\n\t\t\trow = this.getMoveDownRowByKeyDownInternal(focusCell)\r\n\t\t\tif (this.rowCount <= row) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trow = this.getMoveUpRowByKeyDownInternal(focusCell)\r\n\t\t\tif (row < 0) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst { col } = focusCell\r\n\t\t_moveFocusCell.call(this, col, row, shiftKeyFlg)\r\n\t\treturn true\r\n\t}\r\n\r\n\tfunction hmove(this: DrawGrid, hDir: 'W' | 'E', shiftKeyFlg: boolean = shiftKey): boolean {\r\n\t\tlet col: number\r\n\t\tif (hDir === 'E') {\r\n\t\t\tcol = this.getMoveRightColByKeyDownInternal(focusCell)\r\n\t\t\tif (this.colCount <= col) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcol = this.getMoveLeftColByKeyDownInternal(focusCell)\r\n\t\t\tif (col < 0) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst { row } = focusCell\r\n\t\t_moveFocusCell.call(this, col, row, shiftKeyFlg)\r\n\t\treturn true\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _moveFocusCell(this: DrawGrid, col: number, row: number, shiftKey: boolean): void {\r\n\tconst offset = this.getOffsetInvalidateCells()\r\n\r\n\tfunction extendRange(range: CellRange): CellRange {\r\n\t\tif (offset > 0) {\r\n\t\t\trange.start.col -= offset\r\n\t\t\trange.start.row -= offset\r\n\t\t\trange.end.col += offset\r\n\t\t\trange.end.row += offset\r\n\t\t}\r\n\t\treturn range\r\n\t}\r\n\r\n\tconst beforeRange = extendRange(this.selection.range)\r\n\tconst beforeRect = this.getCellRangeRect(beforeRange)\r\n\r\n\tthis.selection._setFocusCell(col, row, shiftKey)\r\n\tthis.makeVisibleCell(col, row)\r\n\tthis.focusCell(col, row)\r\n\r\n\tconst afterRange = extendRange(this.selection.range)\r\n\tconst afterRect = this.getCellRangeRect(afterRange)\r\n\r\n\tif (afterRect.intersection(beforeRect)) {\r\n\t\tconst invalidateRect = Rect.max(afterRect, beforeRect)\r\n\t\t_invalidateRect(this, invalidateRect)\r\n\t} else {\r\n\t\t_invalidateRect(this, beforeRect)\r\n\t\t_invalidateRect(this, afterRect)\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _updatedSelection(this: DrawGrid): void {\r\n\tconst { focusControl } = this[_]\r\n\tconst { col: selCol, row: selRow } = this[_].selection.select\r\n\tconst results = this.fireListeners(DG_EVENT_TYPE.EDITABLEINPUT_CELL, {\r\n\t\tcol: selCol,\r\n\t\trow: selRow\r\n\t})\r\n\r\n\tconst editMode = array.findIndex(results, (v) => !!v) >= 0\r\n\tfocusControl.editMode = editMode\r\n\r\n\tif (editMode) {\r\n\t\tfocusControl.storeInputStatus()\r\n\t\tfocusControl.setDefaultInputStatus()\r\n\t\tthis.fireListeners(DG_EVENT_TYPE.MODIFY_STATUS_EDITABLEINPUT_CELL, {\r\n\t\t\tcol: selCol,\r\n\t\t\trow: selRow,\r\n\t\t\tinput: focusControl.input\r\n\t\t})\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction _getMouseAbstractPoint(grid: DrawGrid, evt: TouchEvent | MouseEvent): { x: number; y: number } | null {\r\n\tlet e: MouseEvent | Touch\r\n\tif (isTouchEvent(evt)) {\r\n\t\te = evt.changedTouches[0]\r\n\t} else {\r\n\t\te = evt\r\n\t}\r\n\tconst clientX = e.clientX || e.pageX + window.scrollX\r\n\tconst clientY = e.clientY || e.pageY + window.scrollY\r\n\tconst rect = grid[_].canvas.getBoundingClientRect()\r\n\tif (rect.right <= clientX) {\r\n\t\treturn null\r\n\t}\r\n\tif (rect.bottom <= clientY) {\r\n\t\treturn null\r\n\t}\r\n\tconst x = clientX - rect.left + grid[_].scroll.left\r\n\tconst y = clientY - rect.top + grid[_].scroll.top\r\n\treturn { x, y }\r\n}\r\n\r\n/** @private */\r\nfunction _bindEvents(this: DrawGrid): void {\r\n\t// eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias\r\n\tconst grid = this\r\n\tconst { handler, element, scrollable } = grid[_]\r\n\tconst getCellEventArgsSet = <EVT extends TouchEvent | MouseEvent>(\r\n\t\te: EVT\r\n\t): {\r\n        abstractPos?: { x: number; y: number };\r\n        cell?: CellAddress;\r\n        eventArgs?: CellAddress & { event: EVT };\r\n    } => {\r\n\t\tconst abstractPos = _getMouseAbstractPoint(grid, e)\r\n\t\tif (!abstractPos) {\r\n\t\t\treturn {}\r\n\t\t}\r\n\t\tconst cell = grid.getCellAt(abstractPos.x, abstractPos.y)\r\n\t\tif (cell.col < 0 || cell.row < 0) {\r\n\t\t\treturn {\r\n\t\t\t\tabstractPos,\r\n\t\t\t\tcell\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst eventArgs = {\r\n\t\t\tcol: cell.col,\r\n\t\t\trow: cell.row,\r\n\t\t\tevent: e\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tabstractPos,\r\n\t\t\tcell,\r\n\t\t\teventArgs\r\n\t\t}\r\n\t}\r\n\tconst canResizeColumn = (col: number): boolean => {\r\n\t\tif (grid[_].disableColumnResize) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tconst limit = grid[_].colWidthsLimit[col]\r\n\t\tif (!limit || !limit.min || !limit.max) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\treturn limit.max !== limit.min\r\n\t}\r\n\thandler.on(element, 'mousedown', (e) => {\r\n\t\tconst eventArgsSet = getCellEventArgsSet(e)\r\n\t\tconst { abstractPos, eventArgs } = eventArgsSet\r\n\t\tif (!abstractPos) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (eventArgs) {\r\n\t\t\tconst results = grid.fireListeners(DG_EVENT_TYPE.MOUSEDOWN_CELL, eventArgs)\r\n\t\t\tif (array.findIndex(results, (v) => !v) >= 0) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (getMouseButtons(e) !== 1) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y)\r\n\t\tif (resizeCol >= 0 && canResizeColumn(resizeCol)) {\r\n\t\t\t//\r\n\t\t\tgrid[_].columnResizer.start(resizeCol, e)\r\n\t\t} else {\r\n\t\t\t//\r\n\t\t\tgrid[_].cellSelector.start(e)\r\n\t\t}\r\n\t})\r\n\thandler.on(element, 'mouseup', (e) => {\r\n\t\tif (!grid.hasListeners(DG_EVENT_TYPE.MOUSEUP_CELL)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst { eventArgs } = getCellEventArgsSet(e)\r\n\t\tif (eventArgs) {\r\n\t\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSEUP_CELL, eventArgs)\r\n\t\t}\r\n\t})\r\n\tlet doubleTapBefore: (CellAddress & { event: TouchEvent | MouseEvent }) | null | undefined = null\r\n\t// let longTouchId: NodeJS.Timeout | null = null;\r\n\tlet longTouchId: number = 0\r\n\thandler.on(element, 'touchstart', (e) => {\r\n\t\tif (!doubleTapBefore) {\r\n\t\t\tdoubleTapBefore = getCellEventArgsSet(e).eventArgs\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tdoubleTapBefore = null\r\n\t\t\t}, 350)\r\n\t\t} else {\r\n\t\t\tconst { eventArgs } = getCellEventArgsSet(e)\r\n\t\t\tif (eventArgs && eventArgs.col === doubleTapBefore.col && eventArgs.row === doubleTapBefore.row) {\r\n\t\t\t\tgrid.fireListeners(DG_EVENT_TYPE.DBLTAP_CELL, eventArgs)\r\n\t\t\t}\r\n\r\n\t\t\tdoubleTapBefore = null\r\n\r\n\t\t\tif (e.defaultPrevented) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlongTouchId = window.setTimeout(() => {\r\n\t\t\t//\r\n\t\t\tlongTouchId = 0\r\n\t\t\tconst abstractPos = _getMouseAbstractPoint(grid, e)\r\n\t\t\tif (!abstractPos) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tconst resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y, 15)\r\n\t\t\tif (resizeCol >= 0 && canResizeColumn(resizeCol)) {\r\n\t\t\t\t//\r\n\t\t\t\tgrid[_].columnResizer.start(resizeCol, e)\r\n\t\t\t} else {\r\n\t\t\t\t//\r\n\t\t\t\tgrid[_].cellSelector.start(e)\r\n\t\t\t}\r\n\t\t}, 500)\r\n\t})\r\n\r\n\tfunction cancel(_e: Event): void {\r\n\t\tif (longTouchId) {\r\n\t\t\twindow.clearTimeout(longTouchId)\r\n\t\t\tlongTouchId = 0\r\n\t\t}\r\n\t}\r\n\r\n\thandler.on(element, 'touchcancel', cancel)\r\n\thandler.on(element, 'touchmove', cancel)\r\n\thandler.on(element, 'touchend', (e) => {\r\n\t\tif (longTouchId) {\r\n\t\t\twindow.clearTimeout(longTouchId)\r\n\t\t\tgrid[_].cellSelector.select(e)\r\n\t\t\tlongTouchId = 0\r\n\t\t}\r\n\t})\r\n\r\n\tlet isMouseover = false\r\n\tlet mouseEnterCell: CellAddress | null = null\r\n\tlet mouseOverCell: CellAddress | null = null\r\n\r\n\tfunction onMouseenterCell(cell: CellAddress, related?: CellAddress): void {\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSEENTER_CELL, {\r\n\t\t\tcol: cell.col,\r\n\t\t\trow: cell.row,\r\n\t\t\trelated\r\n\t\t})\r\n\t\tmouseEnterCell = cell\r\n\t}\r\n\r\n\tfunction onMouseleaveCell(related?: CellAddress): CellAddress | undefined {\r\n\t\tconst beforeMouseCell = mouseEnterCell\r\n\t\tmouseEnterCell = null\r\n\t\tif (beforeMouseCell) {\r\n\t\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSELEAVE_CELL, {\r\n\t\t\t\tcol: beforeMouseCell.col,\r\n\t\t\t\trow: beforeMouseCell.row,\r\n\t\t\t\trelated\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn beforeMouseCell || undefined\r\n\t}\r\n\r\n\tfunction onMouseoverCell(cell: CellAddress, related?: CellAddress): void {\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSEOVER_CELL, {\r\n\t\t\tcol: cell.col,\r\n\t\t\trow: cell.row,\r\n\t\t\trelated\r\n\t\t})\r\n\t\tmouseOverCell = cell\r\n\t}\r\n\r\n\tfunction onMouseoutCell(related?: CellAddress): CellAddress | undefined {\r\n\t\tconst beforeMouseCell = mouseOverCell\r\n\t\tmouseOverCell = null\r\n\t\tif (beforeMouseCell) {\r\n\t\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSEOUT_CELL, {\r\n\t\t\t\tcol: beforeMouseCell.col,\r\n\t\t\t\trow: beforeMouseCell.row,\r\n\t\t\t\trelated\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn beforeMouseCell || undefined\r\n\t}\r\n\r\n\tconst scrollElement = scrollable.getElement()\r\n\thandler.on(scrollElement, 'mouseover', (_e: MouseEvent): void => {\r\n\t\tisMouseover = true\r\n\t})\r\n\thandler.on(scrollElement, 'mouseout', (_e: MouseEvent): void => {\r\n\t\tisMouseover = false\r\n\t\tonMouseoutCell()\r\n\t})\r\n\r\n\thandler.on(element, 'mouseleave', (_e: MouseEvent): void => {\r\n\t\tonMouseleaveCell()\r\n\t})\r\n\r\n\thandler.on(element, 'mousemove', (e) => {\r\n\t\tconst eventArgsSet = getCellEventArgsSet(e)\r\n\t\tconst { abstractPos, eventArgs } = eventArgsSet\r\n\t\tif (eventArgs) {\r\n\t\t\tconst beforeMouseCell = mouseEnterCell\r\n\t\t\tif (beforeMouseCell) {\r\n\t\t\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSEMOVE_CELL, eventArgs)\r\n\t\t\t\tif (beforeMouseCell.col !== eventArgs.col || beforeMouseCell.row !== eventArgs.row) {\r\n\t\t\t\t\tconst enterCell = {\r\n\t\t\t\t\t\tcol: eventArgs.col,\r\n\t\t\t\t\t\trow: eventArgs.row\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst outCell = onMouseoutCell(enterCell)\r\n\t\t\t\t\tconst leaveCell = onMouseleaveCell(enterCell)\r\n\t\t\t\t\tonMouseenterCell(enterCell, leaveCell)\r\n\t\t\t\t\tif (isMouseover) {\r\n\t\t\t\t\t\tonMouseoverCell(enterCell, outCell)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (isMouseover && !mouseOverCell) {\r\n\t\t\t\t\tonMouseoverCell({\r\n\t\t\t\t\t\tcol: eventArgs.col,\r\n\t\t\t\t\t\trow: eventArgs.row\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst enterCell = {\r\n\t\t\t\t\tcol: eventArgs.col,\r\n\t\t\t\t\trow: eventArgs.row\r\n\t\t\t\t}\r\n\t\t\t\tonMouseenterCell(enterCell)\r\n\t\t\t\tif (isMouseover) {\r\n\t\t\t\t\tonMouseoverCell(enterCell)\r\n\t\t\t\t}\r\n\t\t\t\tgrid.fireListeners(DG_EVENT_TYPE.MOUSEMOVE_CELL, eventArgs)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tonMouseoutCell()\r\n\t\t\tonMouseleaveCell()\r\n\t\t}\r\n\t\tif (grid[_].columnResizer.moving(e) || grid[_].cellSelector.moving(e)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst { style } = element\r\n\t\tif (!abstractPos) {\r\n\t\t\tif (style.cursor === 'col-resize') {\r\n\t\t\t\tstyle.cursor = ''\r\n\t\t\t}\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y)\r\n\t\tif (resizeCol >= 0 && canResizeColumn(resizeCol)) {\r\n\t\t\tstyle.cursor = 'col-resize'\r\n\t\t} else {\r\n\t\t\tif (style.cursor === 'col-resize') {\r\n\t\t\t\tstyle.cursor = ''\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\thandler.on(element, 'click', (e) => {\r\n\t\tif (grid[_].columnResizer.lastMoving(e) || grid[_].cellSelector.lastMoving(e)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (!grid.hasListeners(DG_EVENT_TYPE.CLICK_CELL)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst { eventArgs } = getCellEventArgsSet(e)\r\n\t\tif (!eventArgs) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.CLICK_CELL, eventArgs)\r\n\t})\r\n\thandler.on(element, 'contextmenu', (e) => {\r\n\t\tif (!grid.hasListeners(DG_EVENT_TYPE.CONTEXTMENU_CELL)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst { eventArgs } = getCellEventArgsSet(e)\r\n\t\tif (!eventArgs) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.CONTEXTMENU_CELL, eventArgs)\r\n\t})\r\n\thandler.on(element, 'dblclick', (e) => {\r\n\t\tif (!grid.hasListeners(DG_EVENT_TYPE.DBLCLICK_CELL)) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst { eventArgs } = getCellEventArgsSet(e)\r\n\t\tif (!eventArgs) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.DBLCLICK_CELL, eventArgs)\r\n\t})\r\n\tgrid[_].focusControl.onKeyDown((evt: KeydownEvent) => {\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.KEYDOWN, evt)\r\n\t})\r\n\tgrid[_].selection.listen(DG_EVENT_TYPE.SELECTED_CELL, (data) => {\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.SELECTED_CELL, data, data.selected)\r\n\t})\r\n\r\n\tscrollable.onScroll((e) => {\r\n\t\t_onScroll(grid, e)\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.SCROLL, { event: e })\r\n\t})\r\n\tgrid[_].focusControl.onKeyDownMove((e) => {\r\n\t\t_onKeyDownMove.call(grid, e)\r\n\t})\r\n\tgrid.listen('copydata', (range) => {\r\n\t\tconst copyRange = grid.getCopyRangeInternal(range)\r\n\t\tlet copyValue = ''\r\n\t\tfor (let { row } = copyRange.start; row <= copyRange.end.row; row++) {\r\n\t\t\tfor (let { col } = copyRange.start; col <= copyRange.end.col; col++) {\r\n\t\t\t\tconst copyCellValue = grid.getCopyCellValue(col, row, copyRange)\r\n\t\t\t\tif (typeof Promise !== 'undefined' && copyCellValue instanceof Promise) {\r\n\t\t\t\t\t//\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n\t\t\t\t\tconst strCellValue = `${ copyCellValue }`\r\n\t\t\t\t\tif (/^\\[object .*\\]$/.exec(strCellValue)) {\r\n\t\t\t\t\t\t//object \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcopyValue += strCellValue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (col < copyRange.end.col) {\r\n\t\t\t\t\tcopyValue += '\\t'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcopyValue += '\\n'\r\n\t\t}\r\n\t\treturn copyValue\r\n\t})\r\n\tgrid[_].focusControl.onCopy((_e: ClipboardEvent): string | void => array.find(grid.fireListeners('copydata', grid[_].selection.range), (r) => r != null))\r\n\tgrid[_].focusControl.onPaste(({ value, event }: { value: string; event: ClipboardEvent }) => {\r\n\t\tconst normalizeValue = value.replace(/\\r?\\n$/, '')\r\n\t\tconst { col, row } = grid[_].selection.select\r\n\t\tconst multi = /[\\r\\n\\u2028\\u2029\\t]/.test(normalizeValue) // is multi cell values\r\n\t\tlet rangeBoxValues: PasteRangeBoxValues | null = null\r\n\t\tconst pasteCellEvent: PasteCellEvent = {\r\n\t\t\tcol,\r\n\t\t\trow,\r\n\t\t\tvalue,\r\n\t\t\tnormalizeValue,\r\n\t\t\tmulti,\r\n\t\t\tget rangeBoxValues(): PasteRangeBoxValues {\r\n\t\t\t\treturn rangeBoxValues ?? (rangeBoxValues = parsePasteRangeBoxValues(normalizeValue))\r\n\t\t\t},\r\n\t\t\tevent\r\n\t\t}\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.PASTE_CELL, pasteCellEvent)\r\n\t})\r\n\tgrid[_].focusControl.onInput((value) => {\r\n\t\tconst { col, row } = grid[_].selection.select\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.INPUT_CELL, { col, row, value })\r\n\t})\r\n\tgrid[_].focusControl.onDelete((event) => {\r\n\t\tconst { col, row } = grid[_].selection.select\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.DELETE_CELL, { col, row, event })\r\n\t})\r\n\tgrid[_].focusControl.onFocus((e: FocusEvent) => {\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.FOCUS_GRID, e)\r\n\t\tgrid[_].focusedGrid = true\r\n\r\n\t\tconst { col, row } = grid[_].selection.select\r\n\t\tgrid.invalidateCell(col, row)\r\n\t})\r\n\tgrid[_].focusControl.onBlur((e) => {\r\n\t\tgrid.fireListeners(DG_EVENT_TYPE.BLUR_GRID, e)\r\n\t\tgrid[_].focusedGrid = false\r\n\r\n\t\tconst { col, row } = grid[_].selection.select\r\n\t\tgrid.invalidateCell(col, row)\r\n\t})\r\n}\r\n\r\n/** @private */\r\nfunction _getResizeColAt(grid: DrawGrid, abstractX: number, abstractY: number, offset = 5): number {\r\n\tif (grid[_].frozenRowCount <= 0) {\r\n\t\treturn -1\r\n\t}\r\n\tconst frozenRect = _getFrozenRowsRect(grid)!\r\n\tif (!frozenRect.inPoint(abstractX, abstractY)) {\r\n\t\treturn -1\r\n\t}\r\n\tconst cell = grid.getCellAt(abstractX, abstractY)\r\n\tconst cellRect = grid.getCellRect(cell.col, cell.row)\r\n\tif (abstractX < cellRect.left + offset) {\r\n\t\treturn cell.col - 1\r\n\t}\r\n\tif (cellRect.right - offset < abstractX) {\r\n\t\treturn cell.col\r\n\t}\r\n\treturn -1\r\n}\r\n\r\n/** @private */\r\nfunction _getVisibleRect(grid: DrawGrid): Rect {\r\n\tconst {\r\n\t\tscroll: { left, top },\r\n\t\tcanvas: { width, height }\r\n\t} = grid[_]\r\n\treturn new Rect(left, top, width, height)\r\n}\r\n\r\n/** @private */\r\nfunction _getScrollableVisibleRect(grid: DrawGrid): Rect {\r\n\tlet frozenColsWidth = 0\r\n\tif (grid[_].frozenColCount > 0) {\r\n\t\t//\r\n\t\tconst frozenRect = _getFrozenColsRect(grid)!\r\n\t\tfrozenColsWidth = frozenRect.width\r\n\t}\r\n\tlet frozenRowsHeight = 0\r\n\tif (grid[_].frozenRowCount > 0) {\r\n\t\t//\r\n\t\tconst frozenRect = _getFrozenRowsRect(grid)!\r\n\t\tfrozenRowsHeight = frozenRect.height\r\n\t}\r\n\treturn new Rect(grid[_].scrollable.scrollLeft + frozenColsWidth, grid[_].scrollable.scrollTop + frozenRowsHeight, grid[_].canvas.width - frozenColsWidth, grid[_].canvas.height - frozenRowsHeight)\r\n}\r\n\r\n/** @private */\r\nfunction _toRelativeRect(grid: DrawGrid, absoluteRect: Rect): Rect {\r\n\tconst rect = absoluteRect.copy()\r\n\tconst visibleRect = _getVisibleRect(grid)\r\n\trect.offsetLeft(-visibleRect.left)\r\n\trect.offsetTop(-visibleRect.top)\r\n\r\n\treturn rect\r\n}\r\n\r\n//end private methods\r\n//\r\n//\r\n//\r\n//\r\n\r\n/**\r\n * managing mouse down moving\r\n * @private\r\n */\r\nclass BaseMouseDownMover {\r\n    protected _grid: DrawGrid\r\n\r\n    private _handler: EventHandler\r\n\r\n    private _events: {\r\n        mousemove?: EventListenerId;\r\n        mouseup?: EventListenerId;\r\n        touchmove?: EventListenerId;\r\n        touchend?: EventListenerId;\r\n        touchcancel?: EventListenerId;\r\n    }\r\n\r\n    private _started: boolean\r\n\r\n    private _moved: boolean\r\n\r\n    private _mouseEndPoint?: { x: number; y: number } | null\r\n\r\n    constructor(grid: DrawGrid) {\r\n    \tthis._grid = grid\r\n    \tthis._handler = new EventHandler()\r\n    \tthis._events = {}\r\n    \tthis._started = false\r\n    \tthis._moved = false\r\n    }\r\n\r\n    moving(_e: MouseEvent | TouchEvent): boolean {\r\n    \treturn !!this._started\r\n    }\r\n\r\n    lastMoving(e: MouseEvent | TouchEvent): boolean {\r\n    \t// mouseupclick\r\n    \tif (this.moving(e)) {\r\n    \t\treturn true\r\n    \t}\r\n    \tconst last = this._mouseEndPoint\r\n    \tif (!last) {\r\n    \t\treturn false\r\n    \t}\r\n    \tconst pt = _getMouseAbstractPoint(this._grid, e)\r\n    \treturn pt != null && pt.x === last.x && pt.y === last.y\r\n    }\r\n\r\n    protected _bindMoveAndUp(e: MouseEvent | TouchEvent): void {\r\n    \tconst events = this._events\r\n    \tconst handler = this._handler\r\n    \tif (!isTouchEvent(e)) {\r\n    \t\tevents.mousemove = handler.on(document.body, 'mousemove', (e) => this._mouseMove(e))\r\n    \t\tevents.mouseup = handler.on(document.body, 'mouseup', (e) => this._mouseUp(e))\r\n    \t} else {\r\n    \t\tevents.touchmove = handler.on(document.body, 'touchmove', (e) => this._mouseMove(e), { passive: false })\r\n    \t\tevents.touchend = handler.on(document.body, 'touchend', (e) => this._mouseUp(e))\r\n    \t\tevents.touchcancel = handler.on(document.body, 'touchcancel', (e) => this._mouseUp(e))\r\n    \t}\r\n    \tthis._started = true\r\n    \tthis._moved = false\r\n    }\r\n\r\n    private _mouseMove(e: MouseEvent | TouchEvent): void {\r\n    \tif (!isTouchEvent(e)) {\r\n    \t\tif (getMouseButtons(e) !== 1) {\r\n    \t\t\tthis._mouseUp(e)\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t}\r\n    \tthis._moved = this._moveInternal(e) || this._moved /*calculation on after*/\r\n\r\n    \tcancelEvent(e)\r\n    }\r\n\r\n    protected _moveInternal(_e: MouseEvent | TouchEvent): boolean {\r\n    \t//protected\r\n    \treturn false\r\n    }\r\n\r\n    private _mouseUp(e: MouseEvent | TouchEvent): void {\r\n    \tconst events = this._events\r\n    \tconst handler = this._handler\r\n    \thandler.off(events.mousemove)\r\n    \thandler.off(events.touchmove)\r\n    \thandler.off(events.mouseup)\r\n    \thandler.off(events.touchend)\r\n    \t// handler.off(this._events.mouseleave);\r\n    \thandler.off(events.touchcancel)\r\n\r\n    \tthis._started = false\r\n\r\n    \tthis._upInternal(e)\r\n\r\n    \t// mouseupclick\r\n    \tif (this._moved) {\r\n    \t\t//\r\n    \t\tthis._mouseEndPoint = _getMouseAbstractPoint(this._grid, e)\r\n    \t\tsetTimeout(() => {\r\n    \t\t\tthis._mouseEndPoint = null\r\n    \t\t}, 10)\r\n    \t}\r\n    }\r\n\r\n    protected _upInternal(_e: MouseEvent | TouchEvent): void {\r\n    \t//protected\r\n    }\r\n\r\n    dispose(): void {\r\n    \tthis._handler.dispose()\r\n    }\r\n}\r\n\r\n/**\r\n * managing cell selection operation with mouse\r\n * @private\r\n */\r\nclass CellSelector extends BaseMouseDownMover {\r\n    private _cell?: CellAddress\r\n\r\n    start(e: MouseEvent | TouchEvent): void {\r\n    \tconst cell = this._getTargetCell(e)\r\n    \tif (!cell) {\r\n    \t\treturn\r\n    \t}\r\n    \t_moveFocusCell.call(this._grid, cell.col, cell.row, e.shiftKey)\r\n\r\n    \tthis._bindMoveAndUp(e)\r\n\r\n    \tthis._cell = cell\r\n\r\n    \tcancelEvent(e)\r\n    \t_vibrate(e)\r\n    }\r\n\r\n    select(e: MouseEvent | TouchEvent): void {\r\n    \tconst cell = this._getTargetCell(e)\r\n    \tif (!cell) {\r\n    \t\treturn\r\n    \t}\r\n    \t_moveFocusCell.call(this._grid, cell.col, cell.row, e.shiftKey)\r\n    \tthis._cell = cell\r\n    }\r\n\r\n    protected _moveInternal(e: MouseEvent | TouchEvent): boolean {\r\n    \tconst cell = this._getTargetCell(e)\r\n    \tif (!cell) {\r\n    \t\treturn false\r\n    \t}\r\n    \tconst { col: oldCol, row: oldRow } = this._cell!\r\n    \tconst { col: newCol, row: newRow } = cell\r\n    \tif (oldCol === newCol && oldRow === newRow) {\r\n    \t\treturn false\r\n    \t}\r\n    \tconst grid = this._grid\r\n    \t_moveFocusCell.call(grid, newCol, newRow, true)\r\n\r\n    \t//make visible\r\n    \tconst makeVisibleCol = ((): number => {\r\n    \t\tif (newCol < oldCol && 0 < newCol) {\r\n    \t\t\t// move left\r\n    \t\t\treturn newCol - 1\r\n    \t\t} else if (oldCol < newCol && newCol + 1 < grid.colCount) {\r\n    \t\t\t// move right\r\n    \t\t\treturn newCol + 1\r\n    \t\t}\r\n    \t\treturn newCol\r\n    \t})()\r\n    \tconst makeVisibleRow = ((): number => {\r\n    \t\tif (newRow < oldRow && 0 < newRow) {\r\n    \t\t\t// move up\r\n    \t\t\treturn newRow - 1\r\n    \t\t} else if (oldRow < newRow && newRow + 1 < grid.rowCount) {\r\n    \t\t\t// move down\r\n    \t\t\treturn newRow + 1\r\n    \t\t}\r\n    \t\treturn newRow\r\n    \t})()\r\n    \tif (makeVisibleCol !== newCol || makeVisibleRow !== newRow) {\r\n    \t\tgrid.makeVisibleCell(makeVisibleCol, makeVisibleRow)\r\n    \t}\r\n    \tthis._cell = cell\r\n    \treturn true\r\n    }\r\n\r\n    private _getTargetCell(e: MouseEvent | TouchEvent): CellAddress | null {\r\n    \tconst grid = this._grid\r\n    \tconst abstractPos = _getMouseAbstractPoint(grid, e)\r\n    \tif (!abstractPos) {\r\n    \t\treturn null\r\n    \t}\r\n    \tconst cell = grid.getCellAt(abstractPos.x, abstractPos.y)\r\n    \tif (cell.col < 0 || cell.row < 0) {\r\n    \t\treturn null\r\n    \t}\r\n    \treturn cell\r\n    }\r\n}\r\n\r\n/**\r\n * managing row width changing operation with mouse\r\n * @private\r\n */\r\nclass ColumnResizer extends BaseMouseDownMover {\r\n    private _targetCol: number\r\n\r\n    private _x = -1\r\n\r\n    private _preX = -1\r\n\r\n    private _invalidateAbsoluteLeft = -1\r\n\r\n    constructor(grid: DrawGrid) {\r\n    \tsuper(grid)\r\n    \tthis._targetCol = -1\r\n    }\r\n\r\n    start(col: number, e: MouseEvent | TouchEvent): void {\r\n    \tlet pageX\r\n    \tif (!isTouchEvent(e)) {\r\n    \t\t({ pageX } = e)\r\n    \t} else {\r\n    \t\t({ pageX } = e.changedTouches[0])\r\n    \t}\r\n\r\n    \tthis._x = pageX\r\n    \tthis._preX = 0\r\n\r\n    \tthis._bindMoveAndUp(e)\r\n\r\n    \tthis._targetCol = col\r\n    \tthis._invalidateAbsoluteLeft = _getColsWidth(this._grid, 0, col - 1)\r\n\r\n    \tcancelEvent(e)\r\n    \t_vibrate(e)\r\n    }\r\n\r\n    protected _moveInternal(e: MouseEvent | TouchEvent): boolean {\r\n    \tconst pageX = isTouchEvent(e) ? e.changedTouches[0].pageX : e.pageX\r\n\r\n    \tconst x = pageX - this._x\r\n    \tconst moveX = x - this._preX\r\n    \tthis._preX = x\r\n    \tconst pre = this._grid.getColWidth(this._targetCol)\r\n    \tlet afterSize = _adjustColWidth(this._grid, this._targetCol, pre + moveX)\r\n    \tif (afterSize < 10 && moveX < 0) {\r\n    \t\tafterSize = 10\r\n    \t}\r\n    \t_storeAutoColWidthExprs(this._grid)\r\n    \t_setColWidth(this._grid, this._targetCol, afterSize)\r\n\r\n    \tconst rect = _getVisibleRect(this._grid)\r\n    \trect.left = this._invalidateAbsoluteLeft\r\n    \t_invalidateRect(this._grid, rect)\r\n\r\n    \tthis._grid.fireListeners(DG_EVENT_TYPE.RESIZE_COLUMN, {\r\n    \t\tcol: this._targetCol\r\n    \t})\r\n\r\n    \treturn true\r\n    }\r\n\r\n    protected _upInternal(_e: MouseEvent | TouchEvent): void {\r\n    \tconst grid = this._grid\r\n    \tif (grid.updateScroll()) {\r\n    \t\tgrid.invalidate()\r\n    \t}\r\n    }\r\n}\r\n\r\n/** @private */\r\nfunction setSafeInputValue(input: HTMLInputElement, value: string): void {\r\n\tconst { type } = input\r\n\tinput.type = ''\r\n\tinput.value = value\r\n\tif (type) {\r\n\t\tinput.type = type\r\n\t}\r\n}\r\n\r\n/**\r\n * Manage focus\r\n * @private\r\n */\r\nclass FocusControl extends EventTarget {\r\n    private _grid: DrawGrid\r\n\r\n    private _scrollable: Scrollable\r\n\r\n    private _handler: EventHandler\r\n\r\n    private _input: HTMLInputElement\r\n\r\n    private _isComposition?: boolean\r\n\r\n    private _compositionEnd?: number\r\n\r\n    private _inputStatus?: { [key: string]: string }\r\n\r\n    private _keyDownMoveCallback?: KeyboardEventListener\r\n\r\n    constructor(grid: DrawGrid, parentElement: HTMLElement, scrollable: Scrollable) {\r\n    \tsuper()\r\n    \tthis._grid = grid\r\n    \tthis._scrollable = scrollable\r\n    \tconst handler = (this._handler = new EventHandler())\r\n    \tconst input = (this._input = document.createElement('input'))\r\n    \tinput.classList.add('grid-focus-control')\r\n    \tinput.readOnly = true\r\n    \tparentElement.appendChild(input)\r\n\r\n    \thandler.on(input, 'compositionstart', (_e: Event): void => {\r\n    \t\tinput.classList.add('composition')\r\n    \t\tinput.style.font = grid.font || '16px sans-serif'\r\n    \t\tthis._isComposition = true\r\n    \t\tif (this._compositionEnd) {\r\n    \t\t\tclearTimeout(this._compositionEnd)\r\n    \t\t\tdelete this._compositionEnd\r\n    \t\t}\r\n    \t\tgrid.focus()\r\n    \t})\r\n    \tlet lastInputValue: string | undefined\r\n    \tconst inputClear = (storeLastInputValue: boolean): void => {\r\n    \t\tlastInputValue = input.value\r\n    \t\tif (this._isComposition) {\r\n    \t\t\treturn\r\n    \t\t}\r\n\r\n    \t\tif (lastInputValue !== '') {\r\n    \t\t\tsetSafeInputValue(input, '')\r\n    \t\t}\r\n    \t\tif (!storeLastInputValue) {\r\n    \t\t\tlastInputValue = ''\r\n    \t\t}\r\n    \t}\r\n\r\n    \tconst handleCompositionEnd = (): void => {\r\n    \t\tthis._isComposition = false\r\n    \t\tinput.classList.remove('composition')\r\n    \t\tinput.style.font = ''\r\n    \t\tconst { value } = input\r\n\r\n    \t\tinputClear(false)\r\n\r\n    \t\tif (!input.readOnly) {\r\n    \t\t\tthis.fireListeners('input', value)\r\n    \t\t}\r\n\r\n    \t\tif (this._compositionEnd) {\r\n    \t\t\tclearTimeout(this._compositionEnd)\r\n    \t\t\tdelete this._compositionEnd\r\n    \t\t}\r\n    \t}\r\n    \thandler.on(input, 'compositionend', (_e: Event): void => {\r\n    \t\tthis._compositionEnd = window.setTimeout(handleCompositionEnd, 1)\r\n    \t})\r\n    \thandler.on(input, 'keypress', (e) => {\r\n    \t\tif (this._isComposition) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tif (!input.readOnly && e.key && e.key.length === 1) {\r\n    \t\t\tif (e.ctrlKey || e.metaKey) {\r\n    \t\t\t\tif (e.key === 'c') {\r\n    \t\t\t\t\t//copy! for Firefox & Safari\r\n    \t\t\t\t} else if (e.key === 'v') {\r\n    \t\t\t\t\t//paste! for Firefox & Safari\r\n    \t\t\t\t}\r\n    \t\t\t} else {\r\n    \t\t\t\tif (e.key === ' ') {\r\n    \t\t\t\t\t// Since the full-width space cannot be determined, it is processed by \"input\".\r\n    \t\t\t\t\treturn\r\n    \t\t\t\t}\r\n    \t\t\t\tthis.fireListeners('input', e.key)\r\n    \t\t\t\tcancelEvent(e)\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tinputClear(true)\r\n    \t})\r\n    \thandler.on(input, 'keydown', (e) => {\r\n    \t\tif (this._isComposition) {\r\n    \t\t\tif (this._compositionEnd) {\r\n    \t\t\t\thandleCompositionEnd()\r\n    \t\t\t\tcancelEvent(e)\r\n    \t\t\t}\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst keyCode = getKeyCode(e)\r\n    \t\tlet stopCellMove = false\r\n    \t\tconst evt: KeydownEvent = {\r\n    \t\t\tkeyCode,\r\n    \t\t\tevent: e,\r\n    \t\t\tstopCellMoving() {\r\n    \t\t\t\tstopCellMove = true\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tthis.fireListeners('keydown', evt)\r\n\r\n    \t\tif (!input.readOnly && lastInputValue) {\r\n    \t\t\t// for Safari\r\n    \t\t\tthis.fireListeners('input', lastInputValue)\r\n    \t\t}\r\n    \t\tif (!stopCellMove) {\r\n    \t\t\tthis.fireKeyDownMove(keyCode, e)\r\n    \t\t}\r\n    \t\tif (this._grid.keyboardOptions?.deleteCellValueOnDel && (keyCode === KEY_DEL || keyCode === KEY_BS)) {\r\n    \t\t\tthis.fireListeners('delete', e)\r\n    \t\t}\r\n\r\n    \t\tinputClear(true)\r\n    \t})\r\n    \thandler.on(input, 'keyup', (_e) => {\r\n    \t\tif (this._isComposition) {\r\n    \t\t\tif (this._compositionEnd) {\r\n    \t\t\t\thandleCompositionEnd()\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tinputClear(true)\r\n    \t})\r\n\r\n    \thandler.on(input, 'input', (e: InputEvent) => {\r\n    \t\tif (e.data === ' ' || e.data === '') {\r\n    \t\t\t// Since the full-width space cannot be determined on \"keypress\", it is processed by \"input\".\r\n    \t\t\tthis.fireListeners('input', e.data)\r\n    \t\t}\r\n    \t\tinputClear(true)\r\n    \t})\r\n    \tif (browser.IE) {\r\n    \t\thandler.on(document, 'keydown', (e) => {\r\n    \t\t\tif (e.target !== input) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\tconst keyCode = getKeyCode(e)\r\n    \t\t\tif (keyCode === KEY_ALPHA_C && e.ctrlKey) {\r\n    \t\t\t\t// When text is not selected copy-event is not emit, on IE.\r\n    \t\t\t\tsetSafeInputValue(input, 'dummy')\r\n    \t\t\t\tinput.select()\r\n    \t\t\t\tsetTimeout(() => {\r\n    \t\t\t\t\tsetSafeInputValue(input, '')\r\n    \t\t\t\t}, 100)\r\n    \t\t\t} else if (keyCode === KEY_ALPHA_V && e.ctrlKey) {\r\n    \t\t\t\t// When input is read-only paste-event is not emit, on IE.\r\n    \t\t\t\tif (input.readOnly) {\r\n    \t\t\t\t\tinput.readOnly = false\r\n    \t\t\t\t\tsetTimeout(() => {\r\n    \t\t\t\t\t\tinput.readOnly = true\r\n    \t\t\t\t\t\tsetSafeInputValue(input, '')\r\n    \t\t\t\t\t}, 10)\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t})\r\n    \t}\r\n    \tif (browser.Edge) {\r\n    \t\thandler.once(document, 'keydown', (e) => {\r\n    \t\t\tif (!isDescendantElement(parentElement, e.target as HTMLElement)) {\r\n    \t\t\t\treturn\r\n    \t\t\t}\r\n    \t\t\t// When the input has focus on the first page opening, the paste-event and copy-event is not emit, on Edge.\r\n    \t\t\tconst dummyInput = document.createElement('input')\r\n    \t\t\tgrid.getElement().appendChild(dummyInput)\r\n    \t\t\tdummyInput.focus()\r\n    \t\t\tinput.focus()\r\n    \t\t\tdummyInput.parentElement?.removeChild(dummyInput)\r\n    \t\t})\r\n    \t}\r\n    \thandler.on(document, 'paste', (e) => {\r\n    \t\tif (!isDescendantElement(parentElement, e.target)) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tlet pasteText: string | undefined = undefined\r\n    \t\tif (browser.IE) {\r\n    \t\t\t// IE\r\n    \t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t\tpasteText = (window as any).clipboardData.getData('Text')\r\n    \t\t} else {\r\n    \t\t\tconst { clipboardData } = e\r\n    \t\t\tif (clipboardData.items) {\r\n    \t\t\t\t// Chrome & Firefox & Edge\r\n    \t\t\t\tpasteText = clipboardData.getData('text/plain')\r\n    \t\t\t} else {\r\n    \t\t\t\t// Safari\r\n    \t\t\t\tif (-1 !== Array.prototype.indexOf.call(clipboardData.types, 'text/plain')) {\r\n    \t\t\t\t\tpasteText = clipboardData.getData('Text')\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tif (pasteText != null && pasteText.length) {\r\n    \t\t\tthis.fireListeners('paste', { value: pasteText, event: e })\r\n    \t\t}\r\n    \t})\r\n    \thandler.on(document, 'copy', (e) => {\r\n    \t\tif (this._isComposition) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tif (!isDescendantElement(parentElement, e.target)) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tsetSafeInputValue(input, '')\r\n    \t\tconst data = array.find(this.fireListeners('copy'), (r) => r != null)\r\n    \t\tif (data != null) {\r\n    \t\t\tcancelEvent(e)\r\n    \t\t\tif (browser.IE) {\r\n    \t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t\t\t(window as any).clipboardData.setData('Text', data) // IE\r\n    \t\t\t} else {\r\n    \t\t\t\te.clipboardData.setData('text/plain', data) // Chrome, Firefox\r\n    \t\t\t}\r\n    \t\t}\r\n    \t})\r\n    \thandler.on(input, 'focus', (e) => {\r\n    \t\tthis.fireListeners('focus', e)\r\n    \t})\r\n    \thandler.on(input, 'blur', (e) => {\r\n    \t\tthis.fireListeners('blur', e)\r\n    \t})\r\n    }\r\n\r\n    fireKeyDownMove(keyCode: number, e: KeyboardEvent): void {\r\n    \tconst fn = this._keyDownMoveCallback\r\n    \tif (!fn) {\r\n    \t\treturn\r\n    \t}\r\n    \tif (this._isComposition) {\r\n    \t\treturn\r\n    \t}\r\n    \tif (keyCode === KEY_LEFT || keyCode === KEY_UP || keyCode === KEY_RIGHT || keyCode === KEY_DOWN || keyCode === KEY_HOME || keyCode === KEY_END) {\r\n    \t\tfn(e)\r\n    \t} else if (this._grid.keyboardOptions?.moveCellOnTab && keyCode === KEY_TAB) {\r\n    \t\tfn(e)\r\n    \t} else if (this._grid.keyboardOptions?.moveCellOnEnter && keyCode === KEY_ENTER) {\r\n    \t\tfn(e)\r\n    \t} else if (this._grid.keyboardOptions?.selectAllOnCtrlA && keyCode === KEY_ALPHA_A && (e.ctrlKey || e.metaKey)) {\r\n    \t\tfn(e)\r\n    \t}\r\n    }\r\n\r\n    onKeyDownMove(fn: KeyboardEventListener): void {\r\n    \tthis._keyDownMoveCallback = fn\r\n    }\r\n\r\n    onKeyDown(fn: (e: KeydownEvent) => void): EventListenerId {\r\n    \treturn this.listen('keydown', fn)\r\n    }\r\n\r\n    onInput(fn: (value: string) => void): EventListenerId {\r\n    \treturn this.listen('input', fn)\r\n    }\r\n\r\n    onDelete(fn: (e: KeyboardEvent) => void): EventListenerId {\r\n    \treturn this.listen('delete', fn)\r\n    }\r\n\r\n    onCopy(fn: (e: ClipboardEvent) => void): EventListenerId {\r\n    \treturn this.listen('copy', fn)\r\n    }\r\n\r\n    onPaste(fn: (e: { value: string; event: ClipboardEvent }) => void): EventListenerId {\r\n    \treturn this.listen('paste', fn)\r\n    }\r\n\r\n    onFocus(fn: (e: FocusEvent) => void): EventListenerId {\r\n    \treturn this.listen('focus', fn)\r\n    }\r\n\r\n    onBlur(fn: (e: FocusEvent) => void): EventListenerId {\r\n    \treturn this.listen('blur', fn)\r\n    }\r\n\r\n    focus(): void {\r\n    \t// this._input.value = '';\r\n    \tthis._input.focus()\r\n    }\r\n\r\n    setFocusRect(rect: Rect): void {\r\n    \tconst input = this._input\r\n    \tconst top = this._scrollable.calcTop(rect.top)\r\n    \tinput.style.top = `${ (top - style.getScrollBarSize()).toFixed() }px` //position:relative IE position:relative\r\n    \tinput.style.left = `${ rect.left.toFixed() }px`\r\n    \tinput.style.width = `${ rect.width.toFixed() }px`\r\n    \tinput.style.height = `${ rect.height.toFixed() }px`\r\n    }\r\n\r\n    get editMode(): boolean {\r\n    \treturn !this._input.readOnly\r\n    }\r\n\r\n    set editMode(editMode: boolean) {\r\n    \tthis._input.readOnly = !editMode\r\n    }\r\n\r\n    resetInputStatus(): void {\r\n    \tconst el = this._input\r\n    \tif (!el.classList.contains('grid-focus-control--stored-status')) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst composition = el.classList.contains('composition')\r\n\r\n    \tconst atts = el.attributes\r\n    \tconst removeNames = []\r\n    \tfor (let i = 0, n = atts.length; i < n; i++) {\r\n    \t\tconst att = atts[i]\r\n    \t\tif (!this._inputStatus?.hasOwnProperty(att.nodeName)) {\r\n    \t\t\tremoveNames.push(att.name)\r\n    \t\t}\r\n    \t}\r\n    \tremoveNames.forEach((removeName) => {\r\n    \t\tel.removeAttribute(removeName)\r\n    \t})\r\n    \tfor (const name in this._inputStatus) {\r\n    \t\tel.setAttribute(name, this._inputStatus[name])\r\n    \t}\r\n    \tif (composition) {\r\n    \t\tel.classList.add('composition')\r\n    \t\tel.style.font = this._grid.font || '16px sans-serif'\r\n    \t} else {\r\n    \t\tel.classList.remove('composition')\r\n    \t}\r\n    \tel.classList.remove('grid-focus-control--stored-status')\r\n    }\r\n\r\n    storeInputStatus(): void {\r\n    \tconst el = this._input\r\n    \tif (el.classList.contains('grid-focus-control--stored-status')) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst inputStatus: FocusControl['_inputStatus'] = (this._inputStatus = {})\r\n    \tconst atts = el.attributes\r\n    \tfor (let i = 0, n = atts.length; i < n; i++) {\r\n    \t\tconst att = atts[i]\r\n    \t\tinputStatus[att.name] = att.value\r\n    \t}\r\n    \tel.classList.add('grid-focus-control--stored-status')\r\n    }\r\n\r\n    setDefaultInputStatus(): void {\r\n    \t// \r\n    \t// this._input.style.font = this._grid.font || '16px sans-serif';\r\n    }\r\n\r\n    get input(): HTMLInputElement {\r\n    \treturn this._input\r\n    }\r\n\r\n    dispose(): void {\r\n    \tsuper.dispose()\r\n    \tthis._handler.dispose()\r\n    }\r\n}\r\n\r\n/**\r\n * Selected area management\r\n */\r\nclass Selection extends EventTarget {\r\n    private _grid: DrawGrid\r\n\r\n    private _sel: CellAddress\r\n\r\n    private _focus: CellAddress\r\n\r\n    private _start: CellAddress\r\n\r\n    private _end: CellAddress\r\n\r\n    private _isWraped?: boolean\r\n\r\n    constructor(grid: DrawGrid) {\r\n    \tsuper()\r\n    \tthis._grid = grid\r\n\r\n    \tthis._sel = { col: 0, row: 0 }\r\n    \tthis._focus = { col: 0, row: 0 }\r\n\r\n    \tthis._start = { col: 0, row: 0 }\r\n    \tthis._end = { col: 0, row: 0 }\r\n    }\r\n\r\n    get range(): CellRange {\r\n    \tconst start = this._start\r\n    \tconst end = this._end\r\n    \tconst startCol = Math.min(start.col, end.col)\r\n    \tconst startRow = Math.min(start.row, end.row)\r\n    \tconst endCol = Math.max(start.col, end.col)\r\n    \tconst endRow = Math.max(start.row, end.row)\r\n    \treturn {\r\n    \t\tstart: {\r\n    \t\t\tcol: startCol,\r\n    \t\t\trow: startRow\r\n    \t\t},\r\n    \t\tend: {\r\n    \t\t\tcol: endCol,\r\n    \t\t\trow: endRow\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    set range(range) {\r\n    \tconst startCol = Math.min(range.start.col, range.end.col)\r\n    \tconst startRow = Math.min(range.start.row, range.end.row)\r\n    \tconst endCol = Math.max(range.start.col, range.end.col)\r\n    \tconst endRow = Math.max(range.start.row, range.end.row)\r\n\r\n    \tthis._wrapFireSelectedEvent(() => {\r\n    \t\tthis._sel = {\r\n    \t\t\tcol: startCol,\r\n    \t\t\trow: startRow\r\n    \t\t}\r\n    \t\tthis._focus = {\r\n    \t\t\tcol: startCol,\r\n    \t\t\trow: startRow\r\n    \t\t}\r\n    \t\tthis._start = {\r\n    \t\t\tcol: startCol,\r\n    \t\t\trow: startRow\r\n    \t\t}\r\n    \t\tthis._end = {\r\n    \t\t\tcol: endCol,\r\n    \t\t\trow: endRow\r\n    \t\t}\r\n\r\n    \t\t_updatedSelection.call(this._grid)\r\n    \t})\r\n    }\r\n\r\n    get focus(): CellAddress {\r\n    \tconst { col, row } = this._focus\r\n    \treturn { col, row }\r\n    }\r\n\r\n    get select(): CellAddress {\r\n    \tconst { col, row } = this._sel\r\n    \treturn { col, row }\r\n    }\r\n\r\n    set select(cell: CellAddress) {\r\n    \tthis._wrapFireSelectedEvent(() => {\r\n    \t\tconst { col = 0, row = 0 } = cell\r\n    \t\tthis._setSelectCell(col, row)\r\n    \t\tthis._setFocusCell(col, row, true)\r\n\r\n    \t\t_updatedSelection.call(this._grid)\r\n    \t})\r\n    }\r\n\r\n    _setSelectCell(col: number, row: number): void {\r\n    \tthis._wrapFireSelectedEvent(() => {\r\n    \t\tthis._sel = { col, row }\r\n    \t\tthis._start = { col, row }\r\n    \t})\r\n    }\r\n\r\n    _setFocusCell(col: number, row: number, keepSelect: boolean): void {\r\n    \tthis._wrapFireSelectedEvent(() => {\r\n    \t\tif (!keepSelect) {\r\n    \t\t\tthis._setSelectCell(col, row)\r\n    \t\t}\r\n    \t\tthis._focus = { col, row }\r\n    \t\tthis._end = { col, row }\r\n    \t})\r\n    }\r\n\r\n    _wrapFireSelectedEvent(callback: AnyFunction): void {\r\n    \tif (this._isWraped) {\r\n    \t\tcallback()\r\n    \t} else {\r\n    \t\tthis._isWraped = true\r\n    \t\ttry {\r\n    \t\t\tconst before: BeforeSelectedCellEvent = {\r\n    \t\t\t\tcol: this._sel.col,\r\n    \t\t\t\trow: this._sel.row,\r\n    \t\t\t\tselected: false,\r\n    \t\t\t\tafter: null as never\r\n    \t\t\t}\r\n    \t\t\tcallback()\r\n    \t\t\tconst after: AfterSelectedCellEvent = {\r\n    \t\t\t\tcol: this._sel.col,\r\n    \t\t\t\trow: this._sel.row,\r\n    \t\t\t\tselected: true,\r\n    \t\t\t\tbefore: {\r\n    \t\t\t\t\tcol: before.col,\r\n    \t\t\t\t\trow: before.row\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\tbefore.after = {\r\n    \t\t\t\tcol: after.col,\r\n    \t\t\t\trow: after.row\r\n    \t\t\t}\r\n    \t\t\tthis.fireListeners(DG_EVENT_TYPE.SELECTED_CELL, before)\r\n    \t\t\tthis.fireListeners(DG_EVENT_TYPE.SELECTED_CELL, after)\r\n    \t\t} finally {\r\n    \t\t\tthis._isWraped = false\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    _updateGridRange(): boolean {\r\n    \tconst { rowCount, colCount } = this._grid\r\n    \tconst points = [ this._sel, this._focus, this._start, this._end ]\r\n    \tlet needChange = false\r\n    \tfor (let i = 0; i < points.length; i++) {\r\n    \t\tif (colCount <= points[i].col || rowCount <= points[i].row) {\r\n    \t\t\tneedChange = true\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t}\r\n    \tif (!needChange) {\r\n    \t\treturn false\r\n    \t}\r\n    \tthis._wrapFireSelectedEvent(() => {\r\n    \t\tpoints.forEach((p) => {\r\n    \t\t\tp.col = Math.min(colCount - 1, p.col)\r\n    \t\t\tp.row = Math.min(rowCount - 1, p.row)\r\n    \t\t})\r\n    \t})\r\n    \treturn true\r\n    }\r\n}\r\n\r\n/** @private */\r\ntype DrawLayerFunction = (ctx: CanvasRenderingContext2D) => void;\r\n\r\n/**\r\n * This class manages the drawing process for each layer\r\n */\r\n/** @private */\r\nclass DrawLayers {\r\n    private _layers: { [level: number]: DrawLayer }\r\n\r\n    constructor() {\r\n    \tthis._layers = {}\r\n    }\r\n\r\n    addDraw(level: number, fn: DrawLayerFunction): void {\r\n    \tconst l = this._layers[level] || (this._layers[level] = new DrawLayer(level))\r\n    \tl.addDraw(fn)\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    \tconst list = []\r\n    \tfor (const k in this._layers) {\r\n    \t\tlist.push(this._layers[k])\r\n    \t}\r\n    \tlist.sort((a, b) => a.level - b.level)\r\n    \tlist.forEach((l) => l.draw(ctx))\r\n    }\r\n}\r\n\r\n/** @private */\r\nclass DrawLayer {\r\n    private _level: number\r\n\r\n    private _list: DrawLayerFunction[]\r\n\r\n    constructor(level: number) {\r\n    \tthis._level = level\r\n    \tthis._list = []\r\n    }\r\n\r\n    get level(): number {\r\n    \treturn this._level\r\n    }\r\n\r\n    addDraw(fn: DrawLayerFunction): void {\r\n    \tthis._list.push(fn)\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D): void {\r\n    \tthis._list.forEach((fn) => {\r\n    \t\tctx.save()\r\n    \t\ttry {\r\n    \t\t\tfn(ctx)\r\n    \t\t} finally {\r\n    \t\t\tctx.restore()\r\n    \t\t}\r\n    \t})\r\n    }\r\n}\r\n\r\n/**\r\n * Context of cell drawing\r\n * @private\r\n */\r\nclass DrawCellContext implements CellContext {\r\n    private _col: number\r\n\r\n    private _row: number\r\n\r\n    private _mode: number\r\n\r\n    private _ctx: CanvasRenderingContext2D | null\r\n\r\n    private _rect: Rect | null\r\n\r\n    private _drawRect: Rect | null\r\n\r\n    private _drawing: boolean\r\n\r\n    private _selection: Selection\r\n\r\n    private _drawLayers: DrawLayers\r\n\r\n    private _childContexts: DrawCellContext[]\r\n\r\n    private _cancel?: boolean\r\n\r\n    private _grid?: DrawGrid\r\n\r\n    private _onTerminate?: () => void\r\n\r\n    private _rectFilter: ((base: Rect) => Rect) | null = null\r\n\r\n    //  private _grid: any;\r\n    //  private _onTerminate: any;\r\n    /**\r\n     * constructor\r\n     * @param {number} col index of column\r\n     * @param {number} row index of row\r\n     * @param {CanvasRenderingContext2D} ctx context\r\n     * @param {Rect} rect rect of cell area\r\n     * @param {Rect} drawRect rect of drawing area\r\n     * @param {boolean} drawing `true` if drawing is in progress\r\n     * @param {object} selection the selection\r\n     * @param {Array} drawLayers array of draw layers\r\n     * @private\r\n     */\r\n    constructor(col: number, row: number, ctx: CanvasRenderingContext2D, rect: Rect | null, drawRect: Rect | null, drawing: boolean, selection: Selection, drawLayers: DrawLayers) {\r\n    \tthis._col = col\r\n    \tthis._row = row\r\n    \tthis._mode = 0\r\n    \tthis._ctx = ctx\r\n    \tthis._rect = rect\r\n    \tthis._drawRect = drawRect\r\n    \tthis._drawing = drawing\r\n    \tthis._selection = selection\r\n    \tthis._drawLayers = drawLayers\r\n    \tthis._childContexts = []\r\n    }\r\n\r\n    get drawing(): boolean {\r\n    \tif (this._mode === 0) {\r\n    \t\treturn this._drawing\r\n    \t} else {\r\n    \t\treturn true\r\n    \t}\r\n    }\r\n\r\n    get row(): number {\r\n    \treturn this._row\r\n    }\r\n\r\n    get col(): number {\r\n    \treturn this._col\r\n    }\r\n\r\n    cancel(): void {\r\n    \tthis._cancel = true\r\n    \tthis._childContexts.forEach((ctx) => {\r\n    \t\tctx.cancel()\r\n    \t})\r\n    }\r\n\r\n    /**\r\n     * select status.\r\n     * @return {object} select status\r\n     */\r\n    getSelection(): { select: CellAddress; range: CellRange } {\r\n    \treturn {\r\n    \t\tselect: this._selection.select,\r\n    \t\trange: this._selection.range\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Canvas context.\r\n     * @return {CanvasRenderingContext2D} Canvas context.\r\n     */\r\n    getContext(): CanvasRenderingContext2D {\r\n    \tif (this._mode === 0) {\r\n    \t\treturn this._ctx!\r\n    \t} else {\r\n    \t\treturn _getInitContext.call(this._grid!)\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Rectangle of cell.\r\n     * @return {Rect} rect Rectangle of cell.\r\n     */\r\n    getRect(): Rect {\r\n    \tconst rectFilter = this._rectFilter\r\n    \treturn rectFilter ? rectFilter(this._getRectInternal()) : this._getRectInternal()\r\n    }\r\n\r\n    setRectFilter(rectFilter: (base: Rect) => Rect): void {\r\n    \tthis._rectFilter = rectFilter\r\n    }\r\n\r\n    /**\r\n     * Rectangle of Drawing range.\r\n     * @return {Rect} Rectangle of Drawing range.\r\n     */\r\n    getDrawRect(): Rect | null {\r\n    \tif (this._cancel) {\r\n    \t\treturn null\r\n    \t}\r\n    \tif (this._mode === 0) {\r\n    \t\treturn this._drawRect\r\n    \t} else {\r\n    \t\tif (this._isOutOfRange()) {\r\n    \t\t\treturn null\r\n    \t\t}\r\n\r\n    \t\tconst absoluteRect = this._grid!.getCellRect(this._col, this._row)\r\n    \t\treturn this._toRelativeDrawRect(absoluteRect)\r\n    \t}\r\n    }\r\n\r\n    private _isOutOfRange(): boolean {\r\n    \tconst { colCount, rowCount } = this._grid!\r\n    \treturn colCount <= this._col || rowCount <= this._row\r\n    }\r\n\r\n    /**\r\n     * get Context of current state\r\n     * @return {DrawCellContext} current DrawCellContext.\r\n     */\r\n    toCurrentContext(): DrawCellContext {\r\n    \tif (this._mode === 0) {\r\n    \t\treturn this\r\n    \t} else {\r\n    \t\tconst absoluteRect = this._grid!.getCellRect(this._col, this._row)\r\n    \t\tconst rect = _toRelativeRect(this._grid!, absoluteRect)\r\n    \t\tconst drawRect = this._isOutOfRange() ? null : this._toRelativeDrawRect(absoluteRect)\r\n    \t\tconst context = new DrawCellContext(this._col, this._row, this.getContext(), rect, drawRect, this.drawing, this._selection, this._drawLayers)\r\n    \t\t// toCurrentContext  toCurrentContext\r\n    \t\tcontext.toCurrentContext = this.toCurrentContext.bind(this)\r\n    \t\tthis._childContexts.push(context)\r\n    \t\tif (this._cancel) {\r\n    \t\t\tcontext.cancel()\r\n    \t\t}\r\n    \t\tcontext._rectFilter = this._rectFilter\r\n    \t\treturn context\r\n    \t}\r\n    }\r\n\r\n    addLayerDraw(level: number, fn: DrawLayerFunction): void {\r\n    \tthis._drawLayers.addDraw(level, fn)\r\n    }\r\n\r\n    private _toRelativeDrawRect(absoluteRect: Rect): Rect | null {\r\n    \tconst visibleRect = _getVisibleRect(this._grid!)\r\n    \tlet rect = absoluteRect.copy()\r\n    \tif (!rect.intersection(visibleRect)) {\r\n    \t\treturn null\r\n    \t}\r\n\r\n    \tconst grid = this._grid!\r\n\r\n    \tconst isFrozenCell = grid.isFrozenCell(this._col, this._row)\r\n    \tif (grid.frozenColCount >= 0 && (!isFrozenCell || !isFrozenCell.col)) {\r\n    \t\tconst fRect = grid.getCellRect(grid.frozenColCount - 1, this._row)\r\n    \t\trect = Rect.bounds(Math.max(rect.left, fRect.right), rect.top, rect.right, rect.bottom)\r\n    \t}\r\n    \tif (grid.frozenRowCount >= 0 && (!isFrozenCell || !isFrozenCell.row)) {\r\n    \t\tconst fRect = grid.getCellRect(this._col, grid.frozenRowCount - 1)\r\n    \t\trect = Rect.bounds(rect.left, Math.max(rect.top, fRect.bottom), rect.right, rect.bottom)\r\n    \t}\r\n\r\n    \tif (!rect.intersection(visibleRect)) {\r\n    \t\treturn null\r\n    \t}\r\n    \trect.offsetLeft(-visibleRect.left)\r\n    \trect.offsetTop(-visibleRect.top)\r\n\r\n    \treturn rect\r\n    }\r\n\r\n    _delayMode(grid: DrawGrid, onTerminate: () => void): void {\r\n    \tthis._mode = 1\r\n    \tthis._ctx = null\r\n    \tthis._rect = null\r\n    \tthis._drawRect = null\r\n    \tthis._grid = grid\r\n    \tthis._onTerminate = onTerminate\r\n    }\r\n\r\n    /**\r\n     * terminate\r\n     * @return {void}\r\n     */\r\n    terminate(): void {\r\n    \tif (this._mode !== 0) {\r\n    \t\tthis._onTerminate?.()\r\n    \t}\r\n    }\r\n\r\n    private _getRectInternal(): Rect {\r\n    \tif (this._mode === 0) {\r\n    \t\treturn this._rect!\r\n    \t} else {\r\n    \t\tif (this._rect) {\r\n    \t\t\treturn this._rect\r\n    \t\t}\r\n    \t\treturn this._grid!.getCellRelativeRect(this._col, this._row)\r\n    \t}\r\n    }\r\n}\r\n\r\n/** @protected */\r\ninterface DrawGridProtected {\r\n    element: HTMLElement;\r\n    scrollable: Scrollable;\r\n    handler: EventHandler;\r\n    selection: Selection;\r\n    focusControl: FocusControl;\r\n    canvas: HTMLCanvasElement;\r\n    context: CanvasRenderingContext2D;\r\n    rowCount: number;\r\n    colCount: number;\r\n    frozenColCount: number;\r\n    frozenRowCount: number;\r\n    defaultRowHeight: number;\r\n    defaultColWidth: string | number;\r\n    font?: string;\r\n    underlayBackgroundColor?: string;\r\n    keyboardOptions?: DrawGridKeyboardOptions;\r\n    disableColumnResize?: boolean;\r\n\r\n    rowHeightsMap: NumberMap<number>;\r\n    colWidthsMap: NumberMap<string | number>;\r\n    colWidthsLimit: {\r\n        [col: number]: {\r\n            max?: string | number;\r\n            min?: string | number;\r\n        };\r\n    };\r\n    calcWidthContext: {\r\n        _: DrawGridProtected;\r\n        full: number;\r\n        em: number;\r\n    };\r\n\r\n    columnResizer: ColumnResizer;\r\n    cellSelector: CellSelector;\r\n\r\n    drawCells: { [row: number]: { [col: number]: DrawCellContext } };\r\n    cellTextOverflows: { [at: string]: string };\r\n    focusedGrid: boolean;\r\n\r\n    config:\r\n        | {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        [name: string]: any;\r\n    }\r\n        | undefined;\r\n    scroll: {\r\n        left: number;\r\n        top: number;\r\n    };\r\n    disposables?: { dispose(): void }[] | null;\r\n}\r\n\r\nexport { DrawGridProtected }\r\n\r\nexport interface DrawGridConstructorOptions {\r\n    rowCount?: number;\r\n    colCount?: number;\r\n    frozenColCount?: number;\r\n    frozenRowCount?: number;\r\n    /**\r\n     * Default grid row height. default 40\r\n     */\r\n    defaultRowHeight?: number;\r\n    /**\r\n     * Default grid col width. default 80\r\n     */\r\n    defaultColWidth?: string | number;\r\n    font?: string;\r\n    underlayBackgroundColor?: string;\r\n    keyboardOptions?: DrawGridKeyboardOptions;\r\n    /**\r\n     * Canvas parent element\r\n     */\r\n    parentElement?: HTMLElement | null;\r\n    /**\r\n     * Disable column resizing\r\n     */\r\n    disableColumnResize?: boolean;\r\n}\r\n\r\n/** @private */\r\nconst protectedKey = _\r\n\r\n/**\r\n * DrawGrid\r\n * @classdesc cheetahGrid.core.DrawGrid\r\n * @memberof cheetahGrid.core\r\n */\r\nexport abstract class DrawGrid extends EventTarget implements DrawGridAPI {\r\n    protected [protectedKey]: DrawGridProtected\r\n\r\n    static get EVENT_TYPE(): typeof DG_EVENT_TYPE {\r\n    \treturn DG_EVENT_TYPE\r\n    }\r\n\r\n    constructor(options: DrawGridConstructorOptions = {}) {\r\n    \tsuper()\r\n    \tconst {\r\n    \t\trowCount = 10,\r\n    \t\tcolCount = 10,\r\n    \t\tfrozenColCount = 0,\r\n    \t\tfrozenRowCount = 0,\r\n    \t\tdefaultRowHeight = 40,\r\n    \t\tdefaultColWidth = 80,\r\n    \t\tfont,\r\n    \t\tunderlayBackgroundColor,\r\n    \t\tkeyboardOptions,\r\n    \t\tparentElement,\r\n    \t\tdisableColumnResize\r\n    \t} = options\r\n    \tconst protectedSpace = (this[_] = {} as DrawGridProtected)\r\n    \tstyle.initDocument()\r\n    \tprotectedSpace.element = createRootElement()\r\n    \tprotectedSpace.scrollable = new Scrollable()\r\n    \tprotectedSpace.handler = new EventHandler()\r\n    \tprotectedSpace.selection = new Selection(this)\r\n    \tprotectedSpace.focusControl = new FocusControl(this, protectedSpace.scrollable.getElement(), protectedSpace.scrollable)\r\n\r\n    \tprotectedSpace.canvas = hiDPI.transform(document.createElement('canvas'))\r\n    \tprotectedSpace.context = protectedSpace.canvas.getContext('2d', {\r\n    \t\talpha: false\r\n    \t})!\r\n\r\n    \tprotectedSpace.rowCount = rowCount\r\n    \tprotectedSpace.colCount = colCount\r\n    \tprotectedSpace.frozenColCount = frozenColCount\r\n    \tprotectedSpace.frozenRowCount = frozenRowCount\r\n\r\n    \tprotectedSpace.defaultRowHeight = defaultRowHeight\r\n    \tprotectedSpace.defaultColWidth = defaultColWidth\r\n\r\n    \tprotectedSpace.font = font\r\n    \tprotectedSpace.underlayBackgroundColor = underlayBackgroundColor\r\n\r\n    \tprotectedSpace.keyboardOptions = keyboardOptions\r\n    \tprotectedSpace.disableColumnResize = disableColumnResize\r\n\r\n    \t/////\r\n    \tprotectedSpace.rowHeightsMap = new NumberMap()\r\n    \tprotectedSpace.colWidthsMap = new NumberMap()\r\n    \tprotectedSpace.colWidthsLimit = {}\r\n    \tprotectedSpace.calcWidthContext = {\r\n    \t\t_: protectedSpace,\r\n    \t\tget full(): number {\r\n    \t\t\treturn this._.canvas.width\r\n    \t\t},\r\n    \t\tget em(): number {\r\n    \t\t\treturn getFontSize(this._.context, this._.font).width\r\n    \t\t}\r\n    \t}\r\n\r\n    \tprotectedSpace.columnResizer = new ColumnResizer(this)\r\n    \tprotectedSpace.cellSelector = new CellSelector(this)\r\n\r\n    \tprotectedSpace.drawCells = {}\r\n    \tprotectedSpace.cellTextOverflows = {}\r\n    \tprotectedSpace.focusedGrid = false\r\n\r\n    \tprotectedSpace.element.appendChild(protectedSpace.canvas)\r\n    \tprotectedSpace.element.appendChild(protectedSpace.scrollable.getElement())\r\n    \tprotectedSpace.scroll = {\r\n    \t\tleft: 0,\r\n    \t\ttop: 0\r\n    \t}\r\n    \tthis.updateScroll()\r\n    \tif (parentElement) {\r\n    \t\tparentElement.appendChild(protectedSpace.element)\r\n    \t\tthis.updateSize()\r\n    \t} else {\r\n    \t\tthis.updateSize()\r\n    \t}\r\n    \t_bindEvents.call(this)\r\n    \tthis.bindEventsInternal()\r\n    }\r\n\r\n    /**\r\n     * Get root element.\r\n     * @returns {HTMLElement} root element\r\n     */\r\n    getElement(): HTMLElement {\r\n    \treturn this[_].element\r\n    }\r\n\r\n    /**\r\n     * Get canvas element.\r\n     */\r\n    get canvas(): HTMLCanvasElement {\r\n    \treturn this[_].canvas\r\n    }\r\n\r\n    /**\r\n     * Focus the grid.\r\n     * @return {void}\r\n     */\r\n    focus(): void {\r\n    \tconst { col, row } = this[_].selection.select\r\n    \tthis.focusCell(col, row)\r\n    }\r\n\r\n    hasFocusGrid(): boolean {\r\n    \treturn this[_].focusedGrid\r\n    }\r\n\r\n    /**\r\n     * Get the selection instance.\r\n     */\r\n    get selection(): Selection {\r\n    \treturn this[_].selection\r\n    }\r\n\r\n    /**\r\n     * Get the number of rows.\r\n     */\r\n    get rowCount(): number {\r\n    \treturn this[_].rowCount\r\n    }\r\n\r\n    /**\r\n     * Set the number of rows.\r\n     */\r\n    set rowCount(rowCount: number) {\r\n    \tthis[_].rowCount = rowCount\r\n    \tthis.updateScroll()\r\n    \tif (this[_].selection._updateGridRange()) {\r\n    \t\tconst { col, row } = this[_].selection.focus\r\n    \t\tthis.makeVisibleCell(col, row)\r\n    \t\tthis.setFocusCursor(col, row)\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Get the number of columns.\r\n     */\r\n    get colCount(): number {\r\n    \treturn this[_].colCount\r\n    }\r\n\r\n    /**\r\n     * Set the number of columns.\r\n     */\r\n    set colCount(colCount: number) {\r\n    \tthis[_].colCount = colCount\r\n    \tthis.updateScroll()\r\n    \tif (this[_].selection._updateGridRange()) {\r\n    \t\tconst { col, row } = this[_].selection.focus\r\n    \t\tthis.makeVisibleCell(col, row)\r\n    \t\tthis.setFocusCursor(col, row)\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Get the number of frozen columns.\r\n     */\r\n    get frozenColCount(): number {\r\n    \treturn this[_].frozenColCount\r\n    }\r\n\r\n    /**\r\n     * Set the number of frozen columns.\r\n     */\r\n    set frozenColCount(frozenColCount: number) {\r\n    \tthis[_].frozenColCount = frozenColCount\r\n    }\r\n\r\n    /**\r\n     * Get the number of frozen rows.\r\n     */\r\n    get frozenRowCount(): number {\r\n    \treturn this[_].frozenRowCount\r\n    }\r\n\r\n    /**\r\n     * Set the number of frozen rows.\r\n     */\r\n    set frozenRowCount(frozenRowCount: number) {\r\n    \tthis[_].frozenRowCount = frozenRowCount\r\n    }\r\n\r\n    /**\r\n     * Get the default row height.\r\n     *\r\n     */\r\n    get defaultRowHeight(): number {\r\n    \treturn this[_].defaultRowHeight\r\n    }\r\n\r\n    /**\r\n     * Set the default row height.\r\n     */\r\n    set defaultRowHeight(defaultRowHeight: number) {\r\n    \tthis[_].defaultRowHeight = defaultRowHeight\r\n    }\r\n\r\n    /**\r\n     * Get the default column width.\r\n     */\r\n    get defaultColWidth(): string | number {\r\n    \treturn this[_].defaultColWidth\r\n    }\r\n\r\n    /**\r\n     * Set the default column width.\r\n     */\r\n    set defaultColWidth(defaultColWidth: string | number) {\r\n    \tthis[_].defaultColWidth = defaultColWidth\r\n    }\r\n\r\n    /**\r\n     * Get the font definition as a string.\r\n     */\r\n    get font(): string | undefined {\r\n    \treturn this[_].font\r\n    }\r\n\r\n    /**\r\n     * Set the font definition with the given string.\r\n     */\r\n    set font(font: string | undefined) {\r\n    \tthis[_].font = font\r\n    }\r\n\r\n    /**\r\n     * Get the background color of the underlay.\r\n     */\r\n    get underlayBackgroundColor(): string | undefined {\r\n    \treturn this[_].underlayBackgroundColor\r\n    }\r\n\r\n    /**\r\n     * Set the background color of the underlay.\r\n     */\r\n    set underlayBackgroundColor(underlayBackgroundColor: string | undefined) {\r\n    \tthis[_].underlayBackgroundColor = underlayBackgroundColor\r\n    }\r\n\r\n    get keyboardOptions(): DrawGridKeyboardOptions | null {\r\n    \treturn this[_].keyboardOptions ?? null\r\n    }\r\n\r\n    set keyboardOptions(keyboardOptions: DrawGridKeyboardOptions | null) {\r\n    \tthis[_].keyboardOptions = keyboardOptions ?? undefined\r\n    }\r\n\r\n    configure(name: 'fadeinWhenCallbackInPromise', value?: boolean): boolean;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    configure(name: string, value?: any): any {\r\n    \tconst cfg = this[_].config || (this[_].config = {})\r\n    \tif (value != null) {\r\n    \t\tcfg[name] = value\r\n    \t}\r\n    \treturn cfg[name]\r\n    }\r\n\r\n    /**\r\n     * Apply the changed size.\r\n     * @return {void}\r\n     */\r\n    updateSize(): void {\r\n    \t//\r\n    \tconst { canvas } = this[_]\r\n    \tcanvas.style.width = ''\r\n    \tcanvas.style.height = ''\r\n    \tconst width = Math.floor(canvas.offsetWidth || canvas.parentElement!.offsetWidth - style.getScrollBarSize() /*for legacy*/)\r\n    \tconst height = Math.floor(canvas.offsetHeight || canvas.parentElement!.offsetHeight - style.getScrollBarSize() /*for legacy*/)\r\n\r\n    \tcanvas.width = width\r\n    \tcanvas.height = height\r\n\r\n    \t//style\r\n    \tcanvas.style.width = `${ width }px`\r\n    \tcanvas.style.height = `${ height }px`\r\n\r\n    \tconst sel = this[_].selection.select\r\n    \tthis[_].focusControl.setFocusRect(this.getCellRect(sel.col, sel.row))\r\n    }\r\n\r\n    /**\r\n     * Apply the changed scroll size.\r\n     * @return {boolean} `true` if there was a change in the scroll size\r\n     */\r\n    updateScroll(): boolean {\r\n    \tconst { scrollable } = this[_]\r\n    \tconst newHeight = _getScrollHeight.call(this)\r\n    \tconst newWidth = _getScrollWidth(this)\r\n    \tif (newHeight === scrollable.scrollHeight && newWidth === scrollable.scrollWidth) {\r\n    \t\treturn false\r\n    \t}\r\n    \tscrollable.setScrollSize(newWidth, newHeight)\r\n    \tthis[_].scroll = {\r\n    \t\tleft: scrollable.scrollLeft,\r\n    \t\ttop: scrollable.scrollTop\r\n    \t}\r\n    \treturn true\r\n    }\r\n\r\n    /**\r\n     * Get the row height of the given the row index.\r\n     * @param  {number} row The row index\r\n     * @return {number} The row height\r\n     */\r\n    getRowHeight(row: number): number {\r\n    \treturn _getRowHeight.call(this, row)\r\n    }\r\n\r\n    /**\r\n     * Set the row height of the given the row index.\r\n     * @param  {number} row The row index\r\n     * @param  {number} height The row height\r\n     * @return {void}\r\n     */\r\n    setRowHeight(row: number, height: number): void {\r\n    \t_setRowHeight(this, row, height)\r\n    }\r\n\r\n    /**\r\n     * Get the column width of the given the column index.\r\n     * @param  {number} col The column index\r\n     * @return {number} The column width\r\n     */\r\n    getColWidth(col: number): number {\r\n    \treturn _getColWidth(this, col)\r\n    }\r\n\r\n    /**\r\n     * Set the column widtht of the given the column index.\r\n     * @param  {number} col The column index\r\n     * @param  {number} width The column width\r\n     * @return {void}\r\n     */\r\n    setColWidth(col: number, width: string | number): void {\r\n    \t_setColWidth(this, col, width)\r\n    }\r\n\r\n    /**\r\n     * Get the column max width of the given the column index.\r\n     * @param  {number} col The column index\r\n     * @return {number} The column max width\r\n     */\r\n    getMaxColWidth(col: number): string | number | undefined {\r\n    \tconst obj = this[_].colWidthsLimit[col]\r\n    \treturn (obj && obj.max) || undefined\r\n    }\r\n\r\n    /**\r\n     * Set the column max widtht of the given the column index.\r\n     * @param  {number} col The column index\r\n     * @param  {number} maxwidth The column max width\r\n     * @return {void}\r\n     */\r\n    setMaxColWidth(col: number, maxwidth: string | number): void {\r\n    \tconst obj = this[_].colWidthsLimit[col] || (this[_].colWidthsLimit[col] = {})\r\n    \tobj.max = maxwidth\r\n    }\r\n\r\n    /**\r\n     * Get the column min width of the given the column index.\r\n     * @param  {number} col The column index\r\n     * @return {number} The column min width\r\n     */\r\n    getMinColWidth(col: number): string | number | undefined {\r\n    \tconst obj = this[_].colWidthsLimit[col]\r\n    \treturn (obj && obj.min) || undefined\r\n    }\r\n\r\n    /**\r\n     * Set the column min widtht of the given the column index.\r\n     * @param  {number} col The column index\r\n     * @param  {number} minwidth The column min width\r\n     * @return {void}\r\n     */\r\n    setMinColWidth(col: number, minwidth: string | number): void {\r\n    \tconst obj = this[_].colWidthsLimit[col] || (this[_].colWidthsLimit[col] = {})\r\n    \tobj.min = minwidth\r\n    }\r\n\r\n    /**\r\n     * Get the rect of the cell.\r\n     * @param {number} col index of column, of the cell\r\n     * @param {number} row index of row, of the cell\r\n     * @returns {Rect} the rect of the cell.\r\n     */\r\n    getCellRect(col: number, row: number): Rect {\r\n    \tconst isFrozenCell = this.isFrozenCell(col, row)\r\n\r\n    \tlet absoluteLeft = _getColsWidth(this, 0, col - 1)\r\n    \tconst width = _getColWidth(this, col)\r\n    \tif (isFrozenCell && isFrozenCell.col) {\r\n    \t\tabsoluteLeft += this[_].scroll.left\r\n    \t}\r\n\r\n    \tlet absoluteTop = _getRowsHeight.call(this, 0, row - 1)\r\n    \tconst height = _getRowHeight.call(this, row)\r\n    \tif (isFrozenCell && isFrozenCell.row) {\r\n    \t\tabsoluteTop += this[_].scroll.top\r\n    \t}\r\n    \treturn new Rect(absoluteLeft, absoluteTop, width, height)\r\n    }\r\n\r\n    /**\r\n     * Get the relative rectangle of the cell.\r\n     * @param {number} col index of column, of the cell\r\n     * @param {number} row index of row, of the cell\r\n     * @returns {Rect} the rect of the cell.\r\n     */\r\n    getCellRelativeRect(col: number, row: number): Rect {\r\n    \treturn _toRelativeRect(this, this.getCellRect(col, row))\r\n    }\r\n\r\n    /**\r\n     * Get the rectangle of the cells area.\r\n     * @param {number} startCol index of the starting column, of the cell\r\n     * @param {number} startRow index of the starting row, of the cell\r\n     * @param {number} endCol index of the ending column, of the cell\r\n     * @param {number} endRow index of the ending row, of the cell\r\n     * @returns {Rect} the rect of the cells.\r\n     */\r\n    getCellsRect(startCol: number, startRow: number, endCol: number, endRow: number): Rect {\r\n    \tconst isFrozenStartCell = this.isFrozenCell(startCol, startRow)\r\n    \tconst isFrozenEndCell = this.isFrozenCell(endCol, endRow)\r\n\r\n    \tlet absoluteLeft = _getColsWidth(this, 0, startCol - 1)\r\n    \tlet width = _getColsWidth(this, startCol, endCol)\r\n    \tif (isFrozenStartCell && isFrozenStartCell.col) {\r\n    \t\tconst scrollLeft = this[_].scroll.left\r\n    \t\tabsoluteLeft += scrollLeft\r\n    \t\tif (!isFrozenEndCell || !isFrozenEndCell.col) {\r\n    \t\t\twidth -= scrollLeft\r\n    \t\t\twidth = Math.max(width, _getColsWidth(this, startCol, this.frozenColCount - 1))\r\n    \t\t}\r\n    \t}\r\n    \tlet absoluteTop = _getRowsHeight.call(this, 0, startRow - 1)\r\n    \tlet height = _getRowsHeight.call(this, startRow, endRow)\r\n    \tif (isFrozenStartCell && isFrozenStartCell.row) {\r\n    \t\tconst scrollTop = this[_].scroll.top\r\n    \t\tabsoluteTop += scrollTop\r\n    \t\tif (!isFrozenEndCell || !isFrozenEndCell.row) {\r\n    \t\t\theight -= scrollTop\r\n    \t\t\theight = Math.max(height, _getColsWidth(this, startRow, this.frozenRowCount - 1))\r\n    \t\t}\r\n    \t}\r\n    \treturn new Rect(absoluteLeft, absoluteTop, width, height)\r\n    }\r\n\r\n    getCellRangeRect(range: CellRange): Rect {\r\n    \treturn this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row)\r\n    }\r\n\r\n    isFrozenCell(\r\n    \t\tcol: number,\r\n    \t\trow: number\r\n    ): {\r\n        row: boolean;\r\n        col: boolean;\r\n    } | null {\r\n    \tconst { frozenRowCount, frozenColCount } = this[_]\r\n    \tconst isFrozenRow = frozenRowCount > 0 && row < frozenRowCount\r\n    \tconst isFrozenCol = frozenColCount > 0 && col < frozenColCount\r\n    \tif (isFrozenRow || isFrozenCol) {\r\n    \t\treturn {\r\n    \t\t\trow: isFrozenRow,\r\n    \t\t\tcol: isFrozenCol\r\n    \t\t}\r\n    \t} else {\r\n    \t\treturn null\r\n    \t}\r\n    }\r\n\r\n    getRowAt(absoluteY: number): number {\r\n    \tconst frozen = _getTargetFrozenRowAt(this, absoluteY)\r\n    \tif (frozen) {\r\n    \t\treturn frozen.row\r\n    \t}\r\n    \tconst row = _getTargetRowAt.call(this, absoluteY)\r\n    \treturn row ? row.row : -1\r\n    }\r\n\r\n    getColAt(absoluteX: number): number {\r\n    \tconst frozen = _getTargetFrozenColAt(this, absoluteX)\r\n    \tif (frozen) {\r\n    \t\treturn frozen.col\r\n    \t}\r\n    \tconst col = _getTargetColAt(this, absoluteX)\r\n    \treturn col ? col.col : -1\r\n    }\r\n\r\n    getCellAt(absoluteX: number, absoluteY: number): CellAddress {\r\n    \treturn {\r\n    \t\trow: this.getRowAt(absoluteY),\r\n    \t\tcol: this.getColAt(absoluteX)\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Scroll to where cell is visible.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index\r\n     * @return {void}\r\n     */\r\n    makeVisibleCell(col: number, row: number): void {\r\n    \tconst isFrozenCell = this.isFrozenCell(col, row)\r\n    \tif (isFrozenCell && isFrozenCell.col && isFrozenCell.row) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst rect = this.getCellRect(col, row)\r\n    \tconst visibleRect = _getScrollableVisibleRect(this)\r\n    \tif (visibleRect.contains(rect)) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst { scrollable } = this[_]\r\n    \tif (!isFrozenCell || !isFrozenCell.col) {\r\n    \t\tif (rect.left < visibleRect.left) {\r\n    \t\t\tscrollable.scrollLeft -= visibleRect.left - rect.left\r\n    \t\t} else if (visibleRect.right < rect.right) {\r\n    \t\t\tscrollable.scrollLeft -= visibleRect.right - rect.right\r\n    \t\t}\r\n    \t}\r\n    \tif (!isFrozenCell || !isFrozenCell.row) {\r\n    \t\tif (rect.top < visibleRect.top) {\r\n    \t\t\tscrollable.scrollTop -= visibleRect.top - rect.top\r\n    \t\t} else if (visibleRect.bottom < rect.bottom) {\r\n    \t\t\tscrollable.scrollTop -= visibleRect.bottom - rect.bottom\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Moves the focus cursor to the given cell.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index\r\n     * @return {void}\r\n     */\r\n    setFocusCursor(col: number, row: number): void {\r\n    \tconst { focusControl } = this[_]\r\n    \tconst oldEditMode = focusControl.editMode\r\n\r\n    \tfocusControl.setFocusRect(this.getCellRect(col, row))\r\n\r\n    \t_updatedSelection.call(this)\r\n\r\n    \tif (oldEditMode && !focusControl.editMode) {\r\n    \t\tfocusControl.resetInputStatus()\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * Focus the cell.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index\r\n     * @return {void}\r\n     */\r\n    focusCell(col: number, row: number): void {\r\n    \tthis.setFocusCursor(col, row)\r\n\r\n    \t// Failure occurs in IE if focus is not last\r\n    \tthis[_].focusControl.focus()\r\n    }\r\n\r\n    /**\r\n     * Redraws the range of the given cell.\r\n     * @param  {number} col The column index of cell.\r\n     * @param  {number} row The row index of cell.\r\n     * @return {void}\r\n     */\r\n    invalidateCell(col: number, row: number): void {\r\n    \tthis.invalidateGridRect(col, row)\r\n    }\r\n\r\n    /**\r\n     * Redraws the range of the given cells.\r\n     * @param {number} startCol index of the starting column, of the cell\r\n     * @param {number} startRow index of the starting row, of the cell\r\n     * @param {number} endCol index of the ending column, of the cell\r\n     * @param {number} endRow index of the ending row, of the cell\r\n     * @return {void}\r\n     */\r\n    invalidateGridRect(startCol: number, startRow: number, endCol = startCol, endRow = startRow): void {\r\n    \tconst offset = this.getOffsetInvalidateCells()\r\n    \tif (offset > 0) {\r\n    \t\tstartCol -= offset\r\n    \t\tstartRow -= offset\r\n    \t\tendCol += offset\r\n    \t\tendRow += offset\r\n    \t}\r\n\r\n    \tconst visibleRect = _getVisibleRect(this)\r\n    \tconst cellsRect = this.getCellsRect(startCol, startRow, endCol, endRow)\r\n    \tconst invalidateTarget = visibleRect.intersection(cellsRect)\r\n    \tif (invalidateTarget) {\r\n    \t\tconst { frozenColCount, frozenRowCount } = this[_]\r\n    \t\tif (frozenColCount > 0 && endCol >= frozenColCount) {\r\n    \t\t\tconst frozenRect = _getFrozenColsRect(this)!\r\n    \t\t\tif (frozenRect.intersection(invalidateTarget)) {\r\n    \t\t\t\tinvalidateTarget.left = Math.min(frozenRect.right - 1, invalidateTarget.left)\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\tif (frozenRowCount > 0 && endRow >= frozenRowCount) {\r\n    \t\t\tconst frozenRect = _getFrozenRowsRect(this)!\r\n    \t\t\tif (frozenRect.intersection(invalidateTarget)) {\r\n    \t\t\t\tinvalidateTarget.top = Math.min(frozenRect.bottom - 1, invalidateTarget.top)\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\t_invalidateRect(this, invalidateTarget)\r\n    \t}\r\n    }\r\n\r\n    invalidateCellRange(range: CellRange): void {\r\n    \tthis.invalidateGridRect(range.start.col, range.start.row, range.end.col, range.end.row)\r\n    }\r\n\r\n    /**\r\n     * Redraws the whole grid.\r\n     * @return {void}\r\n     */\r\n    invalidate(): void {\r\n    \tconst visibleRect = _getVisibleRect(this)\r\n    \t_invalidateRect(this, visibleRect)\r\n    }\r\n\r\n    /**\r\n     * Get the number of scrollable rows fully visible in the grid. visibleRowCount does not include the frozen rows counted by the frozenRowCount property. It does not include any partially visible rows on the bottom of the grid.\r\n     * @returns {number}\r\n     */\r\n    get visibleRowCount(): number {\r\n    \tconst { frozenRowCount } = this\r\n    \tconst visibleRect = _getVisibleRect(this)\r\n    \tconst visibleTop = frozenRowCount > 0 ? visibleRect.top + _getRowsHeight.call(this, 0, frozenRowCount - 1) : visibleRect.top\r\n\r\n    \tconst initRow = _getTargetRowAt.call(this, visibleTop)\r\n    \tif (!initRow) {\r\n    \t\treturn 0\r\n    \t}\r\n    \tconst startRow = Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount)\r\n    \tlet absoluteTop = _getRowsHeight.call(this, 0, startRow - 1)\r\n    \tlet count = 0\r\n    \tconst { rowCount } = this\r\n    \tfor (let row = startRow; row < rowCount; row++) {\r\n    \t\tconst height = _getRowHeight.call(this, row)\r\n    \t\tconst bottom = absoluteTop + height\r\n    \t\tif (visibleRect.bottom < bottom) {\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t\tcount++\r\n    \t\tabsoluteTop = bottom\r\n    \t}\r\n    \treturn count\r\n    }\r\n\r\n    /**\r\n     * Get the number of scrollable columns fully visible in the grid. visibleColCount does not include the frozen columns counted by the frozenColCount property. It does not include any partially visible columns on the right of the grid.\r\n     * @returns {number}\r\n     */\r\n    get visibleColCount(): number {\r\n    \tconst { frozenColCount } = this\r\n    \tconst visibleRect = _getVisibleRect(this)\r\n    \tconst visibleLeft = frozenColCount > 0 ? visibleRect.left + _getColsWidth(this, 0, frozenColCount - 1) : visibleRect.left\r\n\r\n    \tconst initCol = _getTargetColAt(this, visibleLeft)\r\n    \tif (!initCol) {\r\n    \t\treturn 0\r\n    \t}\r\n    \tconst startCol = Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount)\r\n    \tlet absoluteLeft = _getColsWidth(this, 0, startCol - 1)\r\n    \tlet count = 0\r\n    \tconst { colCount } = this\r\n    \tfor (let col = startCol; col < colCount; col++) {\r\n    \t\tconst width = _getColWidth(this, col)\r\n    \t\tconst right = absoluteLeft + width\r\n    \t\tif (visibleRect.right < right) {\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t\tcount++\r\n    \t\tabsoluteLeft = right\r\n    \t}\r\n    \treturn count\r\n    }\r\n\r\n    /**\r\n     * Get the index of the first row in the scrollable region that is visible.\r\n     * @returns {number}\r\n     */\r\n    get topRow(): number {\r\n    \tconst { frozenRowCount } = this\r\n    \tconst visibleRect = _getVisibleRect(this)\r\n    \tconst visibleTop = frozenRowCount > 0 ? visibleRect.top + _getRowsHeight.call(this, 0, frozenRowCount - 1) : visibleRect.top\r\n\r\n    \tconst initRow = _getTargetRowAt.call(this, visibleTop)\r\n    \tif (!initRow) {\r\n    \t\treturn 0\r\n    \t}\r\n    \treturn Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount)\r\n    }\r\n\r\n    /**\r\n     * Get the index of the first column in the scrollable region that is visible.\r\n     * @returns {number}\r\n     */\r\n    get leftCol(): number {\r\n    \tconst { frozenColCount } = this\r\n    \tconst visibleRect = _getVisibleRect(this)\r\n    \tconst visibleLeft = frozenColCount > 0 ? visibleRect.left + _getColsWidth(this, 0, frozenColCount - 1) : visibleRect.left\r\n\r\n    \tconst initCol = _getTargetColAt(this, visibleLeft)\r\n    \tif (!initCol) {\r\n    \t\treturn 0\r\n    \t}\r\n    \treturn Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount)\r\n    }\r\n\r\n    /**\r\n     * gets or sets the number of pixels that an element's content is scrolled vertically\r\n     */\r\n    get scrollTop(): number {\r\n    \treturn this[_].scrollable.scrollTop\r\n    }\r\n\r\n    set scrollTop(scrollTop: number) {\r\n    \tthis[_].scrollable.scrollTop = scrollTop\r\n    }\r\n\r\n    /**\r\n     * gets or sets the number of pixels that an element's content is scrolled from its left edge\r\n     */\r\n    get scrollLeft(): number {\r\n    \treturn this[_].scrollable.scrollLeft\r\n    }\r\n\r\n    set scrollLeft(scrollLeft: number) {\r\n    \tthis[_].scrollable.scrollLeft = scrollLeft\r\n    }\r\n\r\n    /**\r\n     * Get the value of cell with the copy action.\r\n     * <p>\r\n     * Please implement\r\n     * </p>\r\n     *\r\n     * @protected\r\n     * @param col Column index of cell.\r\n     * @param row Row index of cell.\r\n     * @param range Copy range.\r\n     * @return {string} the value of cell\r\n     */\r\n    protected getCopyCellValue(_col: number, _row: number, _range: CellRange): string | Promise<string> | void {\r\n    \t//Please implement get cell value!!\r\n    }\r\n\r\n    /**\r\n     * Draw a cell\r\n     * <p>\r\n     * Please implement cell drawing.\r\n     * </p>\r\n     *\r\n     * @protected\r\n     * @param  {number} col Column index of cell.\r\n     * @param  {number} row Row index of cell.\r\n     * @param  {DrawCellContext} context context of cell drawing.\r\n     * @return {void}\r\n     */\r\n    protected abstract onDrawCell(col: number, row: number, context: CellContext): Promise<void> | void;\r\n\r\n    /**\r\n     * Get the overflowed text in the cell rectangle, from the given cell.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index\r\n     * @return {string | null} The text overflowing the cell rect.\r\n     */\r\n    getCellOverflowText(col: number, row: number): string | null {\r\n    \tconst key = `${ col }:${ row }`\r\n    \treturn this[_].cellTextOverflows[key] || null\r\n    }\r\n\r\n    /**\r\n     * Set the overflowed text in the cell rectangle, to the given cell.\r\n     * @param  {number} col The column index.\r\n     * @param  {number} row The row index\r\n     * @param  {string} overflowText The overflowed text in the cell rectangle.\r\n     * @return {void}\r\n     */\r\n    setCellOverflowText(col: number, row: number, overflowText: string | false): void {\r\n    \tconst key = `${ col }:${ row }`\r\n    \tif (overflowText) {\r\n    \t\tthis[_].cellTextOverflows[key] = typeof overflowText === 'string' ? overflowText.trim() : overflowText\r\n    \t} else {\r\n    \t\tdelete this[_].cellTextOverflows[key]\r\n    \t}\r\n    }\r\n\r\n    addDisposable(disposable: { dispose(): void }): void {\r\n    \tif (!disposable || !disposable.dispose || typeof disposable.dispose !== 'function') {\r\n    \t\tthrow new Error('not disposable!')\r\n    \t}\r\n    \tconst disposables = (this[_].disposables = this[_].disposables || [])\r\n    \tdisposables.push(disposable)\r\n    }\r\n\r\n    /**\r\n     * Dispose the grid instance.\r\n     * @returns {void}\r\n     */\r\n    dispose(): void {\r\n    \tsuper.dispose()\r\n    \tconst protectedSpace = this[_]\r\n    \tprotectedSpace.handler.dispose()\r\n    \tprotectedSpace.scrollable.dispose()\r\n    \tprotectedSpace.focusControl.dispose()\r\n    \tprotectedSpace.columnResizer.dispose()\r\n    \tprotectedSpace.cellSelector.dispose()\r\n    \tif (protectedSpace.disposables) {\r\n    \t\tprotectedSpace.disposables.forEach((disposable) => disposable.dispose())\r\n    \t\tprotectedSpace.disposables = null\r\n    \t}\r\n\r\n    \tconst { parentElement } = protectedSpace.element\r\n    \tif (parentElement) {\r\n    \t\tparentElement.removeChild(protectedSpace.element)\r\n    \t}\r\n    }\r\n\r\n    getAttachCellsArea(range: CellRange): {\r\n        element: HTMLElement;\r\n        rect: Rect;\r\n    } {\r\n    \treturn {\r\n    \t\telement: this.getElement(),\r\n    \t\trect: _toRelativeRect(this, this.getCellRangeRect(range))\r\n    \t}\r\n    }\r\n\r\n    onKeyDownMove(evt: KeyboardEvent): void {\r\n    \t_onKeyDownMove.call(this, evt)\r\n    }\r\n\r\n    protected bindEventsInternal(): void {\r\n    \t//nop\r\n    }\r\n\r\n    protected getTargetRowAtInternal(_absoluteY: number): { row: number; top: number } | void {\r\n    \t// \r\n    }\r\n\r\n    protected getRowsHeightInternal(_startRow: number, _endRow: number): number | void {\r\n    \t// \r\n    }\r\n\r\n    protected getRowHeightInternal(_row: number): number | void {\r\n    \t// \r\n    }\r\n\r\n    protected getScrollHeightInternal(_row?: number): number | void {\r\n    \t// \r\n    }\r\n\r\n    protected getMoveLeftColByKeyDownInternal({ col }: CellAddress): number {\r\n    \treturn col - 1\r\n    }\r\n\r\n    protected getMoveRightColByKeyDownInternal({ col }: CellAddress): number {\r\n    \treturn col + 1\r\n    }\r\n\r\n    protected getMoveUpRowByKeyDownInternal({ row }: CellAddress): number {\r\n    \treturn row - 1\r\n    }\r\n\r\n    protected getMoveDownRowByKeyDownInternal({ row }: CellAddress): number {\r\n    \treturn row + 1\r\n    }\r\n\r\n    protected getOffsetInvalidateCells(): number {\r\n    \treturn 0\r\n    }\r\n\r\n    protected getCopyRangeInternal(range: CellRange): CellRange {\r\n    \treturn range\r\n    }\r\n\r\n    protected _getInitContext(): CanvasRenderingContext2D {\r\n    \tconst ctx = this[_].context\r\n    \t//\r\n    \tctx.fillStyle = 'white'\r\n    \tctx.strokeStyle = 'black'\r\n    \tctx.textAlign = 'left'\r\n    \tctx.textBaseline = 'top'\r\n    \tctx.lineWidth = 1\r\n    \tctx.font = this.font || '16px sans-serif'\r\n    \treturn ctx\r\n    }\r\n\r\n    fireListeners<TYPE extends keyof DrawGridEventHandlersEventMap>(type: TYPE, ...event: DrawGridEventHandlersEventMap[TYPE]): DrawGridEventHandlersReturnMap[TYPE][] {\r\n    \treturn super.fireListeners(type, ...event)\r\n    }\r\n}\r\n","import type { AnyListener, EventListenerId } from '../ts-types'\r\nimport { each } from '../internal/utils'\r\nimport { get as getSymbol } from '../internal/symbolManager'\r\n\r\n//private symbol\r\n/** @private */\r\nconst _ = getSymbol()\r\n\r\n/** @private */\r\nlet nextId = 1\r\n\r\n/**\r\n * event target.\r\n */\r\nexport class EventTarget {\r\n    private [_]: {\r\n        listeners: { [type: string]: AnyListener[] };\r\n        listenerData: {\r\n            [id: number]: {\r\n                type: string;\r\n                listener: AnyListener;\r\n                remove: () => void;\r\n            };\r\n        };\r\n    } = {\r\n    \tlisteners: {},\r\n    \tlistenerData: {}\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener.\r\n     * @param  {string} type The event type id.\r\n     * @param  {function} listener Callback method.\r\n     * @return {number} unique id for the listener.\r\n     */\r\n    listen(type: string, listener: AnyListener): EventListenerId {\r\n    \tconst list = this[_].listeners[type] || (this[_].listeners[type] = [])\r\n    \tlist.push(listener)\r\n\r\n    \tconst id = nextId++\r\n    \tthis[_].listenerData[id] = {\r\n    \t\ttype,\r\n    \t\tlistener,\r\n    \t\tremove: (): void => {\r\n    \t\t\tdelete this[_].listenerData[id]\r\n    \t\t\tconst index = list.indexOf(listener)\r\n    \t\t\tlist.splice(index, 1)\r\n    \t\t\tif (!this[_].listeners[type].length) {\r\n    \t\t\t\tdelete this[_].listeners[type]\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn id\r\n    }\r\n\r\n    /**\r\n     * Removes an event listener which was added with listen() by the id returned by listen().\r\n     * @param  {number} id the id returned by listen().\r\n     * @return {void}\r\n     */\r\n    unlisten(id: EventListenerId): void {\r\n    \tif (!this[_]) {\r\n    \t\treturn\r\n    \t}\r\n    \tthis[_].listenerData[id].remove()\r\n    }\r\n\r\n    addEventListener(type: string, listener: AnyListener): void {\r\n    \tthis.listen(type, listener)\r\n    }\r\n\r\n    removeEventListener(type: string, listener: AnyListener): void {\r\n    \tif (!this[_]) {\r\n    \t\treturn\r\n    \t}\r\n    \teach(this[_].listenerData, (obj, id) => {\r\n    \t\tif (obj.type === type && obj.listener === listener) {\r\n    \t\t\tthis.unlisten(id)\r\n    \t\t}\r\n    \t})\r\n    }\r\n\r\n    hasListeners(type: string): boolean {\r\n    \tif (!this[_]) {\r\n    \t\treturn false\r\n    \t}\r\n    \treturn !!this[_].listeners[type]\r\n    }\r\n\r\n    /**\r\n     * Fires all registered listeners\r\n     * @param  {string}    type The type of the listeners to fire.\r\n     * @param  {...*} args fire arguments\r\n     * @return {*} the result of the last listener\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    fireListeners(type: string, ...args: any[]): any {\r\n    \tif (!this[_]) {\r\n    \t\treturn []\r\n    \t}\r\n    \tconst list = this[_].listeners[type]\r\n    \tif (!list) {\r\n    \t\treturn []\r\n    \t}\r\n    \treturn list.map((listener) => listener.call(this, ...args)).filter((r) => r != null)\r\n    }\r\n\r\n    dispose(): void {\r\n    \tdelete this[_]\r\n    }\r\n}\r\n","import { DataSource } from './data/DataSource'\r\nimport { CachedDataSource } from './data/CachedDataSource'\r\nimport { FilterDataSource } from './data/FilterDataSource'\r\n\r\n/**\r\n * data modules\r\n */\r\nexport const data = {\r\n\tDataSource,\r\n\tCachedDataSource,\r\n\tFilterDataSource\r\n}\r\n","import type { FieldData, FieldDef, MaybePromise, MaybePromiseOrUndef } from '../ts-types'\r\nimport { DataSource } from './DataSource'\r\nimport type { DataSourceParam } from './DataSource'\r\nimport type { PromiseCacheValue } from './internal/types'\r\n\r\n/** @private */\r\nfunction _setFieldCache<T, F extends FieldDef<T>>(\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tfCache: { [index: number]: Map<FieldDef<T>, any> },\r\n\t\tindex: number,\r\n\t\tfield: F,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tvalue: PromiseCacheValue<any>\r\n): void {\r\n\tconst recCache = fCache[index] || (fCache[index] = new Map())\r\n\trecCache.set(field, value)\r\n}\r\n\r\n/**\r\n * grid data source for caching Promise data\r\n *\r\n * @classdesc cheetahGrid.data.CachedDataSource\r\n * @memberof cheetahGrid.data\r\n */\r\nexport class CachedDataSource<T> extends DataSource<T> {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private _rCache: { [index: number]: any }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private _fCache: { [index: number]: Map<FieldDef<T>, any> }\r\n\r\n    static get EVENT_TYPE(): typeof DataSource.EVENT_TYPE {\r\n    \treturn DataSource.EVENT_TYPE\r\n    }\r\n\r\n    static ofArray<T>(array: T[]): CachedDataSource<T> {\r\n    \treturn new CachedDataSource({\r\n    \t\tget: (index: number): T => array[index],\r\n    \t\tlength: array.length,\r\n    \t\tsource: array\r\n    \t})\r\n    }\r\n\r\n    constructor(opt?: DataSourceParam<T>) {\r\n    \tsuper(opt)\r\n    \tthis._rCache = {}\r\n    \tthis._fCache = {}\r\n    }\r\n\r\n    protected getOriginal(index: number): MaybePromiseOrUndef<T> {\r\n    \tif (this._rCache && this._rCache[index]) {\r\n    \t\treturn this._rCache[index]\r\n    \t}\r\n    \treturn super.getOriginal(index)\r\n    }\r\n\r\n    protected getOriginalField<F extends FieldDef<T>>(index: number, field: F): FieldData {\r\n    \tconst rowCache = this._fCache && this._fCache[index]\r\n    \tif (rowCache) {\r\n    \t\tconst cache = rowCache.get(field)\r\n    \t\tif (cache) {\r\n    \t\t\treturn cache\r\n    \t\t}\r\n    \t}\r\n    \treturn super.getOriginalField(index, field)\r\n    }\r\n\r\n    protected setOriginalField<F extends FieldDef<T>>(\r\n    \t\tindex: number,\r\n    \t\tfield: F,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tvalue: any\r\n    ): MaybePromise<boolean> {\r\n    \tconst fCache = this._fCache\r\n    \tif (fCache && fCache[index]) {\r\n    \t\tdelete fCache[index] // clear row cache\r\n    \t}\r\n    \treturn super.setOriginalField(index, field, value)\r\n    }\r\n\r\n    clearCache(): void {\r\n    \tif (this._rCache) {\r\n    \t\tthis._rCache = {}\r\n    \t}\r\n    \tif (this._fCache) {\r\n    \t\tthis._fCache = {}\r\n    \t}\r\n    }\r\n\r\n    protected fieldPromiseCallBackInternal<F extends FieldDef<T>>(\r\n    \t\tindex: number,\r\n    \t\tfield: F,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tvalue: PromiseCacheValue<any>\r\n    ): void {\r\n    \t_setFieldCache(this._fCache, index, field, value)\r\n    }\r\n\r\n    protected recordPromiseCallBackInternal(\r\n    \t\tindex: number,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\trecord: PromiseCacheValue<T>\r\n    ): void {\r\n    \tthis._rCache[index] = record\r\n    }\r\n\r\n    dispose(): void {\r\n    \tsuper.dispose()\r\n    }\r\n}\r\n","import * as sort from '../internal/sort'\r\nimport type { DataSourceAPI, FieldAssessor, FieldData, FieldDef, MaybePromise, MaybePromiseOrCall, MaybePromiseOrCallOrUndef, MaybePromiseOrUndef } from '../ts-types'\r\nimport { applyChainSafe, array, emptyFn, getOrApply, isPromise, obj } from '../internal/utils'\r\nimport { EventTarget } from '../core/EventTarget'\r\nimport type { PromiseCacheValue } from './internal/types'\r\n\r\n/** @private */\r\nfunction isFieldAssessor<T>(field: FieldDef<T>): field is FieldAssessor<T> {\r\n\tif (obj.isObject(field)) {\r\n\t\tif ((field as FieldAssessor<T>).get && (field as FieldAssessor<T>).set) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r\n\r\n/** @private */\r\nconst EVENT_TYPE = {\r\n\tUPDATE_LENGTH: 'update_length',\r\n\tUPDATED_LENGTH: 'updated_length',\r\n\tUPDATED_ORDER: 'updated_order'\r\n} as const\r\n\r\n/** @private */\r\ntype PromiseBack<V> = (value: PromiseCacheValue<V>) => void;\r\n\r\n/** @private */\r\nfunction getValue<V>(value: MaybePromiseOrCallOrUndef<V, []>, setPromiseBack: PromiseBack<V>): MaybePromiseOrUndef<V> {\r\n\tconst maybePromiseValue = getOrApply(value)\r\n\tif (isPromise(maybePromiseValue)) {\r\n\t\tconst promiseValue = maybePromiseValue.then((r: V | undefined) => {\r\n\t\t\tsetPromiseBack(r)\r\n\t\t\treturn r\r\n\t\t})\r\n\t\t//\r\n\t\tsetPromiseBack(promiseValue)\r\n\t\treturn promiseValue\r\n\t} else {\r\n\t\treturn maybePromiseValue\r\n\t}\r\n}\r\n\r\n/** @private */\r\nfunction getField<T, F extends FieldDef<T>>(\r\n\t\trecord: MaybePromiseOrUndef<T>,\r\n\t\tfield: F,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tsetPromiseBack: PromiseBack<any>\r\n): FieldData {\r\n\tif (record == null) {\r\n\t\treturn undefined\r\n\t}\r\n\tif (isPromise(record)) {\r\n\t\treturn record.then((r: T | undefined) => getField(r, field, setPromiseBack))\r\n\t}\r\n\tconst fieldGet = isFieldAssessor<T>(field) ? field.get : field\r\n\tif ((fieldGet as never) in record) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tconst fieldResult = (record as any)[fieldGet]\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\treturn getValue(fieldResult, setPromiseBack)\r\n\t}\r\n\tif (typeof fieldGet === 'function') {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tconst fieldResult = (fieldGet as any)(record)\r\n\t\treturn getValue(fieldResult, setPromiseBack)\r\n\t}\r\n\r\n\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n\tconst ss = `${ fieldGet }`.split('.')\r\n\tif (ss.length <= 1) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tconst fieldResult = (record as any)[fieldGet]\r\n\t\treturn getValue(fieldResult, setPromiseBack)\r\n\t}\r\n\tconst fieldResult = applyChainSafe(\r\n\t\t\trecord,\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\t(val, name) => getField(val, name, emptyFn as any),\r\n\t\t\t...ss\r\n\t)\r\n\treturn getValue(fieldResult, setPromiseBack)\r\n}\r\n\r\n/** @private */\r\nfunction setField<T, F extends FieldDef<T>>(\r\n\t\trecord: T | undefined,\r\n\t\tfield: F,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tvalue: any\r\n): boolean {\r\n\tif (record == null) {\r\n\t\treturn false\r\n\t}\r\n\r\n\tconst fieldSet = isFieldAssessor<T>(field) ? field.set : field\r\n\tif ((fieldSet as never) in record) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t(record as any)[fieldSet] = value\r\n\t} else if (typeof fieldSet === 'function') {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\treturn (fieldSet as any)(record, value)\r\n\t} else if (typeof fieldSet === 'string') {\r\n\t\tconst ss = `${ fieldSet }`.split('.')\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tlet obj: any = record\r\n\t\tconst { length } = ss\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tconst f = ss[i]\r\n\t\t\tif (i === length - 1) {\r\n\t\t\t\tobj[f] = value\r\n\t\t\t} else {\r\n\t\t\t\tobj = obj[f] || (obj[f] = {})\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t(record as any)[fieldSet] = value\r\n\t}\r\n\treturn true\r\n}\r\n\r\n/** @private */\r\nfunction _getIndex(sortedIndexMap: null | number[], index: number): number {\r\n\tif (!sortedIndexMap) {\r\n\t\treturn index\r\n\t}\r\n\tconst mapIndex = sortedIndexMap[index]\r\n\treturn mapIndex != null ? mapIndex : index\r\n}\r\n\r\nexport interface DataSourceParam<T> {\r\n    get: (index: number) => T;\r\n    length: number;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    source?: any;\r\n}\r\n\r\n/**\r\n * grid data source\r\n *\r\n * @classdesc cheetahGrid.data.DataSource\r\n * @memberof cheetahGrid.data\r\n */\r\nexport class DataSource<T> extends EventTarget implements DataSourceAPI<T> {\r\n    private _get: (index: number) => MaybePromiseOrCall<T, []>\r\n\r\n    private _length: number\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private readonly _source: any\r\n\r\n    protected _sortedIndexMap: null | number[] = null\r\n\r\n    static get EVENT_TYPE(): typeof EVENT_TYPE {\r\n    \treturn EVENT_TYPE\r\n    }\r\n\r\n    static ofArray<T>(array: T[]): DataSource<T> {\r\n    \treturn new DataSource<T>({\r\n    \t\tget: (index: number): T => array[index],\r\n    \t\tlength: array.length,\r\n    \t\tsource: array\r\n    \t})\r\n    }\r\n\r\n    constructor(obj?: DataSourceParam<T> | DataSource<T>) {\r\n    \tsuper()\r\n    \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \tthis._get = obj?.get.bind(obj) || (undefined as any)\r\n    \tthis._length = obj?.length || 0\r\n    \tthis._source = obj?.source ?? obj\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get source(): any {\r\n    \treturn this._source\r\n    }\r\n\r\n    get(index: number): MaybePromiseOrUndef<T> {\r\n    \treturn this.getOriginal(_getIndex(this._sortedIndexMap, index))\r\n    }\r\n\r\n    getField<F extends FieldDef<T>>(index: number, field: F): FieldData {\r\n    \treturn this.getOriginalField(_getIndex(this._sortedIndexMap, index), field)\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    hasField(index: number, field: FieldDef<T>): boolean {\r\n    \treturn this.hasOriginalField(_getIndex(this._sortedIndexMap, index), field)\r\n    }\r\n\r\n    setField<F extends FieldDef<T>>(\r\n    \t\tindex: number,\r\n    \t\tfield: F,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tvalue: any\r\n    ): MaybePromise<boolean> {\r\n    \treturn this.setOriginalField(_getIndex(this._sortedIndexMap, index), field, value)\r\n    }\r\n\r\n    sort(field: FieldDef<T>, order: 'desc' | 'asc'): MaybePromise<void> {\r\n    \tconst sortedIndexMap = new Array<number>(this._length)\r\n\r\n    \tconst orderFn: (v1: T, v2: T) => -1 | 0 | 1 =\r\n            order !== 'desc' ? (v1: T, v2: T): -1 | 0 | 1 => (v1 === v2 ? 0 : v1 > v2 ? 1 : -1) : (v1: T, v2: T): -1 | 0 | 1 => (v1 === v2 ? 0 : v1 < v2 ? 1 : -1)\r\n\r\n    \treturn sort.sortPromise(\r\n    \t\t\t(index) => (sortedIndexMap[index] != null ? sortedIndexMap[index] : (sortedIndexMap[index] = index)),\r\n    \t\t\t(index, rel) => {\r\n    \t\t\t\tsortedIndexMap[index] = rel\r\n    \t\t\t},\r\n    \t\t\tthis._length,\r\n    \t\t\torderFn,\r\n    \t\t\t(index) => this.getOriginalField(index, field)\r\n    \t).then(() => {\r\n    \t\tthis._sortedIndexMap = sortedIndexMap\r\n    \t\tthis.fireListeners(EVENT_TYPE.UPDATED_ORDER)\r\n    \t})\r\n    }\r\n\r\n    get length(): number {\r\n    \treturn this._length\r\n    }\r\n\r\n    set length(length: number) {\r\n    \tif (this._length === length) {\r\n    \t\treturn\r\n    \t}\r\n\r\n    \tconst results = this.fireListeners(EVENT_TYPE.UPDATE_LENGTH, length)\r\n    \tif (array.findIndex(results, (v) => !v) >= 0) {\r\n    \t\treturn\r\n    \t}\r\n    \tthis._length = length\r\n    \tthis.fireListeners(EVENT_TYPE.UPDATED_LENGTH, this._length)\r\n    }\r\n\r\n    get dataSource(): DataSource<T> {\r\n    \treturn this\r\n    }\r\n\r\n    dispose(): void {\r\n    \tsuper.dispose()\r\n    }\r\n\r\n    protected getOriginal(index: number): MaybePromiseOrUndef<T> {\r\n    \treturn getValue(this._get(index), (val: PromiseCacheValue<T>) => {\r\n    \t\tthis.recordPromiseCallBackInternal(index, val)\r\n    \t})\r\n    }\r\n\r\n    protected getOriginalField<F extends FieldDef<T>>(index: number, field: F): FieldData {\r\n    \tif (field == null) {\r\n    \t\treturn undefined\r\n    \t}\r\n    \tconst record = this.getOriginal(index)\r\n    \treturn getField(record, field, (val) => {\r\n    \t\tthis.fieldPromiseCallBackInternal(index, field, val)\r\n    \t})\r\n    }\r\n\r\n    protected hasOriginalField(index: number, field: FieldDef<T>): boolean {\r\n    \tif (field == null) {\r\n    \t\treturn false\r\n    \t}\r\n    \tif (typeof field === 'function') {\r\n    \t\treturn true\r\n    \t}\r\n    \tconst record = this.getOriginal(index)\r\n    \treturn Boolean(record && (field as never) in record)\r\n    }\r\n\r\n    protected setOriginalField<F extends FieldDef<T>>(\r\n    \t\tindex: number,\r\n    \t\tfield: F,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\tvalue: any\r\n    ): MaybePromise<boolean> {\r\n    \tif (field == null) {\r\n    \t\treturn false\r\n    \t}\r\n    \tconst record = this.getOriginal(index)\r\n    \tif (isPromise(record)) {\r\n    \t\treturn record.then((r) => setField(r, field, value))\r\n    \t}\r\n    \treturn setField(record, field, value)\r\n    }\r\n\r\n    protected fieldPromiseCallBackInternal<F extends FieldDef<T>>(\r\n    \t\t_index: number,\r\n    \t\t_field: F,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t_value: PromiseCacheValue<any>\r\n    ): void {\r\n    \t//\r\n    }\r\n\r\n    protected recordPromiseCallBackInternal(_index: number, _record: PromiseCacheValue<T>): void {\r\n    \t//\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static EMPTY = new DataSource<any>({\r\n    \tget(): void {\r\n    \t\t/*noop */\r\n    \t},\r\n    \tlength: 0\r\n    })\r\n}\r\n","import type { FieldDef, MaybePromise, MaybePromiseOrUndef } from '../ts-types'\r\nimport { each, isPromise } from '../internal/utils'\r\nimport { DataSource } from './DataSource'\r\nimport { EventHandler } from '../internal/EventHandler'\r\n\r\n/** @private */\r\ntype Filter<T> = (record: T | undefined) => boolean;\r\n\r\n/** @private */\r\nclass DataSourceIterator<T> {\r\n    _dataSource: DataSource<T>\r\n\r\n    _curIndex: number\r\n\r\n    _data: MaybePromiseOrUndef<T>[]\r\n\r\n    constructor(dataSource: DataSource<T>) {\r\n    \tthis._dataSource = dataSource\r\n    \tthis._curIndex = -1\r\n    \tthis._data = []\r\n    }\r\n\r\n    hasNext(): boolean {\r\n    \tconst next = this._curIndex + 1\r\n    \treturn this._dataSource.length > next\r\n    }\r\n\r\n    next(): MaybePromiseOrUndef<T> {\r\n    \tconst next = this._curIndex + 1\r\n    \tconst data = this._getIndexData(next)\r\n    \tthis._curIndex = next\r\n    \treturn data\r\n    }\r\n\r\n    movePrev(): void {\r\n    \tthis._curIndex--\r\n    }\r\n\r\n    _getIndexData(index: number, nest?: boolean): MaybePromiseOrUndef<T> {\r\n    \tconst dataSource = this._dataSource\r\n    \tconst data = this._data\r\n    \tif (index < data.length) {\r\n    \t\treturn data[index]\r\n    \t}\r\n\r\n    \tif (dataSource.length <= index) {\r\n    \t\treturn undefined\r\n    \t}\r\n    \tconst record = this._dataSource.get(index)\r\n    \tdata[index] = record\r\n    \tif (isPromise(record)) {\r\n    \t\trecord.then((val) => {\r\n    \t\t\tdata[index] = val\r\n    \t\t})\r\n    \t\tif (!nest) {\r\n    \t\t\tfor (let i = 1; i <= 100; i++) {\r\n    \t\t\t\tthis._getIndexData(index + i, true)\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn record\r\n    }\r\n}\r\n\r\n/** @private */\r\nclass FilterData<T> {\r\n    _owner: FilterDataSource<T>\r\n\r\n    _dataSourceItr: DataSourceIterator<T>\r\n\r\n    _filter: Filter<T>\r\n\r\n    _filterdList: (T | undefined)[]\r\n\r\n    _queues: (Promise<T | undefined> | null)[]\r\n\r\n    _cancel = false\r\n\r\n    constructor(dc: FilterDataSource<T>, original: DataSource<T>, filter: Filter<T>) {\r\n    \tthis._owner = dc\r\n    \tthis._dataSourceItr = new DataSourceIterator(original)\r\n    \tthis._filter = filter\r\n    \tthis._filterdList = []\r\n    \tthis._queues = []\r\n    }\r\n\r\n    get(index: number): MaybePromiseOrUndef<T> {\r\n    \tif (this._cancel) {\r\n    \t\treturn undefined\r\n    \t}\r\n    \tconst filterdList = this._filterdList\r\n    \tif (index < filterdList.length) {\r\n    \t\treturn filterdList[index]\r\n    \t}\r\n    \tconst queues = this._queues\r\n    \tconst indexQueue = queues[index]\r\n    \tif (indexQueue) {\r\n    \t\treturn indexQueue\r\n    \t}\r\n    \treturn queues[index] || this._findIndex(index)\r\n    }\r\n\r\n    cancel(): void {\r\n    \tthis._cancel = true\r\n    }\r\n\r\n    _findIndex(index: number): MaybePromiseOrUndef<T> {\r\n    \tif (window.Promise) {\r\n    \t\tconst timeout = Date.now() + 100\r\n    \t\tlet count = 0\r\n    \t\treturn this._findIndexWithTimeout(index, () => {\r\n    \t\t\tcount++\r\n    \t\t\tif (count >= 100) {\r\n    \t\t\t\tcount = 0\r\n    \t\t\t\treturn timeout < Date.now()\r\n    \t\t\t}\r\n    \t\t\treturn false\r\n    \t\t})\r\n    \t}\r\n    \treturn this._findIndexWithTimeout(index, () => false)\r\n    }\r\n\r\n    _findIndexWithTimeout(index: number, testTimeout: () => boolean): MaybePromiseOrUndef<T> {\r\n    \tconst filterdList = this._filterdList\r\n    \tconst filter = this._filter\r\n    \tconst dataSourceItr = this._dataSourceItr\r\n\r\n    \tconst queues = this._queues\r\n\r\n    \twhile (dataSourceItr.hasNext()) {\r\n    \t\tif (this._cancel) {\r\n    \t\t\treturn undefined\r\n    \t\t}\r\n    \t\tconst record = dataSourceItr.next()\r\n    \t\tif (isPromise(record)) {\r\n    \t\t\tdataSourceItr.movePrev()\r\n    \t\t\tconst queue = record.then((_value) => {\r\n    \t\t\t\tqueues[index] = null\r\n    \t\t\t\treturn this.get(index)\r\n    \t\t\t})\r\n    \t\t\tqueues[index] = queue\r\n    \t\t\treturn queue\r\n    \t\t}\r\n    \t\tif (filter(record)) {\r\n    \t\t\tfilterdList.push(record)\r\n    \t\t\tif (index < filterdList.length) {\r\n    \t\t\t\treturn filterdList[index]\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tif (testTimeout()) {\r\n    \t\t\tconst promise = new Promise<void>((resolve) => {\r\n    \t\t\t\tsetTimeout(() => {\r\n    \t\t\t\t\tresolve()\r\n    \t\t\t\t}, 300)\r\n    \t\t\t})\r\n    \t\t\tconst queue = promise.then(() => {\r\n    \t\t\t\tqueues[index] = null\r\n    \t\t\t\treturn this.get(index)\r\n    \t\t\t})\r\n    \t\t\tqueues[index] = queue\r\n    \t\t\treturn queue\r\n    \t\t}\r\n    \t}\r\n    \tconst dc = this._owner\r\n    \tdc.length = filterdList.length\r\n    \treturn undefined\r\n    }\r\n}\r\n\r\n/**\r\n * grid data source for filter\r\n *\r\n * @classdesc cheetahGrid.data.FilterDataSource\r\n * @memberof cheetahGrid.data\r\n */\r\nexport class FilterDataSource<T> extends DataSource<T> {\r\n    private _dataSource: DataSource<T>\r\n\r\n    private _handler: EventHandler\r\n\r\n    private _filterData: FilterData<T> | null = null\r\n\r\n    static get EVENT_TYPE(): typeof DataSource.EVENT_TYPE {\r\n    \treturn DataSource.EVENT_TYPE\r\n    }\r\n\r\n    constructor(dataSource: DataSource<T>, filter: Filter<T>) {\r\n    \tsuper(dataSource)\r\n    \tthis._dataSource = dataSource\r\n    \tthis.filter = filter\r\n    \tconst handler = (this._handler = new EventHandler())\r\n    \thandler.on(dataSource, DataSource.EVENT_TYPE.UPDATED_ORDER, () => {\r\n    \t\t// reset\r\n    \t\t// eslint-disable-next-line no-self-assign\r\n    \t\tthis.filter = this.filter\r\n    \t})\r\n    \teach(DataSource.EVENT_TYPE, (type) => {\r\n    \t\thandler.on(dataSource, type, (...args) => this.fireListeners(type, ...args))\r\n    \t})\r\n    }\r\n\r\n    get filter(): Filter<T> | null {\r\n    \treturn this._filterData?._filter || null\r\n    }\r\n\r\n    set filter(filter: Filter<T> | null) {\r\n    \tif (this._filterData) {\r\n    \t\tthis._filterData.cancel()\r\n    \t}\r\n    \tthis._filterData = filter ? new FilterData(this, this._dataSource, filter) : null\r\n    \tthis.length = this._dataSource.length\r\n    }\r\n\r\n    protected getOriginal(index: number): MaybePromiseOrUndef<T> {\r\n    \tif (!this._filterData) {\r\n    \t\treturn super.getOriginal(index)\r\n    \t}\r\n    \treturn this._filterData.get(index)\r\n    }\r\n\r\n    sort(field: FieldDef<T>, order: 'desc' | 'asc'): MaybePromise<void> {\r\n    \treturn this._dataSource.sort(field, order)\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get source(): any {\r\n    \treturn this._dataSource.source\r\n    }\r\n\r\n    get dataSource(): DataSource<T> {\r\n    \treturn this._dataSource\r\n    }\r\n\r\n    dispose(): void {\r\n    \tthis._handler.dispose()\r\n    \tsuper.dispose()\r\n    }\r\n}\r\n","import type { AnyFunction, ColorDef, InlineAPI, RectProps } from '../ts-types'\r\nimport type { CanvasHelper } from '../tools/canvashelper'\r\nimport type { GenWordsResult } from '../internal/utils'\r\nimport { str } from '../internal/utils'\r\n\r\nfunction getWidth(ctx: CanvasRenderingContext2D, content: string): number {\r\n\treturn ctx.measureText(content).width\r\n}\r\n\r\nfunction breakWidth(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tcontent: string,\r\n\t\titr: GenWordsResult,\r\n\t\tcandidateIndex: number,\r\n\t\twidth: number\r\n): {\r\n    before: Inline | null;\r\n    after: Inline | null;\r\n} {\r\n\tconst chars = []\r\n\tlet ret = itr.next()\r\n\tfor (let i = 0; i < candidateIndex && ret !== null; i++, ret = itr.next()) {\r\n\t\tchars.push(ret)\r\n\t}\r\n\tlet beforeWidth = getWidth(ctx, chars.join(''))\r\n\tif (beforeWidth > width) {\r\n\t\twhile (chars.length) {\r\n\t\t\tconst c = chars.pop()\r\n\t\t\tbeforeWidth -= getWidth(ctx, c || '')\r\n\t\t\tif (beforeWidth <= width) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t} else if (beforeWidth < width) {\r\n\t\twhile (ret !== null) {\r\n\t\t\tconst charWidth = getWidth(ctx, ret)\r\n\t\t\tif (beforeWidth + charWidth > width) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tchars.push(ret)\r\n\t\t\tbeforeWidth += charWidth\r\n\t\t\tret = itr.next()\r\n\t\t}\r\n\t}\r\n\tconst beforeContent = chars.join('').replace(/\\s+$/, '')\r\n\tconst afterContent = content.slice(beforeContent.length).replace(/^\\s+/, '')\r\n\treturn {\r\n\t\tbefore: beforeContent ? new Inline(beforeContent) : null,\r\n\t\tafter: afterContent ? new Inline(afterContent) : null\r\n\t}\r\n}\r\n\r\nexport type InlineDrawOption = {\r\n    ctx: CanvasRenderingContext2D;\r\n    canvashelper: CanvasHelper;\r\n    rect: RectProps;\r\n    offset: number;\r\n    offsetLeft: number;\r\n    offsetRight: number;\r\n    offsetTop: number;\r\n    offsetBottom: number;\r\n};\r\n\r\nexport class Inline implements InlineAPI {\r\n    private _content: string\r\n\r\n    constructor(content?: string) {\r\n    \tthis._content = content != null ? content : ''\r\n    }\r\n\r\n    width({ ctx }: { ctx: CanvasRenderingContext2D }): number {\r\n    \treturn getWidth(ctx, this._content)\r\n    }\r\n\r\n    font(): string | null {\r\n    \treturn null\r\n    }\r\n\r\n    color(): ColorDef | null {\r\n    \treturn null\r\n    }\r\n\r\n    canDraw(): boolean {\r\n    \treturn true\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    onReady(_callback: AnyFunction): void {\r\n    }\r\n\r\n    draw({ ctx, canvashelper, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n    \tcanvashelper.fillTextRect(ctx, this._content, rect.left, rect.top, rect.width, rect.height, {\r\n    \t\toffset: offset + 1,\r\n    \t\tpadding: {\r\n    \t\t\tleft: offsetLeft,\r\n    \t\t\tright: offsetRight,\r\n    \t\t\ttop: offsetTop,\r\n    \t\t\tbottom: offsetBottom\r\n    \t\t}\r\n    \t})\r\n    }\r\n\r\n    canBreak(): boolean {\r\n    \treturn !!this._content\r\n    }\r\n\r\n    splitIndex(index: number): {\r\n        before: Inline | null;\r\n        after: Inline | null;\r\n    } {\r\n    \tconst content = this._content\r\n    \tconst itr = str.genChars(content)\r\n    \tconst chars = []\r\n    \tlet ret = itr.next()\r\n    \tfor (let i = 0; i < index && ret !== null; i++, ret = itr.next()) {\r\n    \t\tchars.push(ret)\r\n    \t}\r\n    \tconst beforeContent = chars.join('')\r\n    \tconst afterContent = content.slice(beforeContent.length)\r\n    \treturn {\r\n    \t\tbefore: beforeContent ? new Inline(beforeContent) : null,\r\n    \t\tafter: afterContent ? new Inline(afterContent) : null\r\n    \t}\r\n    }\r\n\r\n    breakWord(\r\n    \t\tctx: CanvasRenderingContext2D,\r\n    \t\twidth: number\r\n    ): {\r\n        before: Inline | null;\r\n        after: Inline | null;\r\n    } {\r\n    \tconst content = this._content\r\n    \tconst allWidth = this.width({ ctx })\r\n    \tconst candidate = Math.floor((this._content.length * width) / allWidth)\r\n    \tconst itr = str.genWords(content)\r\n    \treturn breakWidth(ctx, content, itr, candidate, width)\r\n    }\r\n\r\n    breakAll(\r\n    \t\tctx: CanvasRenderingContext2D,\r\n    \t\twidth: number\r\n    ): {\r\n        before: Inline | null;\r\n        after: Inline | null;\r\n    } {\r\n    \tconst content = this._content\r\n    \tconst allWidth = this.width({ ctx })\r\n    \tconst candidate = Math.floor((this._content.length * width) / allWidth)\r\n    \tconst itr = str.genChars(content)\r\n    \treturn breakWidth(ctx, content, itr, candidate, width)\r\n    }\r\n\r\n    toString(): string {\r\n    \treturn this._content\r\n    }\r\n}\r\n","import type { AnyFunction, ColorDef } from '../ts-types'\r\nimport { Inline } from './Inline'\r\nimport type { InlineDrawOption } from './Inline'\r\n\r\nexport type InlineDrawerFunction = (options: InlineDrawOption) => void;\r\n\r\nexport class InlineDrawer extends Inline {\r\n    private _draw: InlineDrawerFunction\r\n\r\n    private _width: number\r\n\r\n    // private _height: number;\r\n    private _color?: ColorDef\r\n\r\n    constructor({\r\n    \tdraw,\r\n    \twidth,\r\n    \t// height,\r\n    \tcolor\r\n    }: {\r\n        draw: InlineDrawerFunction;\r\n        width: number;\r\n        height: number;\r\n        color?: ColorDef;\r\n    }) {\r\n    \tsuper()\r\n\r\n    \tthis._draw = draw\r\n    \tthis._width = width\r\n    \t// this._height = height;\r\n    \tthis._color = color\r\n    }\r\n\r\n    width(_arg: { ctx: CanvasRenderingContext2D }): number {\r\n    \treturn this._width\r\n    }\r\n\r\n    font(): string | null {\r\n    \treturn null\r\n    }\r\n\r\n    color(): ColorDef | null {\r\n    \treturn this._color ?? null\r\n    }\r\n\r\n    canDraw(): boolean {\r\n    \treturn true\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    onReady(_callback: AnyFunction): void {\r\n    }\r\n\r\n    draw({ ctx, canvashelper, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n    \tthis._draw({\r\n    \t\tctx,\r\n    \t\tcanvashelper,\r\n    \t\trect,\r\n    \t\toffset,\r\n    \t\toffsetLeft,\r\n    \t\toffsetRight,\r\n    \t\toffsetTop,\r\n    \t\toffsetBottom\r\n    \t})\r\n    }\r\n\r\n    canBreak(): boolean {\r\n    \treturn false\r\n    }\r\n\r\n    toString(): string {\r\n    \treturn ''\r\n    }\r\n}\r\n","import * as fonts from '../internal/fonts'\r\nimport type { AnyFunction, ColorDef } from '../ts-types'\r\nimport { Inline } from './Inline'\r\nimport type { InlineDrawOption } from './Inline'\r\n\r\nexport type InlineIconConstructorOption = {\r\n    width?: number;\r\n    font?: string;\r\n    content?: string;\r\n    color?: ColorDef;\r\n};\r\n\r\nexport class InlineIcon extends Inline {\r\n    private _icon: InlineIconConstructorOption\r\n\r\n    constructor(icon: InlineIconConstructorOption) {\r\n    \tsuper()\r\n    \tthis._icon = icon || {}\r\n    }\r\n\r\n    width({ ctx }: { ctx: CanvasRenderingContext2D }): number {\r\n    \tconst icon = this._icon\r\n    \tif (icon.width) {\r\n    \t\treturn icon.width\r\n    \t}\r\n    \tif (icon.font && fonts.check(icon.font, icon.content || '')) {\r\n    \t\tctx.save()\r\n    \t\tctx.canvas.style.letterSpacing = 'normal'\r\n    \t\ttry {\r\n    \t\t\tctx.font = icon.font || ctx.font\r\n    \t\t\treturn ctx.measureText(icon.content || '').width\r\n    \t\t} finally {\r\n    \t\t\tctx.canvas.style.letterSpacing = ''\r\n    \t\t\tctx.restore()\r\n    \t\t}\r\n    \t}\r\n    \treturn 0 //unknown\r\n    }\r\n\r\n    font(): string | null {\r\n    \treturn this._icon.font ?? null\r\n    }\r\n\r\n    color(): ColorDef | null {\r\n    \treturn this._icon.color ?? null\r\n    }\r\n\r\n    canDraw(): boolean {\r\n    \tconst icon = this._icon\r\n    \treturn icon.font ? fonts.check(icon.font, icon.content || '') : true\r\n    }\r\n\r\n    onReady(callback: AnyFunction): void {\r\n    \tconst icon = this._icon\r\n    \tif (icon.font && !fonts.check(icon.font, icon.content || '')) {\r\n    \t\tfonts.load(icon.font, icon.content || '', callback)\r\n    \t}\r\n    }\r\n\r\n    draw({ ctx, canvashelper, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n    \tconst icon = this._icon\r\n    \tif (icon.content) {\r\n    \t\tctx.canvas.style.letterSpacing = 'normal'\r\n    \t\ttry {\r\n    \t\t\t// eslint-disable-next-line no-self-assign\r\n    \t\t\tctx.font = ctx.font // To apply letterSpacing, we need to reset it.\r\n    \t\t\tcanvashelper.fillTextRect(ctx, icon.content, rect.left, rect.top, rect.width, rect.height, {\r\n    \t\t\t\toffset: offset + 1,\r\n    \t\t\t\tpadding: {\r\n    \t\t\t\t\tleft: offsetLeft,\r\n    \t\t\t\t\tright: offsetRight,\r\n    \t\t\t\t\ttop: offsetTop,\r\n    \t\t\t\t\tbottom: offsetBottom\r\n    \t\t\t\t}\r\n    \t\t\t})\r\n    \t\t} finally {\r\n    \t\t\tctx.canvas.style.letterSpacing = ''\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    canBreak(): boolean {\r\n    \treturn false\r\n    }\r\n\r\n    toString(): string {\r\n    \treturn ''\r\n    }\r\n}\r\n","import type { AnyFunction, MaybePromise } from '../ts-types'\r\nimport { Inline } from './Inline'\r\nimport type { InlineDrawOption } from './Inline'\r\nimport { getCacheOrLoad } from '../internal/imgs'\r\nimport { isPromise } from '../internal/utils'\r\n\r\nexport type InlineImageConstructorOption = {\r\n    src: MaybePromise<string>;\r\n    width?: number;\r\n    height?: number;\r\n    imageLeft?: number;\r\n    imageTop?: number;\r\n    imageWidth?: number;\r\n    imageHeight?: number;\r\n};\r\n\r\nexport class InlineImage extends Inline {\r\n    private _src: MaybePromise<string>\r\n\r\n    private _width?: number\r\n\r\n    private _height?: number\r\n\r\n    private _imageLeft?: number\r\n\r\n    private _imageTop?: number\r\n\r\n    private _imageWidth?: number\r\n\r\n    private _imageHeight?: number\r\n\r\n    private _onloaded: AnyFunction[]\r\n\r\n    private _inlineImgPromise: MaybePromise<HTMLImageElement> | null = null\r\n\r\n    private _inlineImg: HTMLImageElement | null = null\r\n\r\n    constructor({ src, width, height, imageLeft, imageTop, imageWidth, imageHeight }: InlineImageConstructorOption) {\r\n    \tsuper()\r\n    \tthis._src = src\r\n    \tthis._width = width\r\n    \tthis._height = height\r\n    \tthis._imageLeft = imageLeft\r\n    \tthis._imageTop = imageTop\r\n    \tthis._imageWidth = imageWidth\r\n    \tthis._imageHeight = imageHeight\r\n\r\n    \tthis._onloaded = []\r\n\r\n    \tif (isPromise(src)) {\r\n    \t\tsrc.then((s) => {\r\n    \t\t\tthis._src = s\r\n    \t\t\tthis._loadImage(s)\r\n    \t\t})\r\n    \t} else {\r\n    \t\tthis._loadImage(src)\r\n    \t}\r\n    }\r\n\r\n    _loadImage(src: string): void {\r\n    \tconst img = (this._inlineImgPromise = getCacheOrLoad('InlineImage', 50, src))\r\n    \tif (isPromise(img)) {\r\n    \t\timg.then((i) => {\r\n    \t\t\tthis._inlineImg = i\r\n\r\n    \t\t\tthis._onloaded.forEach((fn) => fn())\r\n    \t\t})\r\n    \t} else {\r\n    \t\tthis._inlineImg = img\r\n    \t}\r\n    }\r\n\r\n    width(_arg: { ctx: CanvasRenderingContext2D }): number {\r\n    \treturn this._width || (this._inlineImg?.width ?? 0)\r\n    }\r\n\r\n    font(): string | null {\r\n    \treturn null\r\n    }\r\n\r\n    color(): string | null {\r\n    \treturn null\r\n    }\r\n\r\n    canDraw(): boolean {\r\n    \treturn !!this._inlineImg\r\n    }\r\n\r\n    onReady(callback: AnyFunction): void {\r\n    \tif (isPromise(this._src) || isPromise(this._inlineImgPromise)) {\r\n    \t\tthis._onloaded.push(() => callback())\r\n    \t}\r\n    }\r\n\r\n    draw({ ctx, canvashelper, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n    \tconst img = this._inlineImg as HTMLImageElement\r\n    \tcanvashelper.drawInlineImageRect(\r\n    \t\t\tctx,\r\n    \t\t\timg,\r\n    \t\t\tthis._imageLeft || 0,\r\n    \t\t\tthis._imageTop || 0,\r\n    \t\t\tthis._imageWidth || img.width,\r\n    \t\t\tthis._imageHeight || img.height,\r\n    \t\t\tthis._width || img.width,\r\n    \t\t\tthis._height || img.height,\r\n    \t\t\trect.left,\r\n    \t\t\trect.top,\r\n    \t\t\trect.width,\r\n    \t\t\trect.height,\r\n    \t\t\t{\r\n    \t\t\t\toffset: offset + 1,\r\n    \t\t\t\tpadding: {\r\n    \t\t\t\t\tleft: offsetLeft,\r\n    \t\t\t\t\tright: offsetRight,\r\n    \t\t\t\t\ttop: offsetTop,\r\n    \t\t\t\t\tbottom: offsetBottom\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t)\r\n    }\r\n\r\n    canBreak(): boolean {\r\n    \treturn false\r\n    }\r\n\r\n    toString(): string {\r\n    \treturn ''\r\n    }\r\n}\r\n","import * as path2DManager from '../internal/path2DManager'\r\nimport type { AnyFunction, ColorDef } from '../ts-types'\r\nimport { Inline } from './Inline'\r\nimport type { InlineDrawOption } from './Inline'\r\nimport { calcStartPosition } from '../internal/canvases'\r\n\r\nexport type InlinePath2DConstructorOption = {\r\n    path: Path2D | string;\r\n    width: number;\r\n    height: number;\r\n    color?: ColorDef;\r\n};\r\n\r\nexport class InlinePath2D extends Inline {\r\n    private _path: Path2D\r\n\r\n    private _width: number\r\n\r\n    private _height: number\r\n\r\n    private _color?: ColorDef\r\n\r\n    constructor({ path, width, height, color }: InlinePath2DConstructorOption) {\r\n    \tsuper()\r\n    \t// IEPath2Dpolyfill\r\n    \tconst Path2D = path2DManager.getPath2D()\r\n    \tthis._path = new Path2D(path)\r\n    \tthis._width = width\r\n    \tthis._height = height\r\n    \tthis._color = color\r\n    }\r\n\r\n    width(_arg: { ctx: CanvasRenderingContext2D }): number {\r\n    \treturn this._width\r\n    }\r\n\r\n    font(): string | null {\r\n    \treturn null\r\n    }\r\n\r\n    color(): ColorDef | null {\r\n    \treturn this._color ?? null\r\n    }\r\n\r\n    canDraw(): boolean {\r\n    \treturn true\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    onReady(_callback: AnyFunction): void {\r\n    }\r\n\r\n    draw({ ctx, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n    \toffset++\r\n    \tconst padding = {\r\n    \t\tleft: offsetLeft,\r\n    \t\tright: offsetRight,\r\n    \t\ttop: offsetTop,\r\n    \t\tbottom: offsetBottom\r\n    \t}\r\n    \tctx.save()\r\n    \ttry {\r\n    \t\tctx.beginPath()\r\n    \t\tctx.rect(rect.left, rect.top, rect.width, rect.height)\r\n    \t\t//clip\r\n    \t\tctx.clip()\r\n\r\n    \t\t//\r\n    \t\tconst pos = calcStartPosition(ctx, rect, this._width, this._height, {\r\n    \t\t\toffset,\r\n    \t\t\tpadding\r\n    \t\t})\r\n    \t\tctx.translate(pos.x, pos.y)\r\n    \t\tctx.fill(this._path)\r\n    \t} finally {\r\n    \t\tctx.restore()\r\n    \t}\r\n    }\r\n\r\n    canBreak(): boolean {\r\n    \treturn false\r\n    }\r\n\r\n    toString(): string {\r\n    \treturn ''\r\n    }\r\n}\r\n","import { isPromise, then } from '../internal/utils'\r\nimport { InlineImage } from './InlineImage'\r\nimport type { MaybePromise } from '../ts-types'\r\n\r\nfunction buildSvgDataUrl(svg: string | Node): string {\r\n\tconst data = typeof svg === 'string' ? svg : new XMLSerializer().serializeToString(svg)\r\n\tconst url = `data:image/svg+xml;charset=utf-8,${ encodeURIComponent(data) }` //svgbase64\r\n\treturn url\r\n}\r\n\r\nfunction getSvgElement(svg: string | SVGElement): SVGElement {\r\n\tif (typeof svg === 'string') {\r\n\t\tconst parser = new DOMParser()\r\n\t\treturn parser.parseFromString(svg, 'image/svg+xml').children[0] as SVGElement\r\n\t} else {\r\n\t\treturn svg\r\n\t}\r\n}\r\n\r\nexport type InlineSvgConstructorOption = {\r\n    svg: MaybePromise<string | SVGElement>;\r\n    width?: number;\r\n    height?: number;\r\n};\r\n\r\nexport class InlineSvg extends InlineImage {\r\n\tconstructor({ svg, width, height }: InlineSvgConstructorOption) {\r\n\t\tconst svgElem = then(svg, getSvgElement)\r\n\t\tconst elmWidth = !isPromise(svgElem) ? svgElem.getAttribute('width') ?? undefined : undefined\r\n\t\tconst elmHeight = !isPromise(svgElem) ? svgElem.getAttribute('height') ?? undefined : undefined\r\n\t\tconst numElmWidth = elmWidth != null ? Number(elmWidth) : undefined\r\n\t\tconst numElmHeight = elmHeight != null ? Number(elmHeight) : undefined\r\n\t\tsuper({\r\n\t\t\tsrc: then(svg, buildSvgDataUrl),\r\n\t\t\twidth: width || numElmWidth,\r\n\t\t\theight: height || numElmHeight,\r\n\t\t\timageWidth: numElmWidth,\r\n\t\t\timageHeight: numElmHeight\r\n\t\t})\r\n\t}\r\n\r\n\tcanBreak(): boolean {\r\n\t\treturn false\r\n\t}\r\n\r\n\ttoString(): string {\r\n\t\treturn ''\r\n\t}\r\n}\r\n","import { svgIcons } from '../icons'\r\nimport * as path2DManager from '../internal/path2DManager'\r\nimport type { IconDefine } from '../ts-types'\r\nimport { Inline } from './Inline'\r\nimport type { InlineDrawOption } from './Inline'\r\nimport { InlineDrawer } from './InlineDrawer'\r\nimport { InlineIcon } from './InlineIcon'\r\nimport { InlineImage } from './InlineImage'\r\nimport { InlinePath2D } from './InlinePath2D'\r\nimport { InlineSvg } from './InlineSvg'\r\nimport type { PaddingOption } from '../internal/canvases'\r\nimport type { SimpleColumnIconOption } from '../ts-types-internal'\r\nimport { calcStartPosition } from '../internal/canvases'\r\n\r\nfunction drawRegisteredIcon(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\ticon: IconDefine,\r\n\t\tdrawWidth: number,\r\n\t\tdrawHeight: number,\r\n\t\tleft: number,\r\n\t\ttop: number,\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\t{ offset = 2, padding }: { offset?: number; padding?: PaddingOption } = {}\r\n): void {\r\n\tconst rect = {\r\n\t\tleft,\r\n\t\ttop,\r\n\t\twidth,\r\n\t\theight,\r\n\t\tright: left + width,\r\n\t\tbottom: top + height\r\n\t}\r\n\tctx.save()\r\n\ttry {\r\n\t\tctx.beginPath()\r\n\t\tctx.rect(rect.left, rect.top, rect.width, rect.height)\r\n\t\t//clip\r\n\t\tctx.clip()\r\n\r\n\t\t//\r\n\t\tconst pos = calcStartPosition(ctx, rect, drawWidth, drawHeight, {\r\n\t\t\toffset,\r\n\t\t\tpadding\r\n\t\t})\r\n\t\tpath2DManager.fill(icon, ctx, pos.x, pos.y, drawWidth, drawHeight)\r\n\t} finally {\r\n\t\tctx.restore()\r\n\t}\r\n}\r\n\r\nfunction isIconConstructorOption(icon: SimpleColumnIconOption): icon is SimpleColumnIconOption & { font: string; content: string } {\r\n\tif (icon.font && icon.content) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunction isInlineImageConstructorOption(icon: SimpleColumnIconOption): icon is SimpleColumnIconOption & { src: string } {\r\n\tif (icon.src) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunction isInlineSvgConstructorOption(icon: SimpleColumnIconOption): icon is SimpleColumnIconOption & {\r\n    path: string;\r\n    width: number;\r\n    height: number;\r\n} {\r\n\tif (icon.path) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nexport function iconOf(icon: SimpleColumnIconOption | null): Inline | null {\r\n\tif (icon instanceof Inline) {\r\n\t\treturn icon\r\n\t}\r\n\tif (!icon) {\r\n\t\treturn null\r\n\t}\r\n\tif (isIconConstructorOption(icon)) {\r\n\t\treturn new InlineIcon(icon)\r\n\t}\r\n\tif (isInlineImageConstructorOption(icon)) {\r\n\t\treturn new InlineImage({\r\n\t\t\tsrc: icon.src,\r\n\t\t\twidth: icon.width,\r\n\t\t\theight: icon.width\r\n\t\t})\r\n\t}\r\n\tif (icon.svg) {\r\n\t\treturn new InlineSvg({\r\n\t\t\tsvg: icon.svg,\r\n\t\t\twidth: icon.width,\r\n\t\t\theight: icon.width\r\n\t\t})\r\n\t}\r\n\tif (isInlineSvgConstructorOption(icon)) {\r\n\t\treturn new InlinePath2D({\r\n\t\t\tpath: icon.path,\r\n\t\t\twidth: icon.width,\r\n\t\t\theight: icon.width,\r\n\t\t\tcolor: icon.color\r\n\t\t})\r\n\t}\r\n\tconst regedIcons = svgIcons.get()\r\n\tif (icon.name && regedIcons[icon.name]) {\r\n\t\tconst regedIcon = regedIcons[icon.name]\r\n\t\tconst width = icon.width || Math.max(regedIcon.width, regedIcon.height)\r\n\t\treturn new InlineDrawer({\r\n\t\t\tdraw({ ctx, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom }: InlineDrawOption): void {\r\n\t\t\t\tdrawRegisteredIcon(ctx, regedIcon, width, width, rect.left, rect.top, rect.width, rect.height, {\r\n\t\t\t\t\toffset: offset + 1,\r\n\t\t\t\t\tpadding: {\r\n\t\t\t\t\t\tleft: offsetLeft,\r\n\t\t\t\t\t\tright: offsetRight,\r\n\t\t\t\t\t\ttop: offsetTop,\r\n\t\t\t\t\t\tbottom: offsetBottom\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\twidth,\r\n\t\t\theight: width,\r\n\t\t\tcolor: icon.color\r\n\t\t})\r\n\t}\r\n\treturn new InlineIcon(icon)\r\n}\r\n\r\nexport function of(content: string | Inline): Inline;\r\nexport function of(content?: string | Inline | null): null;\r\nexport function of(content?: string | Inline | null): Inline | null {\r\n\tif (content == null) {\r\n\t\treturn null\r\n\t}\r\n\tif (content instanceof Inline) {\r\n\t\treturn content\r\n\t}\r\n\treturn new Inline(content)\r\n}\r\n\r\nexport function buildInlines(icons: SimpleColumnIconOption[] | null | undefined, inline: Inline | string | (string | Inline)[]): Inline[] {\r\n\tconst result: Inline[] = []\r\n\tif (icons) {\r\n\t\tresult.push(...icons.map((icon) => iconOf(icon)).filter((i: Inline | null): i is Inline => i != null))\r\n\t}\r\n\tif (\r\n\t\tArray.isArray(inline)\r\n\t// && inline.filter(il => il instanceof Inline).length <- ?\r\n\t) {\r\n\t\tresult.push(...inline.map((il) => of(il)).filter((i) => i != null))\r\n\t} else {\r\n\t\tconst il = of(inline)\r\n\t\tif (il) {\r\n\t\t\tresult.push(il)\r\n\t\t}\r\n\t}\r\n\treturn result\r\n}\r\n\r\nexport function string(inline: Inline | string | (string | Inline)[]): string {\r\n\treturn buildInlines(undefined, inline).join('')\r\n}\r\n","import type { BaseActionOption, HeaderActionOption, SortHeaderActionOption, SortOption } from '../ts-types'\r\nimport { BaseAction } from './action/BaseAction'\r\nimport type { BaseHeaderDefine } from '../list-grid/layout-map/api'\r\nimport { CheckHeaderAction } from './action/CheckHeaderAction'\r\nimport { SortHeaderAction } from './action/SortHeaderAction'\r\n\r\nclass ImmutableSortHeaderAction<T> extends SortHeaderAction<T> {\r\n\tget disabled(): boolean {\r\n\t\treturn this._disabled\r\n\t}\r\n}\r\n\r\nclass ImmutableCheckHeaderAction<T> extends CheckHeaderAction<T> {\r\n\tget disabled(): boolean {\r\n\t\treturn this._disabled\r\n\t}\r\n}\r\n\r\nexport interface ImmutableHeaderActions {\r\n    SORT: ImmutableSortHeaderAction<any>;\r\n    CHECK: ImmutableCheckHeaderAction<any>;\r\n    // SWITCH: ImmutableSwitchHeaderAction<any>\r\n}\r\n\r\nexport const ACTIONS = {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tSORT: new ImmutableSortHeaderAction<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tCHECK: new ImmutableCheckHeaderAction<any>()\r\n}\r\n/**\r\n * column actions\r\n * @namespace cheetahGrid.columns.action\r\n * @memberof cheetahGrid.columns\r\n */\r\nexport {\r\n\tBaseAction,\r\n\tSortHeaderAction,\r\n\tCheckHeaderAction,\r\n\t// types\r\n\tBaseActionOption,\r\n\tSortHeaderActionOption\r\n}\r\n\r\nexport function of<T>(headerAction: HeaderActionOption | BaseAction<T> | null | undefined): BaseAction<T> | undefined {\r\n\tif (!headerAction) {\r\n\t\treturn undefined\r\n\t} else if (typeof headerAction === 'string') {\r\n\t\tconst key = headerAction.toUpperCase() as keyof typeof ACTIONS\r\n\t\treturn ACTIONS[key] || of(null)\r\n\t} else {\r\n\t\treturn headerAction\r\n\t}\r\n}\r\n\r\nexport function ofCell<T>(headerCell: BaseHeaderDefine<T>): BaseAction<T> | undefined {\r\n\tif (headerCell.sort) {\r\n\t\tif (typeof headerCell.sort === 'function') {\r\n\t\t\tconst sortMethod = headerCell.sort\r\n\t\t\t// 0.9.0 Backward compatibility\r\n\t\t\tconst sort: SortOption<T> = ({ order, col, grid }): void => sortMethod.call(headerCell, order, col, grid)\r\n\t\t\treturn new ImmutableSortHeaderAction({ sort })\r\n\t\t}\r\n\t\treturn ACTIONS.SORT\r\n\t}\r\n\treturn of(headerCell.headerAction)\r\n}\r\n","import type { BaseActionOption, EventListenerId, LayoutObjectId, ListGridAPI } from '../../ts-types'\r\n\r\nexport class BaseAction<T> {\r\n    protected _disabled: boolean\r\n\r\n    constructor(option: BaseActionOption = {}) {\r\n    \tthis._disabled = !!option.disabled || false\r\n    }\r\n\r\n    get disabled(): boolean {\r\n    \treturn this._disabled\r\n    }\r\n\r\n    set disabled(disabled: boolean) {\r\n    \tthis._disabled = disabled\r\n    \tthis.onChangeDisabledInternal()\r\n    }\r\n\r\n    clone(): BaseAction<T> {\r\n    \treturn new BaseAction(this)\r\n    }\r\n\r\n    bindGridEvent(_grid: ListGridAPI<T>, _cellId: LayoutObjectId): EventListenerId[] {\r\n    \treturn []\r\n    }\r\n\r\n    onChangeDisabledInternal(): void {\r\n    \t// impl\r\n    }\r\n}\r\n","import type { CellAddress, EventListenerId, LayoutObjectId } from '../../ts-types'\r\nimport type { CheckHeaderState, GridInternal } from '../../ts-types-internal'\r\nimport { bindCellClickAction, bindCellKeyAction } from './actionBind'\r\nimport { BaseAction } from './BaseAction'\r\nimport { animate } from '../../internal/animate'\r\nimport { getCheckHeaderStateId } from '../../internal/symbolManager'\r\nimport { obj } from '../../internal/utils'\r\n\r\nconst CHECK_HEADER_STATE_ID = getCheckHeaderStateId()\r\n\r\nfunction getState<T>(grid: GridInternal<T>): CheckHeaderState {\r\n\tlet state = grid[CHECK_HEADER_STATE_ID]\r\n\tif (!state) {\r\n\t\tstate = { elapsed: {}, block: {} }\r\n\t\tobj.setReadonly(grid, CHECK_HEADER_STATE_ID, state)\r\n\t}\r\n\treturn state\r\n}\r\n\r\nexport class CheckHeaderAction<T> extends BaseAction<T> {\r\n\tclone(): CheckHeaderAction<T> {\r\n\t\treturn new CheckHeaderAction(this)\r\n\t}\r\n\r\n\tbindGridEvent(grid: GridInternal<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n\t\tconst state = getState(grid)\r\n\r\n\t\tconst action = ({ col, row }: CellAddress): void => {\r\n\t\t\tconst range = grid.getCellRange(col, row)\r\n\t\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\t\t\tif (this.disabled || state.block[cellKey]) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tconst checked = grid.getHeaderValue(range.start.col, range.start.row)\r\n\t\t\tgrid.setHeaderValue(range.start.col, range.start.row, !checked)\r\n\r\n\t\t\tconst onChange = (): void => {\r\n\t\t\t\t// checkbox animation\r\n\t\t\t\tanimate(200, (point) => {\r\n\t\t\t\t\tif (point === 1) {\r\n\t\t\t\t\t\tdelete state.elapsed[cellKey]\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstate.elapsed[cellKey] = point\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tonChange()\r\n\t\t}\r\n\t\treturn [\r\n\t\t\t...bindCellClickAction(grid, cellId, {\r\n\t\t\t\taction,\r\n\t\t\t\tmouseOver: (e) => {\r\n\t\t\t\t\tif (this.disabled) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstate.mouseActiveCell = {\r\n\t\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\t\trow: e.row\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t},\r\n\t\t\t\tmouseOut: (e) => {\r\n\t\t\t\t\tdelete state.mouseActiveCell\r\n\t\t\t\t\tconst range = grid.getCellRange(e.col, e.row)\r\n\t\t\t\t\tgrid.invalidateCellRange(range)\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\t...bindCellKeyAction(grid, cellId, {\r\n\t\t\t\taction\r\n\t\t\t})\r\n\t\t]\r\n\t}\r\n}\r\n","import type { CellAddress, EventListenerId, LayoutObjectId, ListGridAPI, SortHeaderActionOption, SortOption, SortState } from '../../ts-types'\r\nimport { BaseAction } from './BaseAction'\r\nimport { bindCellClickAction } from './actionBind'\r\n\r\nexport class SortHeaderAction<T> extends BaseAction<T> {\r\n    private _sort: SortOption<T>\r\n\r\n    constructor(option: SortHeaderActionOption<T> = {}) {\r\n    \tsuper(option)\r\n    \tthis._sort = option.sort ?? true\r\n    }\r\n\r\n    get sort(): SortOption<T> {\r\n    \treturn this._sort\r\n    }\r\n\r\n    set sort(sort: SortOption<T>) {\r\n    \tthis._sort = sort\r\n    \tthis.onChangeDisabledInternal()\r\n    }\r\n\r\n    clone(): SortHeaderAction<T> {\r\n    \treturn new SortHeaderAction(this)\r\n    }\r\n\r\n    _executeSort(newState: SortState, grid: ListGridAPI<T>): void {\r\n    \tif (typeof this._sort === 'function') {\r\n    \t\tthis._sort({\r\n    \t\t\torder: newState.order || 'asc',\r\n    \t\t\tcol: newState.col,\r\n    \t\t\trow: newState.row,\r\n    \t\t\tgrid\r\n    \t\t})\r\n    \t} else {\r\n    \t\tconst fieldRow = Math.min(grid.recordRowCount - 1, newState.row) + grid.frozenRowCount\r\n    \t\tconst field = grid.getField(newState.col, fieldRow)\r\n    \t\tif (field == null) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tgrid.dataSource.sort(field, newState.order || 'asc')\r\n    \t}\r\n    }\r\n\r\n    bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[] {\r\n    \tfunction isTarget(col: number, row: number): boolean {\r\n    \t\treturn grid.getLayoutCellId(col, row) === cellId\r\n    \t}\r\n\r\n    \tconst action = (cell: CellAddress): void => {\r\n    \t\tif (this.disabled) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tconst state = grid.sortState as SortState\r\n    \t\tlet newState: SortState\r\n    \t\tconst range = grid.getCellRange(cell.col, cell.row)\r\n    \t\tif (isTarget(state.col, cell.row)) {\r\n    \t\t\tnewState = {\r\n    \t\t\t\tcol: range.start.col,\r\n    \t\t\t\trow: range.start.row,\r\n    \t\t\t\torder: state.order === 'asc' ? 'desc' : 'asc'\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\tnewState = {\r\n    \t\t\t\tcol: range.start.col,\r\n    \t\t\t\trow: range.start.row,\r\n    \t\t\t\torder: 'asc'\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tgrid.sortState = newState\r\n    \t\tthis._executeSort(newState, grid)\r\n    \t\tgrid.invalidateGridRect(0, 0, grid.colCount - 1, grid.rowCount - 1)\r\n    \t}\r\n\r\n    \treturn [\r\n    \t\t...bindCellClickAction(grid, cellId, {\r\n    \t\t\taction,\r\n    \t\t\tmouseOver: (_e) => {\r\n    \t\t\t\tif (this.disabled) {\r\n    \t\t\t\t\treturn false\r\n    \t\t\t\t}\r\n    \t\t\t\treturn true\r\n    \t\t\t}\r\n    \t\t})\r\n    \t]\r\n    }\r\n}\r\n","import type { CellAddress, EventListenerId, LayoutObjectId, ListGridAPI } from '../../ts-types'\r\nimport { DG_EVENT_TYPE } from '../../core/DG_EVENT_TYPE'\r\nimport { event } from '../../internal/utils'\r\n\r\nconst KEY_ENTER = 13\r\nconst KEY_SPACE = 32\r\n\r\nexport function bindCellClickAction<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tcellId: LayoutObjectId,\r\n\t\t{\r\n\t\t\taction,\r\n\t\t\tmouseOver,\r\n\t\t\tmouseOut\r\n\t\t}: {\r\n        action: (cell: CellAddress) => void;\r\n        mouseOver?: (cell: CellAddress) => boolean;\r\n        mouseOut?: (cell: CellAddress) => void;\r\n    }\r\n): EventListenerId[] {\r\n\tfunction isTarget(col: number, row: number): boolean {\r\n\t\treturn grid.getLayoutCellId(col, row) === cellId\r\n\t}\r\n\r\n\tlet inMouse: boolean\r\n\treturn [\r\n\t\t// click\r\n\t\tgrid.listen(DG_EVENT_TYPE.CLICK_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\taction({\r\n\t\t\t\tcol: e.col,\r\n\t\t\t\trow: e.row\r\n\t\t\t})\r\n\t\t}),\r\n\t\t// mouse move\r\n\t\tgrid.listen(DG_EVENT_TYPE.MOUSEOVER_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (mouseOver) {\r\n\t\t\t\tif (\r\n\t\t\t\t\t!mouseOver({\r\n\t\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\t\trow: e.row\r\n\t\t\t\t\t})\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tgrid.getElement().style.cursor = 'pointer'\r\n\t\t\tinMouse = true\r\n\t\t}),\r\n\t\t//MOUSEENTER'col-resize'move\r\n\t\tgrid.listen(DG_EVENT_TYPE.MOUSEMOVE_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (inMouse && !grid.getElement().style.cursor) {\r\n\t\t\t\tgrid.getElement().style.cursor = 'pointer'\r\n\t\t\t}\r\n\t\t}),\r\n\t\tgrid.listen(DG_EVENT_TYPE.MOUSEOUT_CELL, (e) => {\r\n\t\t\tif (!isTarget(e.col, e.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (mouseOut) {\r\n\t\t\t\tmouseOut({\r\n\t\t\t\t\tcol: e.col,\r\n\t\t\t\t\trow: e.row\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tgrid.getElement().style.cursor = ''\r\n\t\t\tinMouse = false\r\n\t\t})\r\n\t]\r\n}\r\n\r\nexport function bindCellKeyAction<T>(\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tcellId: LayoutObjectId,\r\n\t\t{\r\n\t\t\taction,\r\n\t\t\tacceptKeys = []\r\n\t\t}: {\r\n        action: (cell: CellAddress) => void;\r\n        acceptKeys?: number[];\r\n    }\r\n): EventListenerId[] {\r\n\tfunction isTarget(col: number, row: number): boolean {\r\n\t\treturn grid.getLayoutCellId(col, row) === cellId\r\n\t}\r\n\r\n\tacceptKeys = [ ...acceptKeys, KEY_ENTER, KEY_SPACE ]\r\n\treturn [\r\n\t\t// enter key down\r\n\t\tgrid.listen(DG_EVENT_TYPE.KEYDOWN, (e) => {\r\n\t\t\tif (acceptKeys.indexOf(e.keyCode) === -1) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (grid.keyboardOptions?.moveCellOnEnter && e.keyCode === KEY_ENTER) {\r\n\t\t\t\t// When moving with the enter key, no action is taken with the enter key.\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tconst sel = grid.selection.select\r\n\t\t\tif (!isTarget(sel.col, sel.row)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\taction({\r\n\t\t\t\tcol: sel.col,\r\n\t\t\t\trow: sel.row\r\n\t\t\t})\r\n\t\t\tevent.cancel(e.event)\r\n\t\t})\r\n\t]\r\n}\r\n","import type { BaseStyleOption, CheckHeaderStyleOption, HeaderStyleOption, SortHeaderStyleOption } from '../ts-types'\r\nimport { BaseStyle } from './style/BaseStyle'\r\nimport { CheckHeaderStyle } from './style/CheckHeaderStyle'\r\nimport { MultilineTextHeaderStyle } from './style/MultilineTextHeaderStyle'\r\nimport { SortHeaderStyle } from './style/SortHeaderStyle'\r\nimport { Style } from './style/Style'\r\n\r\nexport {\r\n\tBaseStyle,\r\n\tStyle,\r\n\tSortHeaderStyle,\r\n\tCheckHeaderStyle,\r\n\t// types\r\n\tBaseStyleOption,\r\n\tCheckHeaderStyleOption,\r\n\tMultilineTextHeaderStyle,\r\n\tSortHeaderStyleOption\r\n}\r\n\r\nexport function of(headerStyle: HeaderStyleOption | null | undefined, StyleClass: typeof BaseStyle): BaseStyle {\r\n\tif (headerStyle) {\r\n\t\tif (headerStyle instanceof Style) {\r\n\t\t\treturn headerStyle\r\n\t\t} else if (typeof headerStyle === 'function') {\r\n\t\t\treturn of(headerStyle(), StyleClass)\r\n\t\t}\r\n\t\treturn new StyleClass(headerStyle)\r\n\t} else {\r\n\t\treturn StyleClass.DEFAULT\r\n\t}\r\n}\r\n","import type { BaseStyleOption, ColorDef, ColumnStyle } from '../../ts-types'\r\nimport { EventTarget } from '../../core/EventTarget'\r\n\r\nconst EVENT_TYPE = {\r\n\tCHANGE_STYLE: 'change_style'\r\n}\r\n\r\nlet defaultStyle: BaseStyle\r\n\r\nexport class BaseStyle extends EventTarget implements ColumnStyle {\r\n    private _bgColor?: ColorDef\r\n\r\n    static get EVENT_TYPE(): { CHANGE_STYLE: string } {\r\n    \treturn EVENT_TYPE\r\n    }\r\n\r\n    static get DEFAULT(): BaseStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new BaseStyle())\r\n    }\r\n\r\n    constructor({ bgColor }: BaseStyleOption = {}) {\r\n    \tsuper()\r\n    \tthis._bgColor = bgColor\r\n    }\r\n\r\n    get bgColor(): ColorDef | undefined {\r\n    \treturn this._bgColor\r\n    }\r\n\r\n    set bgColor(bgColor: ColorDef | undefined) {\r\n    \tthis._bgColor = bgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    doChangeStyle(): void {\r\n    \tthis.fireListeners(EVENT_TYPE.CHANGE_STYLE)\r\n    }\r\n\r\n    clone(): BaseStyle {\r\n    \treturn new BaseStyle(this)\r\n    }\r\n}\r\n","import type { CheckHeaderStyleOption, ColorDef } from '../../ts-types'\r\nimport { Style } from './Style'\r\nimport { defaults } from '../../internal/utils'\r\n\r\nlet defaultStyle: CheckHeaderStyle\r\n\r\nexport class CheckHeaderStyle extends Style {\r\n    private _uncheckBgColor?: ColorDef\r\n\r\n    private _checkBgColor?: ColorDef\r\n\r\n    private _borderColor?: ColorDef\r\n\r\n    static get DEFAULT(): CheckHeaderStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new CheckHeaderStyle())\r\n    }\r\n\r\n    constructor(style: CheckHeaderStyleOption = {}) {\r\n    \tsuper(defaults(style, { textAlign: 'center' }))\r\n    \tconst { uncheckBgColor, checkBgColor, borderColor } = style\r\n    \tthis._uncheckBgColor = uncheckBgColor\r\n    \tthis._checkBgColor = checkBgColor\r\n    \tthis._borderColor = borderColor\r\n    }\r\n\r\n    get uncheckBgColor(): ColorDef | undefined {\r\n    \treturn this._uncheckBgColor\r\n    }\r\n\r\n    set uncheckBgColor(uncheckBgColor: ColorDef | undefined) {\r\n    \tthis._uncheckBgColor = uncheckBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get checkBgColor(): ColorDef | undefined {\r\n    \treturn this._checkBgColor\r\n    }\r\n\r\n    set checkBgColor(checkBgColor: ColorDef | undefined) {\r\n    \tthis._checkBgColor = checkBgColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get borderColor(): ColorDef | undefined {\r\n    \treturn this._borderColor\r\n    }\r\n\r\n    set borderColor(borderColor: ColorDef | undefined) {\r\n    \tthis._borderColor = borderColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): CheckHeaderStyle {\r\n    \treturn new CheckHeaderStyle(this)\r\n    }\r\n}\r\n","import type { LineClamp, MultilineTextHeaderStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\n\r\nlet defaultStyle: MultilineTextHeaderStyle\r\n\r\nexport class MultilineTextHeaderStyle extends Style {\r\n    private _lineHeight: string | number\r\n\r\n    private _autoWrapText: boolean\r\n\r\n    private _lineClamp?: LineClamp\r\n\r\n    static get DEFAULT(): MultilineTextHeaderStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new MultilineTextHeaderStyle())\r\n    }\r\n\r\n    constructor(style: MultilineTextHeaderStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._lineHeight = style.lineHeight || '1em'\r\n    \tthis._autoWrapText = style.autoWrapText || false\r\n    \tthis._lineClamp = style.lineClamp\r\n    }\r\n\r\n    clone(): MultilineTextHeaderStyle {\r\n    \treturn new MultilineTextHeaderStyle(this)\r\n    }\r\n\r\n    get lineHeight(): string | number {\r\n    \treturn this._lineHeight\r\n    }\r\n\r\n    set lineHeight(lineHeight: string | number) {\r\n    \tthis._lineHeight = lineHeight\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get lineClamp(): LineClamp | undefined {\r\n    \treturn this._lineClamp\r\n    }\r\n\r\n    set lineClamp(lineClamp: LineClamp | undefined) {\r\n    \tthis._lineClamp = lineClamp\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get autoWrapText(): boolean {\r\n    \treturn this._autoWrapText\r\n    }\r\n\r\n    set autoWrapText(autoWrapText: boolean) {\r\n    \tthis._autoWrapText = autoWrapText\r\n    \tthis.doChangeStyle()\r\n    }\r\n}\r\n","import type { ColorDef, SortHeaderStyleOption } from '../../ts-types'\r\nimport { Style } from './Style'\r\n\r\nlet defaultStyle: SortHeaderStyle\r\n\r\nexport class SortHeaderStyle extends Style {\r\n    private _sortArrowColor?: ColorDef\r\n\r\n    static get DEFAULT(): SortHeaderStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new SortHeaderStyle())\r\n    }\r\n\r\n    constructor(style: SortHeaderStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._sortArrowColor = style.sortArrowColor\r\n    }\r\n\r\n    get sortArrowColor(): ColorDef | undefined {\r\n    \treturn this._sortArrowColor\r\n    }\r\n\r\n    set sortArrowColor(sortArrowColor: ColorDef | undefined) {\r\n    \tthis._sortArrowColor = sortArrowColor\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): SortHeaderStyle {\r\n    \treturn new SortHeaderStyle(this)\r\n    }\r\n}\r\n","import { BaseStyle } from './BaseStyle'\r\nimport type { StdBaseStyleOption } from '../../ts-types'\r\n\r\nlet defaultStyle: StdBaseStyle\r\n\r\nexport class StdBaseStyle extends BaseStyle {\r\n    private _textAlign: CanvasTextAlign\r\n\r\n    private _textBaseline: CanvasTextBaseline\r\n\r\n    static get DEFAULT(): StdBaseStyle {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new StdBaseStyle())\r\n    }\r\n\r\n    constructor(style: StdBaseStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._textAlign = style.textAlign || 'left'\r\n    \tthis._textBaseline = style.textBaseline || 'middle'\r\n    }\r\n\r\n    get textAlign(): CanvasTextAlign {\r\n    \treturn this._textAlign\r\n    }\r\n\r\n    set textAlign(textAlign: CanvasTextAlign) {\r\n    \tthis._textAlign = textAlign\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get textBaseline(): CanvasTextBaseline {\r\n    \treturn this._textBaseline\r\n    }\r\n\r\n    set textBaseline(textBaseline: CanvasTextBaseline) {\r\n    \tthis._textBaseline = textBaseline\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): StdBaseStyle {\r\n    \treturn new StdBaseStyle(this)\r\n    }\r\n}\r\n","import type { ColorDef, HeaderStdStyleOption, TextOverflow } from '../../ts-types'\r\nimport { StdBaseStyle } from './StdBaseStyle'\r\n\r\nlet defaultStyle: Style\r\n\r\nexport class Style extends StdBaseStyle {\r\n    private _color?: ColorDef\r\n\r\n    private _font?: string\r\n\r\n    private _textOverflow: TextOverflow\r\n\r\n    static get DEFAULT(): Style {\r\n    \treturn defaultStyle ? defaultStyle : (defaultStyle = new Style())\r\n    }\r\n\r\n    constructor(style: HeaderStdStyleOption = {}) {\r\n    \tsuper(style)\r\n    \tthis._color = style.color\r\n    \tthis._font = style.font\r\n    \tthis._textOverflow = style.textOverflow || 'ellipsis'\r\n    }\r\n\r\n    get color(): ColorDef | undefined {\r\n    \treturn this._color\r\n    }\r\n\r\n    set color(color: ColorDef | undefined) {\r\n    \tthis._color = color\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get font(): string | undefined {\r\n    \treturn this._font\r\n    }\r\n\r\n    set font(font: string | undefined) {\r\n    \tthis._font = font\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    get textOverflow(): TextOverflow {\r\n    \treturn this._textOverflow\r\n    }\r\n\r\n    set textOverflow(textOverflow: TextOverflow) {\r\n    \tthis._textOverflow = textOverflow\r\n    \tthis.doChangeStyle()\r\n    }\r\n\r\n    clone(): Style {\r\n    \treturn new Style(this)\r\n    }\r\n}\r\n","import { BaseHeader } from './type/BaseHeader'\r\nimport type { BaseHeaderDefine } from '../list-grid/layout-map/api'\r\nimport { CheckHeader } from './type/CheckHeader'\r\nimport { Header } from './type/Header'\r\nimport type { HeaderTypeOption } from '../ts-types'\r\nimport { MultilineTextHeader } from './type/MultilineTextHeader'\r\nimport { SortHeader } from './type/SortHeader'\r\n\r\nexport const TYPES = {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tDEFAULT: new Header<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tSORT: new SortHeader<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tCHECK: new CheckHeader<any>(),\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tMULTILINETEXT: new MultilineTextHeader<any>()\r\n}\r\nexport { BaseHeader, Header, SortHeader, CheckHeader, MultilineTextHeader }\r\n\r\nexport function of<T>(headerType: HeaderTypeOption | BaseHeader<T> | null | undefined): BaseHeader<T> {\r\n\tif (!headerType) {\r\n\t\treturn TYPES.DEFAULT\r\n\t} else if (typeof headerType === 'string') {\r\n\t\tconst key = headerType.toUpperCase() as keyof typeof TYPES\r\n\t\treturn TYPES[key] || of(null)\r\n\t} else {\r\n\t\treturn headerType\r\n\t}\r\n}\r\n\r\nexport function ofCell<T>(headerCell: BaseHeaderDefine<T>): BaseHeader<T> {\r\n\tif (headerCell.sort) {\r\n\t\treturn TYPES.SORT\r\n\t}\r\n\r\n\treturn of(headerCell.headerType)\r\n}\r\n","import * as styleContents from '../style'\r\nimport type { CellContext, EventListenerId, GridCanvasHelperAPI, HeaderStyleOption, LayoutObjectId, ListGridAPI } from '../../ts-types'\r\nimport { BaseStyle } from '../style/BaseStyle'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\n\r\nexport abstract class BaseHeader<T> {\r\n\tconstructor(_options = {}) {\r\n\t\tthis.onDrawCell = this.onDrawCell.bind(this) //\r\n\t}\r\n\r\n\tget StyleClass(): typeof BaseStyle {\r\n\t\treturn BaseStyle\r\n\t}\r\n\r\n\tonDrawCell(cellValue: unknown, info: DrawCellInfo<T>, context: CellContext, grid: ListGridAPI<T>): void {\r\n\t\tconst { style, drawCellBase } = info\r\n\t\tconst helper = grid.getGridCanvasHelper()\r\n\t\tdrawCellBase()\r\n\t\t//\r\n\t\tthis.drawInternal(this.convertInternal(cellValue), context, styleContents.of(style as HeaderStyleOption, this.StyleClass), helper, grid, info)\r\n\t}\r\n\r\n\tconvertInternal(value: unknown): string {\r\n\t\tif (typeof value === 'function') {\r\n\t\t\tvalue = value()\r\n\t\t}\r\n\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n\t\treturn value != null ? `${ value }` : ''\r\n\t}\r\n\r\n    abstract drawInternal(value: string, context: CellContext, style: BaseStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;\r\n\r\n    bindGridEvent(_grid: ListGridAPI<T>, _cellId: LayoutObjectId): EventListenerId[] {\r\n    \treturn []\r\n    }\r\n}\r\n","import type { CellContext, ColorPropertyDefine, GridCanvasHelperAPI } from '../../ts-types'\r\nimport type { CheckHeaderState, DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { BaseHeader } from './BaseHeader'\r\nimport { CheckHeaderStyle } from '../style/CheckHeaderStyle'\r\nimport { getCheckHeaderStateId } from '../../internal/symbolManager'\r\nimport { obj } from '../../internal/utils'\r\n\r\nconst CHECK_HEADER_STATE_ID = getCheckHeaderStateId()\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction getState<T>(grid: GridInternal<T>): CheckHeaderState {\r\n\tlet state = grid[CHECK_HEADER_STATE_ID]\r\n\tif (!state) {\r\n\t\tstate = { elapsed: {}, block: {} }\r\n\t\tobj.setReadonly(grid, CHECK_HEADER_STATE_ID, state)\r\n\t}\r\n\treturn state\r\n}\r\n\r\nexport class CheckHeader<T> extends BaseHeader<T> {\r\n\tget StyleClass(): typeof CheckHeaderStyle {\r\n\t\treturn CheckHeaderStyle\r\n\t}\r\n\r\n\tclone(): CheckHeader<T> {\r\n\t\treturn new CheckHeader(this)\r\n\t}\r\n\r\n\tdrawInternal(\r\n\t\t\tvalue: string,\r\n\t\t\tcontext: CellContext,\r\n\t\t\tstyle: CheckHeaderStyle,\r\n\t\t\thelper: GridCanvasHelperAPI,\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\tgrid: GridInternal<T>,\r\n\t\t\t{ drawCellBase }: DrawCellInfo<T>\r\n\t): void {\r\n\t\tconst { textAlign, textBaseline, borderColor, checkBgColor, uncheckBgColor, bgColor, color, font, textOverflow } = style\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tconst { col, row } = context\r\n\t\tconst range = grid.getCellRange(col, row)\r\n\t\tconst cellKey = `${ range.start.col }:${ range.start.row }`\r\n\t\tconst {\r\n\t\t\telapsed: { [cellKey]: elapsed }\r\n\t\t} = getState(grid)\r\n\r\n\t\tconst checked = grid.getHeaderValue(range.start.col, range.start.row)\r\n\r\n\t\tconst opt: {\r\n            animElapsedTime?: number;\r\n            uncheckBgColor?: ColorPropertyDefine;\r\n            checkBgColor?: ColorPropertyDefine;\r\n            borderColor?: ColorPropertyDefine;\r\n            textAlign?: CanvasTextAlign;\r\n            textBaseline?: CanvasTextBaseline;\r\n        } = {\r\n        \ttextAlign,\r\n        \ttextBaseline,\r\n        \tborderColor,\r\n        \tcheckBgColor,\r\n        \tuncheckBgColor\r\n        }\r\n\t\tif (elapsed != null) {\r\n\t\t\topt.animElapsedTime = elapsed\r\n\t\t}\r\n\t\tconst inlineCheck = helper.buildCheckBoxInline(!!checked, context, opt)\r\n\r\n\t\thelper.text([ inlineCheck, value ], context, {\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tcolor,\r\n\t\t\tfont,\r\n\t\t\ttextOverflow\r\n\t\t})\r\n\t}\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI, ListGridAPI } from '../../ts-types'\r\nimport { BaseHeader } from './BaseHeader'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { Style } from '../style/Style'\r\n\r\nexport class Header<T> extends BaseHeader<T> {\r\n\tget StyleClass(): typeof Style {\r\n\t\treturn Style\r\n\t}\r\n\r\n\tdrawInternal(value: string, context: CellContext, style: Style, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline, color, font, bgColor, textOverflow } = style\r\n\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\thelper.text(value, context, {\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tcolor,\r\n\t\t\tfont,\r\n\t\t\ttextOverflow\r\n\t\t})\r\n\t}\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI } from '../../ts-types'\r\nimport type { DrawCellInfo, GridInternal } from '../../ts-types-internal'\r\nimport { BaseHeader } from './BaseHeader'\r\nimport { MultilineTextHeaderStyle } from '../style/MultilineTextHeaderStyle'\r\n\r\nexport class MultilineTextHeader<T> extends BaseHeader<T> {\r\n\tget StyleClass(): typeof MultilineTextHeaderStyle {\r\n\t\treturn MultilineTextHeaderStyle\r\n\t}\r\n\r\n\tclone(): MultilineTextHeader<T> {\r\n\t\treturn new MultilineTextHeader(this)\r\n\t}\r\n\r\n\tdrawInternal(value: string, context: CellContext, style: MultilineTextHeaderStyle, helper: GridCanvasHelperAPI, _grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline, color, font, bgColor, lineHeight, autoWrapText, lineClamp, textOverflow } = style\r\n\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\t\tconst multilines = value.replace(/\\r?\\n/g, '\\n').replace(/\\r/g, '\\n').split('\\n')\r\n\t\thelper.testFontLoad(font, value, context)\r\n\t\thelper.multilineText(multilines, context, {\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tcolor,\r\n\t\t\tfont,\r\n\t\t\tlineHeight,\r\n\t\t\tautoWrapText,\r\n\t\t\tlineClamp,\r\n\t\t\ttextOverflow\r\n\t\t})\r\n\t}\r\n}\r\n","import type { CellContext, GridCanvasHelperAPI, ListGridAPI, SortState } from '../../ts-types'\r\nimport { BaseHeader } from './BaseHeader'\r\nimport type { DrawCellInfo } from '../../ts-types-internal'\r\nimport { SortHeaderStyle } from '../style/SortHeaderStyle'\r\nimport { cellInRange } from '../../internal/utils'\r\nimport { getFontSize } from '../../internal/canvases'\r\n\r\nexport class SortHeader<T> extends BaseHeader<T> {\r\n\tget StyleClass(): typeof SortHeaderStyle {\r\n\t\treturn SortHeaderStyle\r\n\t}\r\n\r\n\tdrawInternal(value: string, context: CellContext, style: SortHeaderStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, { drawCellBase }: DrawCellInfo<T>): void {\r\n\t\tconst { textAlign, textBaseline = 'middle', color, bgColor, font, textOverflow, sortArrowColor } = style\r\n\r\n\t\tif (bgColor) {\r\n\t\t\tdrawCellBase({\r\n\t\t\t\tbgColor\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tconst state = grid.sortState as SortState\r\n\t\tlet order = undefined\r\n\t\tconst { col, row } = context\r\n\t\tconst range = grid.getCellRange(col, row)\r\n\t\tif (cellInRange(range, state.col, state.row)) {\r\n\t\t\t({ order } = state)\r\n\t\t}\r\n\r\n\t\tconst ctx = context.getContext()\r\n\t\tconst arrowSize = getFontSize(ctx, font).width * 1.2\r\n\r\n\t\thelper.text(value, context, {\r\n\t\t\ttextAlign,\r\n\t\t\ttextBaseline,\r\n\t\t\tcolor,\r\n\t\t\tfont,\r\n\t\t\ttextOverflow,\r\n\t\t\ticons: [\r\n\t\t\t\t{\r\n\t\t\t\t\tname: order != null ? (order === 'asc' ? 'arrow_downward' : 'arrow_upward') : undefined,\r\n\t\t\t\t\twidth: arrowSize,\r\n\t\t\t\t\tcolor: helper.getColor(sortArrowColor || helper.theme.header.sortArrowColor, col, row, ctx) || 'rgba(0, 0, 0, 0.38)'\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t})\r\n\t}\r\n}\r\n","// import * as action from './header/action'\r\n// import * as style from './header/style'\r\n// import * as type from './header/type'\r\n\r\nimport { ACTIONS, BaseAction, BaseActionOption, CheckHeaderAction, ImmutableHeaderActions, SortHeaderAction, of as headerActionOf, ofCell as headerActionOfCell } from './header/action'\r\nimport {\r\n\tBaseStyle,\r\n\t// BaseStdStyle,\r\n\t// BaseCheckStyle,\r\n\tStyle,\r\n\tSortHeaderStyle,\r\n\tCheckHeaderStyle,\r\n\t// SwitchHeaderStyle,\r\n\tMultilineTextHeaderStyle,\r\n\tof as headerStyleOf\r\n} from './header/style'\r\nimport {\r\n\tTYPES,\r\n\tBaseHeader,\r\n\t// BaseCheckHeader,\r\n\tHeader,\r\n\tSortHeader,\r\n\tCheckHeader,\r\n\t// SwitchHeader,\r\n\tMultilineTextHeader,\r\n\tof as headerTypeOf,\r\n\tofCell as headerTypeOfCell\r\n} from './header/type'\r\n\r\nconst action = {\r\n\tACTIONS: ACTIONS as ImmutableHeaderActions,\r\n\tBaseAction,\r\n\t// BaseCheckAction,\r\n\tSortHeaderAction,\r\n\tCheckHeaderAction,\r\n\t// SwitchHeaderAction,\r\n\tof: headerActionOf,\r\n\tofCell: headerActionOfCell\r\n}\r\nconst style = {\r\n\tBaseStyle,\r\n\t// BaseStdStyle,\r\n\t// BaseCheckStyle,\r\n\tStyle,\r\n\tSortHeaderStyle,\r\n\tCheckHeaderStyle,\r\n\t// SwitchHeaderStyle,\r\n\tMultilineTextHeaderStyle,\r\n\tof: headerStyleOf\r\n}\r\nconst type = {\r\n\tTYPES,\r\n\tBaseHeader,\r\n\t// BaseCheckHeader,\r\n\tHeader,\r\n\tSortHeader,\r\n\tCheckHeader,\r\n\t// SwitchHeader,\r\n\tMultilineTextHeader,\r\n\tof: headerTypeOf,\r\n\tofCell: headerTypeOfCell\r\n}\r\n/**\r\n * header classes\r\n */\r\nexport const headers = { action, type, style }\r\n","//\r\n// /!*eslint-disable camelcase*!/\r\n//\r\n// import type { IconDefine } from './ts-types'\r\n// import { extend } from './internal/utils'\r\n// import { icons as plugins } from './plugins/icons'\r\n//\r\n// const builtins = {\r\n//     get arrow_upward(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_arrow_upward_48px.svg')\r\n//     },\r\n//     get arrow_downward(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_arrow_downward_48px.svg')\r\n//     },\r\n//     get edit(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/image/svg/production/ic_edit_48px.svg')\r\n//     },\r\n//     get add(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/content/svg/production/ic_add_48px.svg')\r\n//     },\r\n//     get star(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_24px.svg')\r\n//     },\r\n//     get star_border(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_border_24px.svg')\r\n//     },\r\n//     get star_half(): IconDefine {\r\n//         return require('cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_half_24px.svg')\r\n//     }\r\n// }\r\n//\r\n// export function get(): { [key: string]: IconDefine } {\r\n//     return extend(builtins, plugins)\r\n// }\r\n//\r\n// export const svgIcons = {\r\n//     get(): { [key: string]: IconDefine } {\r\n//         return extend(builtins, plugins)\r\n//     }\r\n// }\r\n//\r\nimport type { IconDefine } from './ts-types'\r\nimport { extend } from './internal/utils'\r\nimport { icons as plugins } from './plugins/icons'\r\nimport add from './icons/ic_add_48px.svg'\r\nimport edit from './icons/ic_edit_48px.svg'\r\nimport arrowDownward from './icons/ic_arrow_downward_48px.svg'\r\nimport arrowUpward from './icons/ic_arrow_upward_48px.svg'\r\nimport star from './icons/ic_star_24px.svg'\r\nimport starBorder from './icons/ic_star_border_24px.svg'\r\nimport starHalf from './icons/ic_star_half_24px.svg'\r\nimport svgToIcon from './tools/svgToIcon'\r\n\r\nconst builtins = {\r\n\tadd: svgToIcon(add),\r\n\tarrowDownward: svgToIcon(arrowDownward),\r\n\tarrowUpward: svgToIcon(arrowUpward),\r\n\tedit: svgToIcon(edit),\r\n\tstar: svgToIcon(star),\r\n\tstarBorder: svgToIcon(starBorder),\r\n\tstarHalf: svgToIcon(starHalf)\r\n}\r\nexport const svgIcons = {\r\n\tget(): { [key: string]: IconDefine } {\r\n\t\treturn extend(builtins, plugins)\r\n\t}\r\n}\r\n","import type { AnyFunction, EventListenerId } from '../ts-types'\r\nimport type { EventTarget as CustomEventTarget } from '../core/EventTarget'\r\nimport { each } from './utils'\r\n\r\n/** @private */\r\nlet nextId = 1\r\n\r\n/** @private */\r\ntype EventHandlerTarget = EventTarget | CustomEventTarget;\r\n/** @private */\r\ntype Listener = AnyFunction;\r\n/** @private */\r\ntype EventListenerObject = {\r\n    target: EventHandlerTarget;\r\n    type: string;\r\n    listener: Listener;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    options: any[];\r\n};\r\n\r\nexport class EventHandler {\r\n    private _listeners: {\r\n        [key: string]: EventListenerObject;\r\n    } = {}\r\n\r\n    on<TYPE extends keyof GlobalEventHandlersEventMap>(\r\n        target: EventHandlerTarget,\r\n        type: TYPE,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        listener: (event: GlobalEventHandlersEventMap[TYPE]) => any,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        ...options: any[]\r\n    ): EventListenerId;\r\n\r\n    on(\r\n        target: EventHandlerTarget,\r\n        type: string,\r\n        listener: Listener,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        ...options: any[]\r\n    ): EventListenerId;\r\n\r\n    on(\r\n    \t\ttarget: EventHandlerTarget,\r\n    \t\ttype: string,\r\n    \t\tlistener: Listener,\r\n    \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t...options: any[]\r\n    ): EventListenerId {\r\n    \tif (target.addEventListener) {\r\n    \t\ttarget.addEventListener(type, listener, ...(options as []))\r\n    \t}\r\n    \tconst obj = {\r\n    \t\ttarget,\r\n    \t\ttype,\r\n    \t\tlistener,\r\n    \t\toptions\r\n    \t}\r\n    \tconst id = nextId++\r\n    \tthis._listeners[id] = obj\r\n    \treturn id\r\n    }\r\n\r\n    once<TYPE extends keyof GlobalEventHandlersEventMap>(\r\n        target: EventHandlerTarget,\r\n        type: TYPE,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        listener: (event: GlobalEventHandlersEventMap[TYPE]) => any,\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        ...options: any[]\r\n    ): EventListenerId;\r\n\r\n    once(target: EventHandlerTarget, type: string, listener: Listener, ...options: (boolean | AddEventListenerOptions)[]): EventListenerId;\r\n\r\n    once(target: EventHandlerTarget, type: string, listener: Listener, ...options: (boolean | AddEventListenerOptions)[]): EventListenerId {\r\n    \tconst id = this.on(\r\n    \t\t\ttarget,\r\n    \t\t\ttype,\r\n    \t\t\t(...args) => {\r\n    \t\t\t\tthis.off(id)\r\n    \t\t\t\tlistener(...args)\r\n    \t\t\t},\r\n    \t\t\t...options\r\n    \t)\r\n    \treturn id\r\n    }\r\n\r\n    tryWithOffEvents(target: EventHandlerTarget, type: string, call: () => void): void {\r\n    \tconst list: EventListenerObject[] = []\r\n    \ttry {\r\n    \t\teach(this._listeners, (obj) => {\r\n    \t\t\tif (obj.target === target && obj.type === type) {\r\n    \t\t\t\tif (obj.target.removeEventListener) {\r\n    \t\t\t\t\tobj.target.removeEventListener(obj.type, obj.listener, ...(obj.options as []))\r\n    \t\t\t\t}\r\n    \t\t\t\tlist.push(obj)\r\n    \t\t\t}\r\n    \t\t})\r\n    \t\tcall()\r\n    \t} finally {\r\n    \t\tlist.forEach((obj) => {\r\n    \t\t\tif (obj.target.addEventListener) {\r\n    \t\t\t\tobj.target.addEventListener(obj.type, obj.listener, ...(obj.options as []))\r\n    \t\t\t}\r\n    \t\t})\r\n    \t}\r\n    }\r\n\r\n    off(id: EventListenerId | null | undefined): void {\r\n    \tif (id == null) {\r\n    \t\treturn\r\n    \t}\r\n    \tconst obj = this._listeners[id]\r\n    \tif (!obj) {\r\n    \t\treturn\r\n    \t}\r\n    \tdelete this._listeners[id]\r\n    \tif (obj.target.removeEventListener) {\r\n    \t\tobj.target.removeEventListener(obj.type, obj.listener, ...(obj.options as []))\r\n    \t}\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    fire(target: EventTarget, type: string, ...args: any[]): void {\r\n    \teach(this._listeners, (obj) => {\r\n    \t\tif (obj.target === target && obj.type === type) {\r\n    \t\t\tobj.listener.call(obj.target, ...args)\r\n    \t\t}\r\n    \t})\r\n    }\r\n\r\n    hasListener(target: EventTarget, type: string): boolean {\r\n    \tlet result = false\r\n    \teach(this._listeners, (obj) => {\r\n    \t\tif (obj.target === target && obj.type === type) {\r\n    \t\t\tresult = true\r\n    \t\t}\r\n    \t})\r\n    \treturn result\r\n    }\r\n\r\n    clear(): void {\r\n    \teach(this._listeners, (obj) => {\r\n    \t\tif (obj.target.removeEventListener) {\r\n    \t\t\tobj.target.removeEventListener(obj.type, obj.listener, ...(obj.options as []))\r\n    \t\t}\r\n    \t})\r\n    \tthis._listeners = {}\r\n    }\r\n\r\n    dispose(): void {\r\n    \tthis.clear();\r\n    \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t(this as any)._listeners = null\r\n    }\r\n}\r\n","export class LRUCache<T> {\n    private _list: string[]\n\n    private _map: { [key: string]: T }\n\n    private _cacheSize: number\n\n    constructor(cacheSize: number) {\n    \tthis._list = []\n    \tthis._map = {}\n    \tthis._cacheSize = cacheSize || 50\n    }\n\n    get(key: string): T {\n    \tconst val = this._map[key]\n    \tif (val) {\n    \t\tconst list = this._list\n    \t\tconst idx = list.indexOf(key)\n    \t\tlist.splice(idx, 1)\n    \t\tlist.push(key)\n    \t}\n    \treturn val\n    }\n\n    put(key: string, value: T): void {\n    \tconst list = this._list\n    \tconst map = this._map\n    \tif (map[key]) {\n    \t\tconst idx = list.indexOf(key)\n    \t\tlist.splice(idx, 1)\n    \t}\n    \tmap[key] = value\n    \tlist.push(key)\n    \tif (list.length > this._cacheSize) {\n    \t\tconst remKey = list.shift() || ''\n    \t\tdelete map[remKey]\n    \t}\n    }\n}\n","const indexFirst = (arr: number[], elm: number): number => {\r\n\tlet low = 0\r\n\tlet high = arr.length - 1\r\n\twhile (low <= high) {\r\n\t\tconst i = Math.floor((low + high) / 2)\r\n\t\tif (arr[i] === elm) {\r\n\t\t\treturn i\r\n\t\t} else if (arr[i] > elm) {\r\n\t\t\thigh = i - 1\r\n\t\t} else {\r\n\t\t\tlow = i + 1\r\n\t\t}\r\n\t}\r\n\treturn high < 0 ? 0 : high\r\n}\r\n\r\nexport class NumberMap<T> {\r\n    private _keys: number[] = []\r\n\r\n    private _vals: { [key: number]: T } = {}\r\n\r\n    private _sorted = false\r\n\r\n    put(key: number, value: T): void {\r\n    \tif (!(key in this._vals)) {\r\n    \t\tthis._keys.push(key)\r\n    \t\tthis._sorted = false\r\n    \t}\r\n    \tthis._vals[key] = value\r\n    }\r\n\r\n    get(key: number): T | undefined {\r\n    \treturn this._vals[key]\r\n    }\r\n\r\n    has(key: number): boolean {\r\n    \treturn this._vals[key] != null\r\n    }\r\n\r\n    each(keyFrom: number, keyTo: number, fn: (t: T, k: number) => void): void {\r\n    \tconst { _keys: keys } = this\r\n    \tconst { length } = keys\r\n    \tif (!this._sorted) {\r\n    \t\tkeys.sort((a, b) => {\r\n    \t\t\tif (a < b) {\r\n    \t\t\t\treturn -1\r\n    \t\t\t}\r\n    \t\t\tif (a > b) {\r\n    \t\t\t\treturn 1\r\n    \t\t\t}\r\n    \t\t\treturn 0\r\n    \t\t})\r\n    \t\tthis._sorted = true\r\n    \t}\r\n\r\n    \tfor (let i = indexFirst(keys, keyFrom); i < length; i++) {\r\n    \t\tconst key = keys[i]\r\n    \t\tif (keyFrom <= key && key <= keyTo) {\r\n    \t\t\tfn(this.get(key) as T, key)\r\n    \t\t} else if (keyTo < key) {\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t}\r\n    }\r\n}\r\n","import type { RectProps } from '../ts-types'\r\n\r\nexport class Rect implements RectProps {\r\n    private _left: number\r\n\r\n    private _top: number\r\n\r\n    private _width: number\r\n\r\n    private _height: number\r\n\r\n    private _right: number | undefined\r\n\r\n    private _bottom: number | undefined\r\n\r\n    constructor(left: number, top: number, width: number, height: number) {\r\n    \tthis._left = left\r\n    \tthis._top = top\r\n    \tthis._width = width\r\n    \tthis._height = height\r\n    }\r\n\r\n    static bounds(left: number, top: number, right: number, bottom: number): Rect {\r\n    \treturn new Rect(left, top, right - left, bottom - top)\r\n    }\r\n\r\n    static max(rect1: Rect, rect2: Rect): Rect {\r\n    \treturn Rect.bounds(Math.min(rect1.left, rect2.left), Math.min(rect1.top, rect2.top), Math.max(rect1.right, rect2.right), Math.max(rect1.bottom, rect2.bottom))\r\n    }\r\n\r\n    get left(): number {\r\n    \treturn this._left\r\n    }\r\n\r\n    set left(left: number) {\r\n    \tconst { right } = this\r\n    \tthis._left = left\r\n    \tthis.right = right\r\n    }\r\n\r\n    get top(): number {\r\n    \treturn this._top\r\n    }\r\n\r\n    set top(top: number) {\r\n    \tconst { bottom } = this\r\n    \tthis._top = top\r\n    \tthis.bottom = bottom\r\n    }\r\n\r\n    get width(): number {\r\n    \treturn this._width\r\n    }\r\n\r\n    set width(width: number) {\r\n    \tthis._width = width\r\n    \tthis._right = undefined\r\n    }\r\n\r\n    get height(): number {\r\n    \treturn this._height\r\n    }\r\n\r\n    set height(height: number) {\r\n    \tthis._height = height\r\n    \tthis._bottom = undefined\r\n    }\r\n\r\n    get right(): number {\r\n    \treturn this._right !== undefined ? this._right : (this._right = this.left + this.width)\r\n    }\r\n\r\n    set right(right: number) {\r\n    \tthis._right = right\r\n    \tthis.width = right - this.left\r\n    }\r\n\r\n    get bottom(): number {\r\n    \treturn this._bottom !== undefined ? this._bottom : (this._bottom = this.top + this.height)\r\n    }\r\n\r\n    set bottom(bottom: number) {\r\n    \tthis._bottom = bottom\r\n    \tthis.height = bottom - this.top\r\n    }\r\n\r\n    offsetLeft(offset: number): void {\r\n    \tthis._left += offset\r\n    \tthis._right = undefined\r\n    }\r\n\r\n    offsetTop(offset: number): void {\r\n    \tthis._top += offset\r\n    \tthis._bottom = undefined\r\n    }\r\n\r\n    copy(): Rect {\r\n    \treturn new Rect(this.left, this.top, this.width, this.height)\r\n    }\r\n\r\n    intersection(rect: Rect): Rect | null {\r\n    \tconst x0 = Math.max(this.left, rect.left)\r\n    \tconst x1 = Math.min(this.left + this.width, rect.left + rect.width)\r\n    \tif (x0 <= x1) {\r\n    \t\tconst y0 = Math.max(this.top, rect.top)\r\n    \t\tconst y1 = Math.min(this.top + this.height, rect.top + rect.height)\r\n    \t\tif (y0 <= y1) {\r\n    \t\t\treturn Rect.bounds(x0, y0, x1, y1)\r\n    \t\t}\r\n    \t}\r\n    \treturn null\r\n    }\r\n\r\n    contains(another: Rect): boolean {\r\n    \treturn this.left <= another.left && this.left + this.width >= another.left + another.width && this.top <= another.top && this.top + this.height >= another.top + another.height\r\n    }\r\n\r\n    inPoint(x: number, y: number): boolean {\r\n    \treturn this.left <= x && this.left + this.width >= x && this.top <= y && this.top + this.height >= y\r\n    }\r\n}\r\n","import * as style from './style'\r\nimport { EventHandler } from './EventHandler'\r\nimport { browser } from './utils'\r\n\r\nconst MAX_SCROLL = browser.heightLimit - 1000\r\n\r\nexport class Scrollable {\r\n    private _handler: EventHandler\r\n\r\n    private _scrollable: HTMLDivElement\r\n\r\n    private _height: number\r\n\r\n    private _width: number\r\n\r\n    private _endPointElement: HTMLDivElement\r\n\r\n    private _p = 1\r\n\r\n    constructor() {\r\n    \tthis._handler = new EventHandler()\r\n\r\n    \tthis._scrollable = document.createElement('div')\r\n    \tthis._scrollable.classList.add('grid-scrollable')\r\n    \tthis._height = 0\r\n    \tthis._width = 0\r\n\r\n    \tthis._endPointElement = document.createElement('div')\r\n    \tthis._endPointElement.classList.add('grid-scroll-end-point')\r\n    \tthis._update()\r\n    \tthis._scrollable.appendChild(this._endPointElement)\r\n\r\n    \t// const mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? 'DOMMouseScroll' : 'mousewheel'; //FF doesn't recognize mousewheel as of FF3.x\r\n    \t// this._handler.on(this._scrollable, mousewheelevt, (evt) => {\r\n    \t// const delta = evt.detail ? evt.detail * (-120) : evt.wheelDelta;\r\n    \t// const point = Math.min(Math.abs(delta) / 12, this.scrollHeight / 5);\r\n    \t// this.scrollTop += delta < 0 ? point : -point;\r\n    \t// });\r\n    }\r\n\r\n    calcTop(top: number): number {\r\n    \tconst relativeTop = top - this.scrollTop\r\n    \treturn this._scrollable.scrollTop + relativeTop\r\n    }\r\n\r\n    getElement(): HTMLDivElement {\r\n    \treturn this._scrollable\r\n    }\r\n\r\n    setScrollSize(width: number, height: number): void {\r\n    \tthis._width = width\r\n    \tthis._height = height\r\n    \tthis._update()\r\n    }\r\n\r\n    get scrollWidth(): number {\r\n    \treturn this._width\r\n    }\r\n\r\n    set scrollWidth(width: number) {\r\n    \tthis._width = width\r\n    \tthis._update()\r\n    }\r\n\r\n    get scrollHeight(): number {\r\n    \treturn this._height\r\n    }\r\n\r\n    set scrollHeight(height: number) {\r\n    \tthis._height = height\r\n    \tthis._update()\r\n    }\r\n\r\n    get scrollLeft(): number {\r\n    \treturn Math.max(Math.ceil(this._scrollable.scrollLeft), 0)\r\n    }\r\n\r\n    set scrollLeft(scrollLeft: number) {\r\n    \tthis._scrollable.scrollLeft = scrollLeft\r\n    }\r\n\r\n    get scrollTop(): number {\r\n    \treturn Math.max(Math.ceil(this._scrollable.scrollTop / this._p), 0)\r\n    }\r\n\r\n    set scrollTop(scrollTop: number) {\r\n    \tthis._scrollable.scrollTop = scrollTop * this._p\r\n    }\r\n\r\n    onScroll(fn: (evt: Event) => void): void {\r\n    \tthis._handler.on(this._scrollable, 'scroll', fn)\r\n    }\r\n\r\n    dispose(): void {\r\n    \tthis._handler.dispose()\r\n    }\r\n\r\n    private _update(): void {\r\n    \tlet domHeight\r\n    \tif (this._height > MAX_SCROLL) {\r\n    \t\tconst sbSize = style.getScrollBarSize()\r\n    \t\tconst { offsetHeight } = this._scrollable\r\n    \t\tconst vScrollRange = MAX_SCROLL - offsetHeight + sbSize\r\n    \t\tconst rScrollRange = this._height - offsetHeight + sbSize\r\n    \t\tthis._p = vScrollRange / rScrollRange\r\n    \t\tdomHeight = MAX_SCROLL\r\n    \t} else {\r\n    \t\tthis._p = 1\r\n    \t\tdomHeight = this._height\r\n    \t}\r\n\r\n    \tthis._endPointElement.style.top = `${ domHeight.toFixed() }px`\r\n    \tthis._endPointElement.style.left = `${ this._width.toFixed() }px`\r\n    }\r\n}\r\n","import { isNode } from './utils'\r\n\r\nfunction cubicBezier(x2: number, y2: number, x3: number, y3: number): EasingFunction {\r\n\tlet step: number\r\n\tconst err = 0.0001\r\n\r\n\tx2 *= 3\r\n\ty2 *= 3\r\n\tx3 *= 3\r\n\ty3 *= 3\r\n\r\n\treturn function(t: number): number {\r\n\t\tlet p, a, b, c, d, x, s\r\n\t\tif (t < 0 || 1 < t) {\r\n\t\t\tthrow new Error(`${ t }`)\r\n\t\t}\r\n\r\n\t\tp = step || t\r\n\r\n\t\tdo {\r\n\t\t\ta = 1 - p\r\n\t\t\tb = a * a\r\n\t\t\tc = p * p\r\n\t\t\td = c * p\r\n\r\n\t\t\tx = x2 * b * p + x3 * a * c + d\r\n\t\t\ts = t - x\r\n\t\t\tp += s * 0.5\r\n\t\t} while (err < Math.abs(s))\r\n\r\n\t\tstep = p\r\n\t\treturn y2 * b * p + y3 * a * c + d\r\n\t}\r\n}\r\n\r\nconst EASINGS = {\r\n\tlinear(p: number): number {\r\n\t\treturn p\r\n\t},\r\n\teaseIn: cubicBezier(0.42, 0.0, 1.0, 1.0),\r\n\teaseOut: cubicBezier(0.0, 0.0, 0.58, 1.0),\r\n\teaseInOut: cubicBezier(0.42, 0.0, 0.58, 1.0)\r\n}\r\n\r\nconst raf: typeof requestAnimationFrame = (\r\n    isNode\r\n    \t? (): void => {\r\n    \t}\r\n    \t: window.requestAnimationFrame ||\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        ((fn: () => void): any => setTimeout(fn, 1))\r\n) as typeof requestAnimationFrame\r\n\r\nfunction now(): number {\r\n\treturn Date.now()\r\n}\r\n\r\nexport type EasingFunction = (t: number) => number;\r\nexport type EasingKind = keyof typeof EASINGS;\r\nexport type StepFunction = (s: number) => void;\r\n\r\n/**\r\n * <pre>\r\n * Animates.\r\n * </pre>\r\n * @function\r\n * @param {number} duration animation time.\r\n * @param {function} step step\r\n * @param {function|string} easing easing\r\n * @returns {object} Deferred object.\r\n */\r\nexport function animate(\r\n\t\tduration: number,\r\n\t\tstep: StepFunction,\r\n\t\teasing?: EasingKind | EasingFunction\r\n): {\r\n    cancel: () => void;\r\n} {\r\n\tconst startedAt = now()\r\n\r\n\tconst easingFn: EasingFunction = easing == null ? EASINGS.easeInOut : typeof easing === 'string' ? EASINGS[easing] : easing\r\n\r\n\tlet canceledFlg = false\r\n\tconst createAnim = (resolve: () => void, reject: () => void): (() => void) => {\r\n\t\tconst anim = (): void => {\r\n\t\t\tconst point = now() - startedAt\r\n\t\t\tif (canceledFlg) {\r\n\t\t\t\t//cancel\r\n\t\t\t\tif (reject) {\r\n\t\t\t\t\treject()\r\n\t\t\t\t}\r\n\t\t\t} else if (point >= duration) {\r\n\t\t\t\t//end\r\n\t\t\t\tstep(1)\r\n\t\t\t\tif (resolve) {\r\n\t\t\t\t\tresolve()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstep(easingFn(point / duration))\r\n\r\n\t\t\t\traf(anim)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn anim\r\n\t}\r\n\tconst cancel = (): void => {\r\n\t\tcanceledFlg = true\r\n\t}\r\n\tif (typeof Promise !== 'undefined') {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tconst result: any = new Promise<void>((resolve, reject) => {\r\n\t\t\tconst anim = createAnim(resolve, reject)\r\n\t\t\tstep(0)\r\n\t\t\tanim()\r\n\t\t})\r\n\t\tresult.cancel = cancel\r\n\t\treturn result\r\n\t} else {\r\n\t\tconst anim = createAnim(\r\n\t\t\t\t() => {\r\n\t\t\t\t},\r\n\t\t\t\t() => {\r\n\t\t\t\t}\r\n\t\t)\r\n\t\tstep(0)\r\n\t\tanim()\r\n\t\treturn {\r\n\t\t\tcancel\r\n\t\t}\r\n\t}\r\n}\r\n","import { array } from './utils'\r\n\r\nconst TYPE_PAREN = 0\r\nconst TYPE_UNIT = 1\r\nconst TYPE_OPERATOR = 2\r\nconst TYPE_NUMBER = 3\r\n\r\nconst NODE_TYPE_UNIT = 10\r\nconst NODE_TYPE_BINARY_EXPRESSION = 11\r\nconst NODE_TYPE_NUMBER = 12\r\n\r\ntype Ops = '-' | '+' | '*' | '/';\r\ntype ParenToken = {\r\n    value: '(' | ')';\r\n    type: typeof TYPE_PAREN;\r\n};\r\ntype UnitToken = {\r\n    unit: string;\r\n    value: number;\r\n    type: typeof TYPE_UNIT;\r\n};\r\ntype OpToken = {\r\n    value: Ops;\r\n    type: typeof TYPE_OPERATOR;\r\n};\r\ntype NumToken = {\r\n    value: number;\r\n    type: typeof TYPE_NUMBER;\r\n};\r\ntype Token = ParenToken | UnitToken | OpToken | NumToken;\r\ntype UnitNode = {\r\n    nodeType: typeof NODE_TYPE_UNIT;\r\n    unit: string;\r\n    value: number;\r\n};\r\ntype BinaryNode = {\r\n    nodeType: typeof NODE_TYPE_BINARY_EXPRESSION;\r\n    left: Node;\r\n    op: OpToken;\r\n    right: Node;\r\n};\r\ntype NumNode = {\r\n    nodeType: typeof NODE_TYPE_NUMBER;\r\n    value: number;\r\n};\r\ntype Node = UnitNode | BinaryNode | NumNode;\r\n\r\nconst TABULATION = 0x09\r\nconst CARRIAGE_RETURN = 0x0d\r\nconst LINE_FEED = 0x0a\r\nconst FORM_FEED = 0x0c\r\nconst SPACE = 0x20\r\nconst PERCENT = 0x25\r\nconst FULL_STOP = 0x2e\r\nconst DIGIT_0 = 0x30\r\nconst DIGIT_9 = 0x39\r\nconst LATIN_CAPITAL_A = 0x41\r\nconst LATIN_CAPITAL_Z = 0x5a\r\nconst LATIN_SMALL_A = 0x61\r\nconst LATIN_SMALL_Z = 0x7a\r\n\r\nfunction isUpperLetter(cp: number): boolean {\r\n\treturn cp >= LATIN_CAPITAL_A && cp <= LATIN_CAPITAL_Z\r\n}\r\n\r\nfunction isLowerLetter(cp: number): boolean {\r\n\treturn cp >= LATIN_SMALL_A && cp <= LATIN_SMALL_Z\r\n}\r\n\r\nfunction isLetter(cp: number): boolean {\r\n\treturn isLowerLetter(cp) || isUpperLetter(cp)\r\n}\r\n\r\nfunction isWhitespace(cp: number): boolean {\r\n\treturn cp === TABULATION || cp === LINE_FEED || cp === FORM_FEED || cp === CARRIAGE_RETURN || cp === SPACE\r\n}\r\n\r\nfunction isDigit(cp: number): boolean {\r\n\treturn cp >= DIGIT_0 && cp <= DIGIT_9\r\n}\r\n\r\nfunction isDot(cp: number): boolean {\r\n\treturn cp === FULL_STOP\r\n}\r\n\r\nfunction isUnit(cp: number): boolean {\r\n\treturn isLetter(cp) || cp === PERCENT\r\n}\r\n\r\nfunction createError(calc: string): Error {\r\n\treturn new Error(`calc parse error: ${ calc }`)\r\n}\r\n\r\n/**\r\n * tokenize\r\n * @param {string} calc calc expression\r\n * @returns {Array} tokens\r\n * @private\r\n */\r\nfunction tokenize(calc: string): Token[] {\r\n\tconst exp = calc.replace(/calc\\(/g, '(').trim()\r\n\r\n\tconst tokens: Token[] = []\r\n\tconst len = exp.length\r\n\tfor (let index = 0; index < len; index++) {\r\n\t\tconst c = exp[index]\r\n\t\tconst cp = c.charCodeAt(0)\r\n\t\tif (c === '(' || c === ')') {\r\n\t\t\ttokens.push({ value: c, type: TYPE_PAREN })\r\n\t\t} else if (c === '*' || c === '/') {\r\n\t\t\ttokens.push({ value: c, type: TYPE_OPERATOR })\r\n\t\t} else if (c === '+' || c === '-') {\r\n\t\t\tindex = parseSign(c, index + 1) - 1\r\n\t\t} else if (isDigit(cp) || isDot(cp)) {\r\n\t\t\tindex = parseNum(c, index + 1) - 1\r\n\t\t} else if (isWhitespace(cp)) {\r\n\t\t\t// skip\r\n\t\t} else {\r\n\t\t\tthrow createError(calc)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parseSign(sign: '+' | '-', start: number): number {\r\n\t\tif (start < len) {\r\n\t\t\tconst c = exp[start]\r\n\t\t\tconst cp = c.charCodeAt(0)\r\n\t\t\tif (isDigit(cp) || isDot(cp)) {\r\n\t\t\t\treturn parseNum(sign + c, start + 1)\r\n\t\t\t}\r\n\t\t}\r\n\t\ttokens.push({ value: sign, type: TYPE_OPERATOR })\r\n\t\treturn start\r\n\t}\r\n\r\n\tfunction parseNum(num: string, start: number): number {\r\n\t\tlet index = start\r\n\t\tfor (; index < len; index++) {\r\n\t\t\tconst c = exp[index]\r\n\t\t\tconst cp = c.charCodeAt(0)\r\n\t\t\tif (isDigit(cp)) {\r\n\t\t\t\tnum += c\r\n\t\t\t} else if (c === '.') {\r\n\t\t\t\tif (num.indexOf('.') >= 0) {\r\n\t\t\t\t\tthrow createError(calc)\r\n\t\t\t\t}\r\n\t\t\t\tnum += c\r\n\t\t\t} else if (isUnit(cp)) {\r\n\t\t\t\treturn parseUnit(num, c, index + 1)\r\n\t\t\t} else {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (num === '.') {\r\n\t\t\tthrow createError(calc)\r\n\t\t}\r\n\t\ttokens.push({ value: parseFloat(num), type: TYPE_NUMBER })\r\n\t\treturn index\r\n\t}\r\n\r\n\tfunction parseUnit(num: string, unit: string, start: number): number {\r\n\t\tlet index = start\r\n\t\tfor (; index < len; index++) {\r\n\t\t\tconst c = exp[index]\r\n\t\t\tconst cp = c.charCodeAt(0)\r\n\t\t\tif (isUnit(cp)) {\r\n\t\t\t\tunit += c\r\n\t\t\t} else {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\ttokens.push({ value: parseFloat(num), unit, type: TYPE_UNIT })\r\n\t\treturn index\r\n\t}\r\n\r\n\treturn tokens\r\n}\r\n\r\nconst PRECEDENCE = {\r\n\t'*': 3,\r\n\t'/': 3,\r\n\t'+': 2,\r\n\t'-': 2\r\n}\r\n\r\nfunction lex(tokens: Token[], calc: string): Node {\r\n\tfunction buildBinaryExpNode(stack: (Node | OpToken)[]): BinaryNode {\r\n\t\tconst right = stack.pop() as Node\r\n\t\tconst op = stack.pop() as OpToken\r\n\t\tconst left = stack.pop() as Node\r\n\r\n\t\tif (!left || !left.nodeType || !op || op.type !== TYPE_OPERATOR || !right || !right.nodeType) {\r\n\t\t\tthrow createError(calc)\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tnodeType: NODE_TYPE_BINARY_EXPRESSION,\r\n\t\t\tleft,\r\n\t\t\top,\r\n\t\t\tright\r\n\t\t}\r\n\t}\r\n\r\n\tconst stack: (Node | OpToken)[] = []\r\n\r\n\twhile (tokens.length) {\r\n\t\tconst token = tokens.shift() as Token\r\n\t\tif (token.type === TYPE_PAREN && token.value === '(') {\r\n\t\t\tlet deep = 0\r\n\t\t\tconst closeIndex = array.findIndex(tokens, (t) => {\r\n\t\t\t\tif (t.type === TYPE_PAREN && t.value === '(') {\r\n\t\t\t\t\tdeep++\r\n\t\t\t\t} else if (t.type === TYPE_PAREN && t.value === ')') {\r\n\t\t\t\t\tif (!deep) {\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdeep--\r\n\t\t\t\t}\r\n\t\t\t\treturn false\r\n\t\t\t})\r\n\t\t\tif (closeIndex === -1) {\r\n\t\t\t\tthrow createError(calc)\r\n\t\t\t}\r\n\r\n\t\t\tstack.push(lex(tokens.splice(0, closeIndex), calc))\r\n\t\t\ttokens.shift()\r\n\t\t} else if (token.type === TYPE_OPERATOR) {\r\n\t\t\tif (stack.length >= 3) {\r\n\t\t\t\tconst beforeOp = (stack[stack.length - 2] as OpToken).value\r\n\t\t\t\tif (PRECEDENCE[token.value] <= PRECEDENCE[beforeOp]) {\r\n\t\t\t\t\tstack.push(buildBinaryExpNode(stack))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstack.push(token)\r\n\t\t} else if (token.type === TYPE_UNIT) {\r\n\t\t\tconst { value: num, unit } = token\r\n\t\t\tstack.push({\r\n\t\t\t\tnodeType: NODE_TYPE_UNIT,\r\n\t\t\t\tvalue: num,\r\n\t\t\t\tunit\r\n\t\t\t})\r\n\t\t} else if (token.type === TYPE_NUMBER) {\r\n\t\t\tstack.push({\r\n\t\t\t\tnodeType: NODE_TYPE_NUMBER,\r\n\t\t\t\tvalue: token.value\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\twhile (stack.length > 1) {\r\n\t\tstack.push(buildBinaryExpNode(stack))\r\n\t}\r\n\treturn stack[0] as Node\r\n}\r\n\r\nfunction parse(calcStr: string): Node {\r\n\tconst tokens = tokenize(calcStr)\r\n\treturn lex(tokens, calcStr)\r\n}\r\n\r\nfunction calcNode(node: Node, context: CalcContext): number {\r\n\tif (node.nodeType === NODE_TYPE_BINARY_EXPRESSION) {\r\n\t\tconst left = calcNode(node.left, context)\r\n\t\tconst right = calcNode(node.right, context)\r\n\r\n\t\tswitch (node.op.value) {\r\n\t\tcase '+':\r\n\t\t\treturn left + right\r\n\t\tcase '-':\r\n\t\t\treturn left - right\r\n\t\tcase '*':\r\n\t\t\treturn left * right\r\n\t\tcase '/':\r\n\t\t\treturn left / right\r\n\t\tdefault:\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\r\n\t\t\tthrow new Error(`calc error. unknown operator: ${ node.op.value }`)\r\n\t\t}\r\n\t} else if (node.nodeType === NODE_TYPE_UNIT) {\r\n\t\tswitch (node.unit) {\r\n\t\tcase '%':\r\n\t\t\treturn (node.value * context.full) / 100\r\n\t\tcase 'em':\r\n\t\t\treturn node.value * context.em\r\n\t\tcase 'px':\r\n\t\t\treturn node.value\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`calc error. unknown unit: ${ node.unit }`)\r\n\t\t}\r\n\t} else if (node.nodeType === NODE_TYPE_NUMBER) {\r\n\t\treturn node.value\r\n\t}\r\n\tthrow new Error('calc error.')\r\n}\r\n\r\nfunction toPxInternal(value: string, context: CalcContext): number {\r\n\tconst ast = parse(value)\r\n\treturn calcNode(ast, context)\r\n}\r\n\r\ntype CalcContext = {\r\n    full: number;\r\n    em: number;\r\n};\r\n\r\nexport function toPx(value: string | number, context: CalcContext): number {\r\n\tif (typeof value === 'string') {\r\n\t\treturn toPxInternal(value.trim(), context)\r\n\t}\r\n\treturn value - 0\r\n}\r\n","import type { RectProps } from '../ts-types'\r\n\r\nexport type PaddingOption = {\r\n    left?: number;\r\n    right?: number;\r\n    top?: number;\r\n    bottom?: number;\r\n};\r\n\r\nconst fontSizeCache: {\r\n    [key: string]: {\r\n        width: number;\r\n        height: number;\r\n    };\r\n} = {}\r\n\r\nexport function getFontSize(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tfont: string | null | undefined\r\n): {\r\n    width: number;\r\n    height: number;\r\n} {\r\n\tconst fontName = font || ctx.font\r\n\tif (fontSizeCache[fontName]) {\r\n\t\treturn fontSizeCache[fontName]\r\n\t}\r\n\tconst bk = ctx.font\r\n\ttry {\r\n\t\tctx.font = fontName\r\n\t\tconst em = ctx.measureText('').width\r\n\t\treturn (fontSizeCache[fontName] = {\r\n\t\t\twidth: em,\r\n\t\t\theight: em\r\n\t\t})\r\n\t} finally {\r\n\t\tctx.font = bk\r\n\t}\r\n}\r\n\r\nexport function calcBasePosition(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\trect: RectProps,\r\n\t\t{\r\n\t\t\toffset = 0,\r\n\t\t\tpadding: { left: paddingLeft = 0, right: paddingRight = 0, top: paddingTop = 0, bottom: paddingBottom = 0 } = {}\r\n\t\t}: {\r\n        offset?: number;\r\n        padding?: PaddingOption;\r\n    } = {}\r\n): { x: number; y: number } {\r\n\treturn calcStartPosition(ctx, rect, 0, 0, {\r\n\t\toffset,\r\n\t\tpadding: {\r\n\t\t\tleft: paddingLeft,\r\n\t\t\tright: paddingRight,\r\n\t\t\ttop: paddingTop,\r\n\t\t\tbottom: paddingBottom\r\n\t\t}\r\n\t})\r\n}\r\n\r\nexport function calcStartPosition(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\trect: RectProps,\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\t{\r\n\t\t\toffset = 0,\r\n\t\t\tpadding: { left: paddingLeft = 0, right: paddingRight = 0, top: paddingTop = 0, bottom: paddingBottom = 0 } = {}\r\n\t\t}: {\r\n        offset?: number;\r\n        padding?: PaddingOption;\r\n    } = {}\r\n): { x: number; y: number } {\r\n\tconst textAlign = ctx.textAlign || 'left'\r\n\tconst textBaseline = ctx.textBaseline || 'middle'\r\n\tctx.textAlign = textAlign\r\n\tctx.textBaseline = textBaseline\r\n\r\n\tlet x = rect.left + offset + paddingLeft\r\n\tif (textAlign === 'right' || textAlign === 'end') {\r\n\t\tx = rect.right - width - offset - paddingRight\r\n\t} else if (textAlign === 'center') {\r\n\t\tx = rect.left + (rect.width - width + paddingLeft - paddingRight) / 2\r\n\t}\r\n\tlet y = rect.top + offset + paddingTop\r\n\tif (textBaseline === 'bottom' || textBaseline === 'alphabetic' || textBaseline === 'ideographic') {\r\n\t\ty = rect.bottom - height - offset - paddingBottom\r\n\t} else if (textBaseline === 'middle') {\r\n\t\ty = rect.top + (rect.height - height + paddingTop - paddingBottom) / 2\r\n\t}\r\n\treturn { x, y }\r\n}\r\n","export type RGBA = { r: number; g: number; b: number; a: number };\r\nconst rgbMap: { [key: string]: RGBA } = {}\r\n\r\nfunction styleColorToRGB(color: string): RGBA | null {\r\n\tconst dummy = document.createElement('div')\r\n\tconst { style } = dummy\r\n\tstyle.color = color\r\n\tstyle.position = 'fixed'\r\n\tstyle.height = '1px'\r\n\tstyle.width = '1px'\r\n\tstyle.opacity = '0'\r\n\tdocument.body.appendChild(dummy)\r\n\tconst { color: styleColor } = (document.defaultView || window).getComputedStyle(dummy, '')\r\n\tdocument.body.removeChild(dummy)\r\n\treturn colorToRGB0(styleColor || '')\r\n}\r\n\r\nfunction hexToNum(hex: string): number {\r\n\treturn parseInt(hex, 16)\r\n}\r\n\r\nfunction createRGB(r: number, g: number, b: number, a = 1): RGBA {\r\n\treturn { r, g, b, a }\r\n}\r\n\r\nfunction tripleHexToRGB({ 1: r, 2: g, 3: b }: string): RGBA {\r\n\treturn createRGB(hexToNum(r + r), hexToNum(g + g), hexToNum(b + b))\r\n}\r\n\r\nfunction sextupleHexToRGB({ 1: r1, 2: r2, 3: g1, 4: g2, 5: b1, 6: b2 }: string): RGBA {\r\n\treturn createRGB(hexToNum(r1 + r2), hexToNum(g1 + g2), hexToNum(b1 + b2))\r\n}\r\n\r\nfunction testRGB({ r, g, b, a }: RGBA): boolean {\r\n\treturn 0 <= r && r <= 255 && 0 <= g && g <= 255 && 0 <= b && b <= 255 && 0 <= a && a <= 1\r\n}\r\n\r\nfunction rateToByte(r: number): number {\r\n\treturn Math.ceil((r * 255) / 100)\r\n}\r\n\r\nfunction colorToRGB0(color: string): RGBA | null {\r\n\tif (/^#[0-9a-f]{3}$/i.exec(color)) {\r\n\t\treturn tripleHexToRGB(color)\r\n\t}\r\n\tif (/^#[0-9a-f]{6}$/i.exec(color)) {\r\n\t\treturn sextupleHexToRGB(color)\r\n\t}\r\n\tlet ret = /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/i.exec(color)\r\n\tif (ret) {\r\n\t\tconst rgb = createRGB(Number(ret[1]), Number(ret[2]), Number(ret[3]))\r\n\t\tif (testRGB(rgb)) {\r\n\t\t\treturn rgb\r\n\t\t}\r\n\t}\r\n\tret = /^rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d(\\.\\d)?)\\s*\\)$/i.exec(color)\r\n\tif (ret) {\r\n\t\tconst rgb = createRGB(Number(ret[1]), Number(ret[2]), Number(ret[3]), Number(ret[4]))\r\n\t\tif (testRGB(rgb)) {\r\n\t\t\treturn rgb\r\n\t\t}\r\n\t}\r\n\tret = /^rgb\\(\\s*(\\d{1,3}(\\.\\d)?)%\\s*,\\s*(\\d{1,3}(\\.\\d)?)%\\s*,\\s*(\\d{1,3}(\\.\\d)?)%\\s*\\)$/i.exec(color)\r\n\tif (ret) {\r\n\t\tconst rgb = createRGB(rateToByte(Number(ret[1])), rateToByte(Number(ret[3])), rateToByte(Number(ret[5])))\r\n\t\tif (testRGB(rgb)) {\r\n\t\t\treturn rgb\r\n\t\t}\r\n\t}\r\n\tret = /^rgba\\(\\s*(\\d{1,3}(\\.\\d)?)%\\s*,\\s*(\\d{1,3}(\\.\\d)?)%\\s*,\\s*(\\d{1,3}(\\.\\d)?)%\\s*,\\s*(\\d(\\.\\d)?)\\s*\\)$/i.exec(color)\r\n\tif (ret) {\r\n\t\tconst rgb = createRGB(rateToByte(Number(ret[1])), rateToByte(Number(ret[3])), rateToByte(Number(ret[5])), Number(ret[7]))\r\n\t\tif (testRGB(rgb)) {\r\n\t\t\treturn rgb\r\n\t\t}\r\n\t}\r\n\treturn null\r\n}\r\n\r\nexport function colorToRGB(color: string): RGBA {\r\n\tif (typeof color !== 'string') {\r\n\t\treturn createRGB(0, 0, 0, 0)\r\n\t}\r\n\tcolor = color.toLowerCase().trim()\r\n\tif (rgbMap[color]) {\r\n\t\treturn rgbMap[color]\r\n\t}\r\n\treturn colorToRGB0(color) || (rgbMap[color] = styleColorToRGB(color) as RGBA)\r\n}\r\n","export function createElement<K extends keyof HTMLElementTagNameMap>(\r\n\t\ttagName: K,\r\n\t\t{ classList, text, html }: { classList?: string[] | string; text?: string; html?: string } = {}\r\n): HTMLElementTagNameMap[K] {\r\n\tconst element = document.createElement(tagName)\r\n\tif (classList) {\r\n\t\tif (Array.isArray(classList)) {\r\n\t\t\telement.classList.add(...classList)\r\n\t\t} else {\r\n\t\t\telement.classList.add(classList)\r\n\t\t}\r\n\t}\r\n\tif (text) {\r\n\t\telement.textContent = text\r\n\t} else if (html) {\r\n\t\telement.innerHTML = html\r\n\t}\r\n\treturn element\r\n}\r\n\r\nexport function empty(dom: HTMLElement): void {\r\n\tlet c\r\n\twhile ((c = dom.firstChild)) {\r\n\t\tdom.removeChild(c)\r\n\t}\r\n}\r\n\r\nfunction isNode(arg: HTMLElement | string): arg is HTMLElement {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\treturn !!((arg as any).nodeType && (arg as any).nodeName)\r\n}\r\n\r\nfunction toNode(arg: HTMLElement | string): HTMLElement | HTMLElement[] {\r\n\tif (isNode(arg)) {\r\n\t\treturn arg\r\n\t}\r\n\tconst dom = createElement('div', { html: arg })\r\n\treturn Array.prototype.slice.call(dom.childNodes) as HTMLElement[]\r\n}\r\n\r\nexport function toNodeList(arg: HTMLElement | HTMLElement[] | string): HTMLElement[] {\r\n\tif (Array.isArray(arg)) {\r\n\t\tconst result: HTMLElement[] = []\r\n\t\targ.forEach((e) => {\r\n\t\t\tresult.push(...toNodeList(e))\r\n\t\t})\r\n\t\treturn result\r\n\t}\r\n\tconst node = toNode(arg)\r\n\treturn Array.isArray(node) ? node : [ node ]\r\n}\r\n\r\nexport function appendHtml(dom: HTMLElement, inner: HTMLElement | HTMLElement[] | string): void {\r\n\ttoNodeList(inner).forEach((node) => {\r\n\t\tdom.appendChild(node)\r\n\t})\r\n}\r\n\r\nexport function disableFocus(el: HTMLElement): void {\r\n\tel.dataset.disableBeforeTabIndex = `${ el.tabIndex }`\r\n\tel.tabIndex = -1\r\n\tArray.prototype.slice.call(el.children, 0).forEach(disableFocus)\r\n}\r\n\r\nexport function enableFocus(el: HTMLElement): void {\r\n\tif ('disableBeforeTabIndex' in el.dataset) {\r\n\t\tel.tabIndex = Number(el.dataset.disableBeforeTabIndex)\r\n\t}\r\n\tArray.prototype.slice.call(el.children, 0).forEach(enableFocus)\r\n}\r\n\r\nexport function isFocusable(el: Node): el is HTMLElement {\r\n\treturn (el as HTMLElement).tabIndex != null && (el as HTMLElement).tabIndex > -1\r\n}\r\n\r\nexport function findPrevSiblingFocusable(el: HTMLElement): ChildNode | HTMLElement | null {\r\n\tlet n = el.previousSibling\r\n\twhile (n && !isFocusable(n)) {\r\n\t\tn = n.previousSibling\r\n\t}\r\n\t// return n\r\n\treturn n\r\n}\r\n\r\nexport function findNextSiblingFocusable(el: HTMLElement): ChildNode | HTMLElement | null {\r\n\tlet n = el.nextSibling\r\n\twhile (n && !isFocusable(n)) {\r\n\t\tn = n.nextSibling\r\n\t}\r\n\treturn n\r\n}\r\n","import type { AnyFunction } from '../ts-types'\r\nimport { isNode } from './utils'\r\nimport FontWatchRunner from './legacy/fontwatch/FontWatchRunner'\r\n\r\nconst loads: { [key: string]: boolean } = {}\r\nlet load: (font: string, testStr: string, callback: AnyFunction) => void\r\nlet check: (font: string, testStr: string) => boolean\r\nif (isNode) {\r\n\tload = function(_font: string, _testStr: string, callback: AnyFunction): void {\r\n\t\tcallback()\r\n\t}\r\n\tcheck = function(): boolean {\r\n\t\treturn false\r\n\t}\r\n} else {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tconst fontFaceSet = (document as any).fonts\r\n\tconst legacy = !fontFaceSet\r\n\tload = legacy\r\n\t\t? function(font: string, testStr: string, callback: AnyFunction): void {\r\n\t\t\t//for legacy(IE)\r\n\t\t\tif (loads[`${ font } @ ${ testStr }`]) {\r\n\t\t\t\tcallback()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-var-requires\r\n\t\t\t// require('./legacy/fontwatch/FontWatchRunner').load(\r\n\t\t\tFontWatchRunner.load(\r\n\t\t\t\t\tfont,\r\n\t\t\t\t\ttestStr,\r\n\t\t\t\t\t() => {\r\n\t\t\t\t\t\tloads[`${ font } @ ${ testStr }`] = true\r\n\t\t\t\t\t\tcallback()\r\n\t\t\t\t\t},\r\n\t\t\t\t\t() => {\r\n\t\t\t\t\t\tloads[`${ font } @ ${ testStr }`] = true\r\n\t\t\t\t\t\tcallback()\r\n\t\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t\t: function(font: string, _testStr: string, callback: AnyFunction): void {\r\n\t\t\tif (loads.all || loads[font]) {\r\n\t\t\t\tcallback()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfontFaceSet.ready.then(() => {\r\n\t\t\t\tloads.all = true\r\n\t\t\t})\r\n\t\t\tfontFaceSet.load(font).then(() => {\r\n\t\t\t\tloads[font] = true\r\n\t\t\t\tcallback()\r\n\t\t\t})\r\n\t\t}\r\n\tcheck = legacy\r\n\t\t? function(font: string, testStr: string): boolean {\r\n\t\t\t//for legacy(IE)\r\n\t\t\tif (loads[`${ font } @ ${ testStr }`]) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tload(font, testStr, () => {\r\n\t\t\t})\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t: function(font: string, testStr: string): boolean {\r\n\t\t\tif (loads.all || loads[font]) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tif (!fontFaceSet.check(font)) {\r\n\t\t\t\tload(font, testStr, () => {\r\n\t\t\t\t})\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n}\r\n\r\nexport { check, load }\r\n","import type { AnyFunction } from '../ts-types'\r\nimport { EventHandler } from './EventHandler'\r\nimport { isNode } from './utils'\r\n\r\nconst handler = new EventHandler()\r\n\r\nlet ratio = 1\r\n\r\nfunction setRatio(): void {\r\n\tif (isNode) {\r\n\t\tratio = 1\r\n\t} else {\r\n\t\tratio = Math.ceil(window.devicePixelRatio || 1)\r\n\t\tif (ratio > 1 && ratio % 2 !== 0) {\r\n\t\t\tratio += 1\r\n\t\t}\r\n\t}\r\n}\r\n\r\nsetRatio()\r\nif (!isNode) {\r\n\thandler.on(window, 'resize', setRatio)\r\n}\r\n\r\nexport function transform(canvas: HTMLCanvasElement): HTMLCanvasElement {\r\n\tconst ctx = canvas.getContext('2d') as CanvasRenderingContext2D\r\n\r\n\tconst { getAttribute, setAttribute } = canvas\r\n\tcanvas.getAttribute = function(name: string): string | null {\r\n\t\tlet result = getAttribute.call(this, name)\r\n\t\tif (name === 'width' || name === 'height') {\r\n\t\t\tresult = `${ Number(result) / ratio }`\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n\tcanvas.setAttribute = function(name, val: string): void {\r\n\t\tconst wh = name === 'width' || name === 'height'\r\n\t\tif (wh) {\r\n\t\t\tval = `${ Number(val) * ratio }`\r\n\t\t}\r\n\t\tconst result = setAttribute.call(this, name, val)\r\n\t\tif (wh) {\r\n\t\t\tctx.scale(ratio, ratio)\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n\r\n\tObject.defineProperty(canvas, 'width', {\r\n\t\tget(): number {\r\n\t\t\treturn Number(canvas.getAttribute('width'))\r\n\t\t},\r\n\t\tset: (val: number) => {\r\n\t\t\tcanvas.setAttribute('width', `${ Math.floor(val) }`)\r\n\t\t},\r\n\t\tconfigurable: true,\r\n\t\tenumerable: true\r\n\t})\r\n\tObject.defineProperty(canvas, 'height', {\r\n\t\tget(): number {\r\n\t\t\treturn Number(canvas.getAttribute('height'))\r\n\t\t},\r\n\t\tset: (val: number) => {\r\n\t\t\tcanvas.setAttribute('height', `${ Math.floor(val) }`)\r\n\t\t},\r\n\t\tconfigurable: true,\r\n\t\tenumerable: true\r\n\t})\r\n\tconst { drawImage } = ctx\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tctx.drawImage = function(img: CanvasImageSource, ...args: any[]): void {\r\n\t\tif (img !== canvas || ratio === 1) {\r\n\t\t\treturn (drawImage as AnyFunction).call(this, img, ...args)\r\n\t\t}\r\n\t\tthis.save()\r\n\t\ttry {\r\n\t\t\tthis.scale(1 / ratio, 1 / ratio)\r\n\t\t\tif (args.length > 4) {\r\n\t\t\t\targs[4] *= ratio\r\n\t\t\t\targs[5] *= ratio\r\n\t\t\t} else {\r\n\t\t\t\targs[0] *= ratio\r\n\t\t\t\targs[1] *= ratio\r\n\t\t\t}\r\n\t\t\treturn (drawImage as AnyFunction).call(this, img, ...args)\r\n\t\t} finally {\r\n\t\t\tthis.restore()\r\n\t\t}\r\n\t}\r\n\r\n\treturn canvas\r\n}\r\n","import type { ColumnIconOption, FontIcon, ImageIcon, NamedIcon, PathIcon, SvgIcon } from '../ts-types'\r\nimport type { SimpleColumnIconOption } from '../ts-types-internal'\r\n\r\ntype ColumnIconArrayOption = {\r\n    content?: (string | null)[];\r\n    font?: (string | null)[];\r\n    color?: (string | null)[];\r\n    className?: (string | null)[];\r\n    tagName?: (string | null)[];\r\n    isLiga?: (boolean | null)[];\r\n    width?: (number | null)[];\r\n    src?: (string | null)[];\r\n    svg?: (string | null)[];\r\n    name?: (string | null)[];\r\n    path?: (string | null)[];\r\n};\r\n\r\ntype IconPropKey = (keyof FontIcon<unknown> | keyof ImageIcon<unknown> | keyof PathIcon<unknown> | keyof SvgIcon<unknown> | keyof NamedIcon<unknown>) & keyof SimpleColumnIconOption;\r\nconst ICON_PROP_KEYS: IconPropKey[] = [ 'content', 'font', 'color', 'className', 'tagName', 'isLiga', 'width', 'src', 'svg', 'name', 'path' ]\r\n\r\nfunction quote(name: string): string {\r\n\tconst quoted = []\r\n\tconst split = name.split(/,\\s*/)\r\n\tfor (let i = 0; i < split.length; i++) {\r\n\t\tconst part = split[i].replace(/['\"]/g, '')\r\n\t\tif (part.indexOf(' ') === -1 && !/^\\d/.test(part)) {\r\n\t\t\tquoted.push(part)\r\n\t\t} else {\r\n\t\t\tquoted.push(`'${ part }'`)\r\n\t\t}\r\n\t}\r\n\treturn quoted.join(',')\r\n}\r\n\r\nconst doms: {\r\n    [tagName: string]: HTMLElement;\r\n} = {}\r\nconst props: {\r\n    [tagName: string]: {\r\n        [className: string]: { [key: string]: string | number | boolean };\r\n    };\r\n} = {}\r\n\r\nexport function getIconProps(tagName: string, className: string): SimpleColumnIconOption {\r\n\tconst tagProps = props[tagName] || (props[tagName] = {})\r\n\tif (tagProps[className]) {\r\n\t\treturn tagProps[className]\r\n\t}\r\n\tconst dom = doms[tagName] || (doms[tagName] = document.createElement(tagName))\r\n\tdom.className = className\r\n\tdocument.body.appendChild(dom)\r\n\ttry {\r\n\t\tconst beforeStyle = (document.defaultView || window).getComputedStyle(dom, '::before')\r\n\t\tlet content = beforeStyle.getPropertyValue('content')\r\n\t\tif (content.length >= 3 && (content[0] === '\"' || content[0] === '\\'')) {\r\n\t\t\tif (content[0] === content[content.length - 1]) {\r\n\t\t\t\tcontent = content.substr(1, content.length - 2)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet font = beforeStyle.getPropertyValue('font')\r\n\t\tif (!font) {\r\n\t\t\tfont = `${ beforeStyle.getPropertyValue('font-style') } ${ beforeStyle.getPropertyValue('font-variant') } ${ beforeStyle.getPropertyValue('font-weight') } ${ beforeStyle.getPropertyValue(\r\n\t\t\t\t\t'font-size'\r\n\t\t\t) }/${ beforeStyle.getPropertyValue('line-height') } ${ quote(beforeStyle.getPropertyValue('font-family')) }`\r\n\t\t}\r\n\t\tconst color = beforeStyle.getPropertyValue('color')\r\n\t\tconst width = dom.clientWidth\r\n\t\tconst isLiga = (beforeStyle.getPropertyValue('font-feature-settings') || '').indexOf('liga') > -1\r\n\r\n\t\treturn (tagProps[className] = {\r\n\t\t\tcontent,\r\n\t\t\tfont,\r\n\t\t\tcolor,\r\n\t\t\twidth,\r\n\t\t\tisLiga\r\n\t\t})\r\n\t} finally {\r\n\t\tdocument.body.removeChild(dom)\r\n\t}\r\n}\r\n\r\nfunction toPropArray<T>(prop: T, count: number): (T | null)[] {\r\n\tconst result: (T | null)[] = []\r\n\tif (Array.isArray(prop)) {\r\n\t\tresult.push(...prop)\r\n\t\tfor (let i = prop.length; i < count; i++) {\r\n\t\t\tresult.push(null)\r\n\t\t}\r\n\t} else {\r\n\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\tresult.push(prop)\r\n\t\t}\r\n\t}\r\n\treturn result\r\n}\r\n\r\nfunction toSimpleArray(iconProps: ColumnIconOption<unknown> | ColumnIconOption<unknown>[]): SimpleColumnIconOption[] | ColumnIconOption<unknown> | ColumnIconOption<unknown>[] {\r\n\tif (!iconProps) {\r\n\t\treturn iconProps\r\n\t} else if (Array.isArray(iconProps)) {\r\n\t\treturn iconProps\r\n\t}\r\n\r\n\tconst workData = {} as Required<ColumnIconArrayOption>\r\n\r\n\tlet count = 0\r\n\tICON_PROP_KEYS.forEach((k) => {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tconst prop = (iconProps as any)[k]\r\n\t\tif (prop) {\r\n\t\t\tif (Array.isArray(prop)) {\r\n\t\t\t\tcount = Math.max(count, prop.length)\r\n\t\t\t} else {\r\n\t\t\t\tcount = Math.max(count, 1)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tICON_PROP_KEYS.forEach((k) => {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tconst arr = toPropArray((iconProps as any)[k], count);\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t(workData as any)[k] = arr\r\n\t})\r\n\r\n\tconst result: SimpleColumnIconOption[] = []\r\n\tfor (let i = 0; i < count; i++) {\r\n\t\tconst data = {} as SimpleColumnIconOption\r\n\t\tICON_PROP_KEYS.forEach((k) => {\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\tconst val = (workData as any)[k][i];\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\t(data as any)[k] = val\r\n\t\t})\r\n\t\tresult.push(data)\r\n\t}\r\n\treturn result\r\n}\r\n\r\nfunction normarize(iconProps: SimpleColumnIconOption): SimpleColumnIconOption {\r\n\tconst data: SimpleColumnIconOption = {}\r\n\tfor (const k in iconProps) {\r\n\t\tif (k === 'className') {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif (isIconKey(k)) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tdata[k] = iconProps[k] as any\r\n\t\t}\r\n\t}\r\n\tif (iconProps.className) {\r\n\t\tconst prop = getIconProps(iconProps.tagName || 'i', iconProps.className)\r\n\t\tfor (const k in prop) {\r\n\t\t\tif (isIconKey(k)) {\r\n\t\t\t\tif (iconProps[k] == null) {\r\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\tdata[k] = prop[k] as any\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn data\r\n}\r\n\r\nexport function toNormarizeArray(iconProps: ColumnIconOption<unknown> | ColumnIconOption<unknown>[]): SimpleColumnIconOption[] {\r\n\tconst icons = toSimpleArray(iconProps)\r\n\tif (!icons) {\r\n\t\t// @ts-ignore\r\n\t\treturn icons\r\n\t}\r\n\t// @ts-ignore\r\n\treturn icons.map((icon) => normarize(icon))\r\n}\r\n\r\nexport const iconPropKeys = ICON_PROP_KEYS\r\n\r\nfunction isIconKey(k: string): k is IconPropKey {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\treturn ICON_PROP_KEYS.indexOf(k as any) >= 0\r\n}\r\n","import { LRUCache } from './LRUCache'\r\nimport type { MaybePromise } from '../ts-types'\r\nimport { then } from './utils'\r\n\r\nconst allCache: {\r\n    [key: string]: LRUCache<MaybePromise<HTMLImageElement>>;\r\n} = {}\r\n\r\nexport function loadImage(src: string): Promise<HTMLImageElement> {\r\n\tif (typeof Promise === 'undefined') {\r\n\t\tconsole.error('Promise is not loaded. load Promise before this process.')\r\n\t\treturn {\r\n\t\t\tthen(): Promise<HTMLImageElement> {\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t} as any\r\n\t}\r\n\tconst img = new Image()\r\n\tconst result = new Promise<HTMLImageElement>((resolve) => {\r\n\t\timg.onload = (): void => {\r\n\t\t\tresolve(img)\r\n\t\t}\r\n\t})\r\n\timg.onerror = (): void => {\r\n\t\tconst url = src.length > 200 ? `${ src.substr(0, 200) }...` : src\r\n\t\tconsole.warn(`cannot load: ${ url }`)\r\n\t\tthrow new Error(`IMAGE LOAD ERROR: ${ url }`)\r\n\t}\r\n\timg.src = src\r\n\treturn result\r\n}\r\n\r\nfunction getCacheOrLoad0(cache: LRUCache<MaybePromise<HTMLImageElement>>, src: MaybePromise<string>): MaybePromise<HTMLImageElement> {\r\n\treturn then(src, (src) => {\r\n\t\tconst c = cache.get(src)\r\n\t\tif (c) {\r\n\t\t\treturn c\r\n\t\t}\r\n\t\tconst result = loadImage(src).then((img) => {\r\n\t\t\tcache.put(src, img)\r\n\t\t\treturn img\r\n\t\t})\r\n\t\tcache.put(src, result)\r\n\t\treturn result\r\n\t})\r\n}\r\n\r\nexport function getCacheOrLoad(cacheName: string, cacheSize: number, src: MaybePromise<string>): MaybePromise<HTMLImageElement> {\r\n\tconst cache = allCache[cacheName] || (allCache[cacheName] = new LRUCache<MaybePromise<HTMLImageElement>>(cacheSize))\r\n\treturn getCacheOrLoad0(cache, src)\r\n}\r\n","import type { AnyFunction } from '../../../ts-types'\r\nimport type { CanvasOperations } from './internal'\r\nimport { PathCommandsParser } from './PathCommandsParser'\r\n\r\nconst parser = new PathCommandsParser()\r\ntype CanvasOperation = keyof CanvasOperations;\r\n\r\nexport class Path2DShim implements CanvasPath {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    _ops: { op: CanvasOperation; args: any[] }[]\r\n\r\n    arc(...args: Parameters<typeof Path2D.prototype.arc>): void {\r\n    \tthis._ops.push({ op: 'arc', args })\r\n    }\r\n\r\n    arcTo(...args: Parameters<typeof Path2D.prototype.arcTo>): void {\r\n    \tthis._ops.push({ op: 'arcTo', args })\r\n    }\r\n\r\n    bezierCurveTo(...args: Parameters<typeof Path2D.prototype.bezierCurveTo>): void {\r\n    \tthis._ops.push({ op: 'bezierCurveTo', args })\r\n    }\r\n\r\n    closePath(...args: Parameters<typeof Path2D.prototype.closePath>): void {\r\n    \tthis._ops.push({ op: 'closePath', args })\r\n    }\r\n\r\n    ellipse(...args: Parameters<typeof Path2D.prototype.ellipse>): void {\r\n    \tthis._ops.push({ op: 'ellipse', args })\r\n    }\r\n\r\n    lineTo(...args: Parameters<typeof Path2D.prototype.lineTo>): void {\r\n    \tthis._ops.push({ op: 'lineTo', args })\r\n    }\r\n\r\n    moveTo(...args: Parameters<typeof Path2D.prototype.moveTo>): void {\r\n    \tthis._ops.push({ op: 'moveTo', args })\r\n    }\r\n\r\n    quadraticCurveTo(...args: Parameters<typeof Path2D.prototype.quadraticCurveTo>): void {\r\n    \tthis._ops.push({ op: 'quadraticCurveTo', args })\r\n    }\r\n\r\n    rect(...args: Parameters<typeof Path2D.prototype.rect>): void {\r\n    \tthis._ops.push({ op: 'rect', args })\r\n    }\r\n\r\n    constructor(arg: string | Path2DShim) {\r\n    \tthis._ops = []\r\n    \tif (arg === undefined) {\r\n    \t\treturn\r\n    \t}\r\n    \tif (typeof arg === 'string') {\r\n    \t\t// try {\r\n    \t\tthis._ops = parser.parse(arg)\r\n    \t\t// } catch (e) {\r\n    \t\t// \tthrow e;\r\n    \t\t// }\r\n    \t} else if (arg.hasOwnProperty('_ops')) {\r\n    \t\tthis._ops = [ ...arg._ops ]\r\n    \t} else {\r\n    \t\tthrow new Error(`Error: ${ typeof arg } is not a valid argument to Path`)\r\n    \t}\r\n    }\r\n}\r\n\r\nconst { CanvasRenderingContext2D } = window\r\n\r\nconst originalFill: AnyFunction = CanvasRenderingContext2D.prototype.fill;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n(CanvasRenderingContext2D.prototype as any).fill = function(...args: Parameters<typeof CanvasRenderingContext2D.prototype.fill>): void {\r\n\tif (args[0] instanceof Path2DShim) {\r\n\t\tconst path = args[0]\r\n\t\tthis.beginPath()\r\n\t\tpath._ops.forEach((op) => {\r\n\t\t\tconst fn: AnyFunction = this[op.op]\r\n\t\t\tfn.apply(this, op.args)\r\n\t\t})\r\n\t\toriginalFill.apply(this, Array.prototype.slice.call(args, 1))\r\n\t} else {\r\n\t\toriginalFill.apply(this, args)\r\n\t}\r\n}\r\n","import type { CanvasOperations } from './internal'\r\n\r\n/*eslint new-cap: \"off\"*/\r\n\r\nfunction mag(v: [ number, number ]): number {\r\n\treturn Math.sqrt(v[0] ** 2 + v[1] ** 2)\r\n}\r\n\r\nfunction dot(u: [ number, number ], v: [ number, number ]): number {\r\n\treturn u[0] * v[0] + u[1] * v[1]\r\n}\r\n\r\nfunction ratio(u: [ number, number ], v: [ number, number ]): number {\r\n\treturn dot(u, v) / (mag(u) * mag(v))\r\n}\r\n\r\nfunction clamp(value: number, min: number, max: number): number {\r\n\treturn Math.min(Math.max(value, min), max)\r\n}\r\n\r\nfunction angle(u: [ number, number ], v: [ number, number ]): number {\r\n\tlet sign = 1.0\r\n\tif (u[0] * v[1] - u[1] * v[0] < 0) {\r\n\t\tsign = -1.0\r\n\t}\r\n\treturn sign * Math.acos(clamp(ratio(u, v), -1, 1))\r\n}\r\n\r\nfunction rotClockwise(v: [ number, number ], angle: number): [ number, number ] {\r\n\tconst cost = Math.cos(angle)\r\n\tconst sint = Math.sin(angle)\r\n\treturn [ cost * v[0] + sint * v[1], -1 * sint * v[0] + cost * v[1] ]\r\n}\r\n\r\nfunction rotCounterClockwise(v: [ number, number ], angle: number): [ number, number ] {\r\n\tconst cost = Math.cos(angle)\r\n\tconst sint = Math.sin(angle)\r\n\treturn [ cost * v[0] - sint * v[1], sint * v[0] + cost * v[1] ]\r\n}\r\n\r\nfunction midPoint(u: [ number, number ], v: [ number, number ]): [ number, number ] {\r\n\treturn [ (u[0] - v[0]) / 2.0, (u[1] - v[1]) / 2.0 ]\r\n}\r\n\r\nfunction meanVec(u: [ number, number ], v: [ number, number ]): [ number, number ] {\r\n\treturn [ (u[0] + v[0]) / 2.0, (u[1] + v[1]) / 2.0 ]\r\n}\r\n\r\nfunction pointMul(u: [ number, number ], v: [ number, number ]): [ number, number ] {\r\n\treturn [ u[0] * v[0], u[1] * v[1] ]\r\n}\r\n\r\nfunction scale(c: number, v: [ number, number ]): [ number, number ] {\r\n\treturn [ c * v[0], c * v[1] ]\r\n}\r\n\r\nfunction sum(u: [ number, number ], v: [ number, number ]): [ number, number ] {\r\n\treturn [ u[0] + v[0], u[1] + v[1] ]\r\n}\r\n\r\n// Convert an SVG elliptical arc to a series of canvas commands.\r\n//\r\n// x1, y1, x2, y2: start and stop coordinates of the ellipse.\r\n// rx, ry: radii of the ellipse.\r\n// phi: rotation of the ellipse.\r\n// fA: large arc flag.\r\n// fS: sweep flag.\r\nfunction ellipseFromEllipticalArc(ctx: CanvasOperations, x1: number, y1: number, rx: number, ry: number, phi: number, fA: number, fS: number, x2: number, y2: number): void {\r\n\t// Convert from endpoint to center parametrization, as detailed in:\r\n\t//   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n\tif (rx === 0 || ry === 0) {\r\n\t\tctx.lineTo(x2, x1)\r\n\t\treturn\r\n\t}\r\n\tphi *= Math.PI / 180.0\r\n\trx = Math.abs(rx)\r\n\try = Math.abs(ry)\r\n\tconst xPrime = rotClockwise(midPoint([ x1, y1 ], [ x2, y2 ]), phi) // F.6.5.1\r\n\tconst xPrime2 = pointMul(xPrime, xPrime)\r\n\tlet rx2 = rx ** 2\r\n\tlet ry2 = ry ** 2\r\n\r\n\tconst lambda = Math.sqrt(xPrime2[0] / rx2 + xPrime2[1] / ry2)\r\n\tif (lambda > 1) {\r\n\t\trx *= lambda\r\n\t\try *= lambda\r\n\t\trx2 = rx ** 2\r\n\t\try2 = ry ** 2\r\n\t}\r\n\tlet factor = Math.sqrt(Math.abs(rx2 * ry2 - rx2 * xPrime2[1] - ry2 * xPrime2[0]) / (rx2 * xPrime2[1] + ry2 * xPrime2[0]))\r\n\tif (fA === fS) {\r\n\t\tfactor *= -1.0\r\n\t}\r\n\tconst cPrime = scale(factor, [ (rx * xPrime[1]) / ry, (-ry * xPrime[0]) / rx ]) // F.6.5.2\r\n\tconst c = sum(rotCounterClockwise(cPrime, phi), meanVec([ x1, y1 ], [ x2, y2 ])) // F.6.5.3\r\n\tconst x1UnitVector: [ number, number ] = [ (xPrime[0] - cPrime[0]) / rx, (xPrime[1] - cPrime[1]) / ry ]\r\n\tconst x2UnitVector: [ number, number ] = [ (-1.0 * xPrime[0] - cPrime[0]) / rx, (-1.0 * xPrime[1] - cPrime[1]) / ry ]\r\n\tconst theta = angle([ 1, 0 ], x1UnitVector) // F.6.5.5\r\n\tconst deltaTheta = angle(x1UnitVector, x2UnitVector) // F.6.5.6\r\n\tconst start = theta\r\n\tconst end = theta + deltaTheta\r\n\tctx.save()\r\n\tctx.translate(c[0], c[1])\r\n\tctx.rotate(phi)\r\n\tctx.scale(rx, ry)\r\n\tctx.arc(0, 0, 1, start, end, !fS)\r\n\tctx.restore()\r\n}\r\n\r\nexport class PathCommands {\r\n    public readonly M: (px: number, py: number) => this\r\n\r\n    public readonly m: (px: number, py: number) => this\r\n\r\n    public readonly L: (px: number, py: number) => this\r\n\r\n    public readonly l: (px: number, py: number) => this\r\n\r\n    public readonly H: (px: number) => this\r\n\r\n    public readonly h: (px: number) => this\r\n\r\n    public readonly V: (py: number) => this\r\n\r\n    public readonly v: (py: number) => this\r\n\r\n    public readonly Z: () => this\r\n\r\n    public readonly z: () => this\r\n\r\n    public readonly C: (cp1x: number, cp1y: number, cp2x: number, cp2y: number, px: number, py: number) => this\r\n\r\n    public readonly c: (cp1x: number, cp1y: number, cp2x: number, cp2y: number, px: number, py: number) => this\r\n\r\n    public readonly S: (cpx: number, cpy: number, px: number, py: number) => this\r\n\r\n    public readonly s: (cpx: number, cpy: number, px: number, py: number) => this\r\n\r\n    public readonly Q: (cpx: number, cpy: number, px: number, py: number) => this\r\n\r\n    public readonly q: (cpx: number, cpy: number, px: number, py: number) => this\r\n\r\n    public readonly T: (px: number, py: number) => this\r\n\r\n    public readonly t: (px: number, py: number) => this\r\n\r\n    public readonly A: (rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, px: number, py: number) => this\r\n\r\n    public readonly a: (rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, px: number, py: number) => this\r\n\r\n    constructor(ctx: CanvasOperations) {\r\n    \tlet lMx: number\r\n    \tlet lMy: number\r\n    \tlet lx = 0\r\n    \tlet ly = 0\r\n    \tlet reflected: {\r\n            x: number;\r\n            y: number;\r\n        }\r\n    \tlet lastCommand = ''\r\n\r\n    \tfunction makeReflected(): {\r\n            x: number;\r\n            y: number;\r\n            } {\r\n    \t\tif ('CcSsQqTt'.indexOf(lastCommand) < 0) {\r\n    \t\t\treturn { x: lx, y: ly }\r\n    \t\t}\r\n    \t\treturn reflected\r\n    \t}\r\n\r\n    \tthis.M = (px, py): this => {\r\n    \t\tctx.moveTo(px, py)\r\n    \t\tlMx = px\r\n    \t\tlMy = py\r\n    \t\tlx = px\r\n    \t\tly = py\r\n    \t\tlastCommand = 'M'\r\n    \t\treturn this\r\n    \t}\r\n    \tthis.m = (px, py): this => this.M(px + lx, py + ly)\r\n    \tthis.L = (px, py): this => {\r\n    \t\tctx.lineTo(px, py)\r\n    \t\tlx = px\r\n    \t\tly = py\r\n    \t\tlastCommand = 'L'\r\n    \t\treturn this\r\n    \t}\r\n    \tthis.l = (px, py): this => this.L(px + lx, py + ly)\r\n    \tthis.H = (px): this => this.L(px, ly)\r\n    \tthis.h = (px): this => this.H(px + lx)\r\n    \tthis.V = (py): this => this.L(lx, py)\r\n    \tthis.v = (py): this => this.V(py + ly)\r\n    \tthis.Z = (): this => {\r\n    \t\tctx.closePath()\r\n    \t\tlx = lMx\r\n    \t\tly = lMy\r\n    \t\tlastCommand = 'Z'\r\n    \t\treturn this\r\n    \t}\r\n    \tthis.z = (): this => this.Z()\r\n    \t//C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)\r\n    \tthis.C = (cp1x, cp1y, cp2x, cp2y, px, py): this => {\r\n    \t\tctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, px, py)\r\n    \t\tlx = px\r\n    \t\tly = py\r\n    \t\treflected = {\r\n    \t\t\tx: 2 * px - cp2x,\r\n    \t\t\ty: 2 * py - cp2y\r\n    \t\t}\r\n    \t\tlastCommand = 'C'\r\n    \t\treturn this\r\n    \t}\r\n    \tthis.c = (cp1x, cp1y, cp2x, cp2y, px, py): this => this.C(cp1x + lx, cp1y + ly, cp2x + lx, cp2y + ly, px + lx, py + ly)\r\n    \t//S x2 y2, x y (or s dx2 dy2, dx dy)\r\n    \tthis.S = (cpx, cpy, px, py): this => {\r\n    \t\tconst { x: cp1x, y: cp1y } = makeReflected(/*lastCommand*/)\r\n    \t\treturn this.C(cp1x, cp1y, cpx, cpy, px, py)\r\n    \t}\r\n    \tthis.s = (cpx, cpy, px, py): this => this.S(cpx + lx, cpy + ly, px + lx, py + ly)\r\n    \t//Q x1 y1, x y (or q dx1 dy1, dx dy)\r\n    \tthis.Q = (cpx, cpy, px, py): this => {\r\n    \t\tctx.quadraticCurveTo(cpx, cpy, px, py)\r\n    \t\tlx = px\r\n    \t\tly = py\r\n    \t\treflected = {\r\n    \t\t\tx: 2 * px - cpx,\r\n    \t\t\ty: 2 * py - cpy\r\n    \t\t}\r\n    \t\tlastCommand = 'Q'\r\n    \t\treturn this\r\n    \t}\r\n    \tthis.q = (cpx, cpy, px, py): this => this.Q(cpx + lx, cpy + ly, px + lx, py + ly)\r\n    \t//T x y (or t dx dy)\r\n    \tthis.T = (px, py): this => {\r\n    \t\tconst { x: cpx, y: cpy } = makeReflected()\r\n    \t\treturn this.Q(cpx, cpy, px, py)\r\n    \t}\r\n    \tthis.t = (px, py): this => this.T(px + lx, py + ly)\r\n    \t//A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n    \tthis.A = (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py): this => {\r\n    \t\tconst x1 = lx\r\n    \t\tconst y1 = ly\r\n\r\n    \t\tellipseFromEllipticalArc(ctx, x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py)\r\n\r\n    \t\tlx = px\r\n    \t\tly = py\r\n    \t\tlastCommand = 'A'\r\n    \t\treturn this\r\n    \t}\r\n    \t//a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\r\n    \tthis.a = (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py): this => this.A(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px + lx, py + ly)\r\n    }\r\n}\r\n","import type { AnyFunction } from '../../../ts-types'\r\nimport type { CanvasOperations } from './internal'\r\nimport { PathCommands } from './PathCommands'\r\n\r\ntype PathCommandName = keyof PathCommands;\r\ntype CanvasOperation = keyof CanvasOperations;\r\n\r\ntype Tokens = { next(): string | null };\r\n\r\nfunction pathTokens(d: string): Tokens {\r\n\tlet idx = 0\r\n\treturn {\r\n\t\tnext(): string | null {\r\n\t\t\tlet s = ''\r\n\t\t\twhile (d.length > idx) {\r\n\t\t\t\tconst c = d[idx]\r\n\t\t\t\tidx++\r\n\t\t\t\tif (' ,\\n\\r\\t'.indexOf(c) > -1) {\r\n\t\t\t\t\tif (s) {\r\n\t\t\t\t\t\treturn s\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst type = '.+-1234567890'.indexOf(c) > -1 ? 'num' : 'str'\r\n\t\t\t\t\tif (type === 'str') {\r\n\t\t\t\t\t\tif (s) {\r\n\t\t\t\t\t\t\tidx--\r\n\t\t\t\t\t\t\treturn s\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn c\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ('-+'.indexOf(c) > -1) {\r\n\t\t\t\t\t\tif (s) {\r\n\t\t\t\t\t\t\tidx--\r\n\t\t\t\t\t\t\treturn s\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (c === '.') {\r\n\t\t\t\t\t\tif (s.indexOf('.') > -1) {\r\n\t\t\t\t\t\t\tidx--\r\n\t\t\t\t\t\t\treturn s\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ts += c\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn s || null\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction command(builder: PathCommandsParser, cmd: PathCommandName, argsProvider: Tokens): PathCommandName | null {\r\n\tif (cmd.toUpperCase() === 'M' || cmd.toUpperCase() === 'L' || cmd.toUpperCase() === 'T') {\r\n\t\tbuilder.command(cmd, argsProvider.next(), argsProvider.next())\r\n\t\treturn cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd\r\n\t} else if (cmd.toUpperCase() === 'H' || cmd.toUpperCase() === 'V') {\r\n\t\tbuilder.command(cmd, argsProvider.next())\r\n\t\treturn cmd\r\n\t} else if (cmd.toUpperCase() === 'Z') {\r\n\t\tbuilder.command(cmd)\r\n\t\treturn cmd\r\n\t} else if (cmd.toUpperCase() === 'C') {\r\n\t\tbuilder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next())\r\n\t\treturn cmd\r\n\t} else if (cmd.toUpperCase() === 'S' || cmd.toUpperCase() === 'Q') {\r\n\t\tbuilder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next())\r\n\t\treturn cmd\r\n\t} else if (cmd.toUpperCase() === 'A') {\r\n\t\tbuilder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next())\r\n\t\treturn cmd\r\n\t} else {\r\n\t\t// https://developer.mozilla.org/ja/docs/Web/SVG/Tutorial/Paths\r\n\t\tconsole.warn(`unsupported:${ cmd }`)\r\n\t}\r\n\treturn null\r\n}\r\n\r\nexport class PathCommandsParser implements CanvasOperations {\r\n    public readonly moveTo: typeof CanvasRenderingContext2D.prototype.moveTo\r\n\r\n    public readonly lineTo: typeof CanvasRenderingContext2D.prototype.lineTo\r\n\r\n    public readonly closePath: typeof CanvasRenderingContext2D.prototype.closePath\r\n\r\n    public readonly bezierCurveTo: typeof CanvasRenderingContext2D.prototype.bezierCurveTo\r\n\r\n    public readonly quadraticCurveTo: typeof CanvasRenderingContext2D.prototype.quadraticCurveTo\r\n\r\n    public readonly save: typeof CanvasRenderingContext2D.prototype.save\r\n\r\n    public readonly translate: typeof CanvasRenderingContext2D.prototype.translate\r\n\r\n    public readonly rotate: typeof CanvasRenderingContext2D.prototype.rotate\r\n\r\n    public readonly scale: typeof CanvasRenderingContext2D.prototype.scale\r\n\r\n    public readonly arc: typeof CanvasRenderingContext2D.prototype.arc\r\n\r\n    public readonly restore: typeof CanvasRenderingContext2D.prototype.restore\r\n\r\n    public readonly arcTo: typeof CanvasRenderingContext2D.prototype.arcTo\r\n\r\n    public readonly ellipse: typeof CanvasRenderingContext2D.prototype.ellipse\r\n\r\n    public readonly rect: typeof CanvasRenderingContext2D.prototype.rect\r\n\r\n    private readonly _commands: PathCommands\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private _ops: { op: CanvasOperation; args: any[] }[] = []\r\n\r\n    constructor() {\r\n    \tthis._commands = new PathCommands(this as CanvasOperations)\r\n    \tconst buildPush =\r\n            (op: CanvasOperation) =>\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            \t(...args: any[]): void => {\r\n            \t\tthis._ops.push({\r\n            \t\t\top,\r\n            \t\t\targs\r\n            \t\t})\r\n            \t}\r\n    \tthis.moveTo = buildPush('moveTo')\r\n    \tthis.lineTo = buildPush('lineTo')\r\n    \tthis.closePath = buildPush('closePath')\r\n    \tthis.bezierCurveTo = buildPush('bezierCurveTo')\r\n    \tthis.quadraticCurveTo = buildPush('quadraticCurveTo')\r\n    \tthis.save = buildPush('save')\r\n    \tthis.translate = buildPush('translate')\r\n    \tthis.rotate = buildPush('rotate')\r\n    \tthis.scale = buildPush('scale')\r\n    \tthis.arc = buildPush('arc')\r\n    \tthis.restore = buildPush('restore')\r\n    \tthis.arcTo = buildPush('arcTo')\r\n    \tthis.ellipse = buildPush('ellipse')\r\n    \tthis.rect = buildPush('rect')\r\n    }\r\n\r\n    command(name: PathCommandName, ...args: any[]): void {\r\n    \tconst numArgs: any[] = args || []\r\n    \tfor (let i = 0; i < args.length; i++) {\r\n    \t\tnumArgs[i] -= 0\r\n    \t}\r\n    \tconst command: AnyFunction = this._commands[name]\r\n    \tcommand.apply(this, numArgs)\r\n    }\r\n\r\n    parse(d: string): { op: CanvasOperation; args: any[] }[] {\r\n    \tconst ops: { op: keyof CanvasOperations; args: any[]; }[] = (this._ops = [])\r\n    \tconst tokens = pathTokens(d)\r\n    \ttry {\r\n    \t\tlet cmd: string | null\r\n    \t\tlet subsequentCommand: PathCommandName = 'Z'\r\n    \t\twhile ((cmd = tokens.next())) {\r\n    \t\t\tif (!isNaN(Number(cmd))) {\r\n    \t\t\t\tlet fst = true\r\n    \t\t\t\tconst argsProvider: Tokens = {\r\n    \t\t\t\t\tnext() {\r\n    \t\t\t\t\t\tif (fst) {\r\n    \t\t\t\t\t\t\tfst = false\r\n    \t\t\t\t\t\t\treturn cmd\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t\t\treturn tokens.next()\r\n    \t\t\t\t\t}\r\n    \t\t\t\t}\r\n    \t\t\t\tsubsequentCommand = command(this, subsequentCommand, argsProvider) || 'Z'\r\n    \t\t\t} else {\r\n    \t\t\t\tsubsequentCommand = command(this, cmd as PathCommandName, tokens) || 'Z'\r\n    \t\t\t}\r\n    \t\t}\r\n    \t} catch (e) {\r\n    \t\tconsole.log(`Error: ${ d }`)\r\n    \t\tthrow e\r\n    \t}\r\n    \treturn ops\r\n    }\r\n}\r\n","//see https://github.com/typekit/webfontloader\r\n\r\ntype Styles1 = {\r\n    display: 'block';\r\n    position: 'absolute';\r\n    top: '-9999px';\r\n    left: '-9999px';\r\n    width: 'auto';\r\n    height: 'auto';\r\n    margin: '0';\r\n    padding: '0';\r\n    'white-space': 'nowrap';\r\n    font: string;\r\n};\r\ntype Styles2 = {\r\n    'font-variant': 'normal';\r\n    'font-size': '300px';\r\n    'font-style': 'normal';\r\n    'font-weight': '400';\r\n    'line-height': 'normal';\r\n};\r\n\r\ntype StyleKeys = keyof Styles1 | keyof Styles2;\r\n\r\nfunction computeStyle(font: string): [ Styles1, Styles2 ] {\r\n\treturn [\r\n\t\t{\r\n\t\t\t'display': 'block',\r\n\t\t\t'position': 'absolute',\r\n\t\t\t'top': '-9999px',\r\n\t\t\t'left': '-9999px',\r\n\t\t\t'width': 'auto',\r\n\t\t\t'height': 'auto',\r\n\t\t\t'margin': '0',\r\n\t\t\t'padding': '0',\r\n\t\t\t'white-space': 'nowrap',\r\n\t\t\tfont\r\n\t\t},\r\n\t\t{\r\n\t\t\t'font-variant': 'normal',\r\n\t\t\t'font-size': '300px',\r\n\t\t\t'font-style': 'normal',\r\n\t\t\t'font-weight': '400',\r\n\t\t\t'line-height': 'normal'\r\n\t\t}\r\n\t]\r\n}\r\n\r\nexport class FontRuler {\r\n    private el_: HTMLSpanElement\r\n\r\n    constructor(font: string, testStr: string) {\r\n    \tconst e = document.createElement('span')\r\n    \te.setAttribute('aria-hidden', 'true')\r\n    \te.textContent = testStr || 'BESbswy'\r\n\r\n    \tcomputeStyle(font).forEach((style: Styles1 | Styles2) => {\r\n    \t\tfor (const k in style) {\r\n    \t\t\tconst key = k as StyleKeys\r\n    \t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    \t\t\te.style[key as any] = (style as any)[key]\r\n    \t\t}\r\n    \t})\r\n    \tdocument.body.appendChild(e)\r\n    \tthis.el_ = e\r\n    }\r\n\r\n    getWidth(): number {\r\n    \treturn this.el_.offsetWidth\r\n    }\r\n\r\n    remove(): void {\r\n    \tdocument.body.removeChild(this.el_)\r\n    }\r\n}\r\n","import { AnyFunction } from '../../../ts-types'\r\n//see https://github.com/typekit/webfontloader\r\n\r\n//http://defghi1977.html.xdomain.jp/tech/canvasMemo/canvasMemo.htm\r\nimport { FontRuler } from './FontRuler'\r\n\r\nconst LastResortFonts: { [key: string]: string } = {\r\n\tSERIF: 'serif',\r\n\tSANS_SERIF: 'sans-serif'\r\n}\r\n\r\nconst watchRunners: {\r\n    [font: string]: { [testStr: string]: FontWatchRunner };\r\n} = {}\r\n\r\nclass FontWatchRunner {\r\n    activeCallbacks: AnyFunction[]\r\n\r\n    inactiveCallbacks: AnyFunction[]\r\n\r\n    status: 'ok' | 'ng' | null\r\n\r\n    lastResortWidths_: { [font: string]: number }\r\n\r\n    fontRulerA_: FontRuler\r\n\r\n    fontRulerB_: FontRuler\r\n\r\n    started_: number\r\n\r\n    static async load(font: string, testStr: string, activeCallback: AnyFunction, inactiveCallback: AnyFunction): Promise<void> {\r\n    \tconst c = watchRunners[font] || (watchRunners[font] = {})\r\n    \ttestStr += ''\r\n    \tlet runner\r\n    \tif (await c[testStr]) {\r\n    \t\trunner = c[testStr]\r\n    \t} else {\r\n    \t\trunner = c[testStr] = new FontWatchRunner(font, testStr)\r\n    \t}\r\n    \trunner.then(activeCallback, inactiveCallback)\r\n    }\r\n\r\n    constructor(font: string, testStr: string) {\r\n    \tthis.activeCallbacks = []\r\n    \tthis.inactiveCallbacks = []\r\n    \tthis.status = null\r\n    \tthis.lastResortWidths_ = {}\r\n\r\n    \tthis.fontRulerA_ = new FontRuler(`${ font },${ LastResortFonts.SERIF }`, testStr)\r\n    \tthis.fontRulerB_ = new FontRuler(`${ font },${ LastResortFonts.SANS_SERIF }`, testStr)\r\n    \tconst lastResortRulerA = new FontRuler(`4px ${ LastResortFonts.SERIF }`, testStr)\r\n    \tconst lastResortRulerB = new FontRuler(`4px ${ LastResortFonts.SANS_SERIF }`, testStr)\r\n\r\n    \t//start\r\n    \tthis.lastResortWidths_[LastResortFonts.SERIF] = lastResortRulerA.getWidth()\r\n    \tthis.lastResortWidths_[LastResortFonts.SANS_SERIF] = lastResortRulerB.getWidth()\r\n\r\n    \tlastResortRulerA.remove()\r\n    \tlastResortRulerB.remove()\r\n\r\n    \tthis.started_ = Date.now()\r\n\r\n    \tthis.check_()\r\n    }\r\n\r\n    then(activeCallback: AnyFunction, inactiveCallback: AnyFunction): void {\r\n    \tif (this.status) {\r\n    \t\tif (this.status !== 'ng') {\r\n    \t\t\tactiveCallback()\r\n    \t\t} else {\r\n    \t\t\tinactiveCallback()\r\n    \t\t}\r\n    \t} else {\r\n    \t\tthis.activeCallbacks.push(activeCallback)\r\n    \t\tthis.inactiveCallbacks.push(inactiveCallback)\r\n    \t}\r\n    }\r\n\r\n    private check_(): void {\r\n    \tconst widthA = this.fontRulerA_.getWidth()\r\n    \tconst widthB = this.fontRulerB_.getWidth()\r\n\r\n    \tif (this.isFallbackFont_(widthA, widthB) || this.isLastResortFont_(widthA, widthB)) {\r\n    \t\tif (Date.now() - this.started_ >= 3000) {\r\n    \t\t\t// timeout\r\n    \t\t\tif (this.isLastResortFont_(widthA, widthB)) {\r\n    \t\t\t\tthis.finish_(this.activeCallbacks)\r\n    \t\t\t\tthis.status = 'ok'\r\n    \t\t\t} else {\r\n    \t\t\t\tthis.finish_(this.inactiveCallbacks)\r\n    \t\t\t\tthis.status = 'ng'\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\tsetTimeout(() => {\r\n    \t\t\t\tthis.check_()\r\n    \t\t\t}, 50)\r\n    \t\t}\r\n    \t} else {\r\n    \t\tthis.finish_(this.activeCallbacks)\r\n    \t\tthis.status = 'ok'\r\n    \t}\r\n    }\r\n\r\n    isFallbackFont_(a: number, b: number): boolean {\r\n    \treturn this.widthMatches_(a, LastResortFonts.SERIF) && this.widthMatches_(b, LastResortFonts.SANS_SERIF)\r\n    }\r\n\r\n    widthsMatchLastResortWidths_(a: number, b: number): boolean {\r\n    \tfor (const font in LastResortFonts) {\r\n    \t\tif (LastResortFonts.hasOwnProperty(font)) {\r\n    \t\t\tif (this.widthMatches_(a, LastResortFonts[font]) && this.widthMatches_(b, LastResortFonts[font])) {\r\n    \t\t\t\treturn true\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn false\r\n    }\r\n\r\n    widthMatches_(width: number, lastResortFont: string): boolean {\r\n    \treturn width === this.lastResortWidths_[lastResortFont]\r\n    }\r\n\r\n    isLastResortFont_(a: number, b: number): boolean {\r\n    \treturn hasWebKitFallbackBug() && this.widthsMatchLastResortWidths_(a, b)\r\n    }\r\n\r\n    finish_(callbacks: AnyFunction[]): void {\r\n    \tsetTimeout(() => {\r\n    \t\tthis.fontRulerA_.remove()\r\n    \t\tthis.fontRulerB_.remove()\r\n    \t\tcallbacks.forEach((cb) => cb())\r\n    \t}, 0)\r\n    }\r\n}\r\n\r\nlet HAS_WEBKIT_FALLBACK_BUG: boolean | null = null\r\n\r\nfunction hasWebKitFallbackBug(): boolean {\r\n\tif (HAS_WEBKIT_FALLBACK_BUG === null) {\r\n\t\tconst match = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent)\r\n\r\n\t\tHAS_WEBKIT_FALLBACK_BUG = !!match && (parseInt(match[1], 10) < 536 || (parseInt(match[1], 10) === 536 && parseInt(match[2], 10) <= 11))\r\n\t}\r\n\treturn HAS_WEBKIT_FALLBACK_BUG\r\n}\r\n\r\nexport default FontWatchRunner\r\n","import type { ColumnMenuItemOption, ColumnMenuItemOptions } from '../ts-types'\r\n\r\n/** @private */\r\nfunction extend<T, U>(a: T, b: U): T & U {\r\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\tconst o: any = {}\r\n\tfor (const k in a) {\r\n\t\to[k] = a[k]\r\n\t}\r\n\tfor (const k in b) {\r\n\t\to[k] = b[k]\r\n\t}\r\n\treturn o\r\n}\r\n\r\n/**\r\n * Normalize the given menu options.\r\n * @param {*} options menu options to given\r\n * @returns {Array} Normalized options\r\n * @private\r\n */\r\nexport function normalize(options: ColumnMenuItemOptions | undefined): ColumnMenuItemOption[] {\r\n\tif (!options) {\r\n\t\treturn []\r\n\t}\r\n\tif (Array.isArray(options)) {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\treturn (options as any).map(\r\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\t\t(e: any): ColumnMenuItemOption => extend(e, { label: e.caption || e.label })\r\n\t\t)\r\n\t}\r\n\tif (typeof options === 'string') {\r\n\t\treturn normalize(JSON.parse(options))\r\n\t}\r\n\tconst result = []\r\n\tfor (const k in options) {\r\n\t\tresult.push({\r\n\t\t\tvalue: k,\r\n\t\t\tlabel: options[k]\r\n\t\t})\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Normalize the given menu options.\r\n * @param {*} options menu options to given\r\n * @returns {Array} Normalized options\r\n * @private\r\n */\r\nexport function normalizeToFn<T>(options: ColumnMenuItemOptions | ((record: T | undefined) => ColumnMenuItemOptions) | undefined): (record: T | undefined) => ColumnMenuItemOption[] {\r\n\tif (typeof options === 'function') {\r\n\t\treturn (record: T | undefined): ColumnMenuItemOption[] => normalize(options(record))\r\n\t}\r\n\treturn (): ColumnMenuItemOption[] => normalize(options)\r\n}\r\n","import type { PasteRangeBoxValues } from '../ts-types'\r\n\r\nexport function parsePasteRangeBoxValues(value: string): PasteRangeBoxValues {\r\n\tconst normalizeValue = value.replace(/\\r?\\n$/, '')\r\n\tconst lines = normalizeValue.split(/(?:\\r?\\n)|[\\u2028\\u2029]/g)\r\n\tconst values = lines.map((line) => line.split(/\\t/g))\r\n\tconst colCount = values.reduce((n, cells) => Math.max(n, cells.length), 0)\r\n\treturn {\r\n\t\tcolCount,\r\n\t\trowCount: values.length,\r\n\t\tgetCellValue(offsetCol: number, offsetRow: number): string {\r\n\t\t\treturn values[offsetRow]?.[offsetCol] || ''\r\n\t\t}\r\n\t}\r\n}\r\n","import { browser } from './utils'\r\n\r\nexport function getPath2D(): typeof Path2D {\r\n\tif (typeof Path2D !== 'undefined' && !browser.Edge) {\r\n\t\treturn Path2D\r\n\t}\r\n\t// eslint-disable-next-line @typescript-eslint/no-var-requires\r\n\treturn require('./legacy/canvas/Path2DShim').Path2DShim\r\n}\r\n\r\nexport function fill(\r\n\t\tpathModule: {\r\n        width: number;\r\n        height: number;\r\n        ud?: boolean;\r\n        x?: number;\r\n        y?: number;\r\n        d: string;\r\n        path2d?: Path2D;\r\n    },\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\tw: number,\r\n\t\th: number\r\n): void {\r\n\tctx.save()\r\n\ttry {\r\n\t\tconst { width, height } = pathModule\r\n\t\tconst { ud: upsideDown, x: offsetX = 0, y: offsetY = 0 } = pathModule\r\n\t\tw = w || width\r\n\t\th = h || height\r\n\t\tconst xrate = w / width\r\n\t\tconst yrate = h / (upsideDown ? -height : height)\r\n\t\tx = x || 0\r\n\t\ty = upsideDown ? (y || 0) + -height * yrate : y || 0\r\n\r\n\t\tctx.translate(x, y)\r\n\t\tctx.scale(xrate, yrate)\r\n\t\tif (offsetX !== 0 || offsetY !== 0) {\r\n\t\t\tctx.translate(offsetX, offsetY)\r\n\t\t}\r\n\t\tconst Path2D = getPath2D()\r\n\t\tconst path2d = (pathModule.path2d = pathModule.path2d || new Path2D(pathModule.d))\r\n\t\tctx.fill(path2d)\r\n\t} finally {\r\n\t\tctx.restore()\r\n\t}\r\n}\r\n","import type { MaybePromise } from '../ts-types'\r\nimport { isPromise } from './utils'\r\n\r\nfunction createArray<T>(get: (i: number) => T, length: number): T[] {\r\n\tconst array = new Array<T>(length)\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tarray[i] = get(i)\r\n\t}\r\n\treturn array\r\n}\r\n\r\nfunction createArrayPromise<R>(get: (i: number) => MaybePromise<R>, getField: undefined, length: number): Promise<{ v: R; f: R }[]>;\r\nfunction createArrayPromise<R, F>(get: (i: number) => MaybePromise<R>, getField: (r: R) => MaybePromise<F>, length: number): Promise<{ v: R; f: F }[]>;\r\nfunction createArrayPromise<R, F>(\r\n\t\tget: (i: number) => MaybePromise<R>,\r\n\t\tgetField: ((r: R) => MaybePromise<F>) | undefined,\r\n\t\tlength: number\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n): Promise<any[]> {\r\n\treturn new Promise((resolve) => {\r\n\t\tconst plist = []\r\n\t\tconst array = new Array<{ v: MaybePromise<R>; f: MaybePromise<R> }>(length)\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tconst data = get(i)\r\n\t\t\tconst record = {\r\n\t\t\t\tv: data,\r\n\t\t\t\tf: data\r\n\t\t\t}\r\n\t\t\tarray[i] = record\r\n\t\t\tif (isPromise(data)) {\r\n\t\t\t\tplist.push(\r\n\t\t\t\t\t\tdata.then((v) => {\r\n\t\t\t\t\t\t\trecord.v = v\r\n\t\t\t\t\t\t\trecord.f = v\r\n\t\t\t\t\t\t})\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t\tPromise.all(plist).then(() => getField == null\r\n\t\t\t? // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\t(array as any)\r\n\t\t\t: // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t\tsetArrayField(array as any, getField)\r\n\t\t).then(resolve)\r\n\t})\r\n}\r\n\r\nfunction setArrayField<R, F>(array: { v: R; f: R | F }[], getField: (r: R) => MaybePromise<F>): Promise<{ v: R; f: F }[]> {\r\n\treturn new Promise((resolve) => {\r\n\t\tconst { length } = array\r\n\t\tconst plist = []\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tconst record = array[i]\r\n\t\t\tconst f = getField(record.v)\r\n\t\t\tif (isPromise(f)) {\r\n\t\t\t\tplist.push(\r\n\t\t\t\t\t\tf.then((v) => {\r\n\t\t\t\t\t\t\trecord.f = v\r\n\t\t\t\t\t\t})\r\n\t\t\t\t)\r\n\t\t\t} else {\r\n\t\t\t\trecord.f = f\r\n\t\t\t}\r\n\t\t}\r\n\t\tPromise.all(plist).then(() => resolve(array as { v: R; f: F }[]))\r\n\t})\r\n}\r\n\r\nexport function sortArray<T>(array: T[], compare: (a: T, b: T) => number): void {\r\n\tArray.prototype.sort.call(array, compare)\r\n}\r\n\r\nexport function sort<R, _F>(get: (i: number) => R, set: (i: number, r: R) => void, length: number, compare: (a: R, b: R) => number): void;\r\nexport function sort<R, F>(get: (i: number) => R, set: (i: number, r: R) => void, length: number, compare: (a: F, b: F) => number, getField: (r: R) => F): void;\r\nexport function sort<R, F>(get: (i: number) => R, set: (i: number, r: R) => void, length: number, compare: ((a: R, b: R) => number) | ((a: F, b: F) => number), getField?: (r: R) => F): void {\r\n\tconst old = createArray(get, length)\r\n\tif (getField != null) {\r\n\t\told.sort((r1, r2) => (compare as (a: F, b: F) => number)(getField(r1), getField(r2)))\r\n\t} else {\r\n\t\told.sort(compare as (a: R, b: R) => number)\r\n\t}\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tset(i, old[i])\r\n\t}\r\n}\r\n\r\nexport function sortPromise<R, _F>(get: (i: number) => MaybePromise<R>, set: (i: number, r: R) => void, length: number, compare: (a: R, b: R) => number): void;\r\nexport function sortPromise<R, F>(\r\n    get: (i: number) => MaybePromise<R>,\r\n    set: (i: number, r: R) => void,\r\n    length: number,\r\n    compare: (a: F, b: F) => number,\r\n    getField: (r: R) => MaybePromise<F | undefined>\r\n): Promise<void>;\r\nexport function sortPromise<R, F>(\r\n\t\tget: (i: number) => MaybePromise<R>,\r\n\t\tset: (i: number, r: R) => void,\r\n\t\tlength: number,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tcompare: any,\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tgetField?: any\r\n): Promise<void> {\r\n\tif (typeof Promise !== 'undefined') {\r\n\t\treturn createArrayPromise(get, getField, length).then((array) => {\r\n\t\t\tarray.sort((r1, r2) => compare(r1.f, r2.f))\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tset(i, array[i].v)\r\n\t\t\t}\r\n\t\t})\r\n\t} else {\r\n\t\tsort(get as (i: number) => R, set, length, compare as (a: F, b: F) => number, getField as (r: R) => F)\r\n\t\tconst dummyPromise: Promise<undefined> = {\r\n\t\t\tthen(fn: () => void): Promise<undefined> {\r\n\t\t\t\tfn()\r\n\t\t\t\treturn dummyPromise\r\n\t\t\t},\r\n\t\t\tcatch(): Promise<undefined> {\r\n\t\t\t\treturn dummyPromise\r\n\t\t\t}\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\t} as any\r\n\t\treturn dummyPromise\r\n\t}\r\n}\r\n","function getScrollBarWidth(): number {\r\n\tconst dummy = document.createElement('div')\r\n\tconst { style } = dummy\r\n\tstyle.position = 'absolute'\r\n\tstyle.height = '9999px'\r\n\tstyle.width = 'calc(100vw - 100%)'\r\n\tstyle.opacity = '0'\r\n\tdummy.textContent = 'x'\r\n\tdocument.body.appendChild(dummy)\r\n\tconst { width } = (document.defaultView || window).getComputedStyle(dummy, '')\r\n\tdocument.body.removeChild(dummy)\r\n\treturn parseInt(width, 10)\r\n}\r\n\r\nlet SCROLLBAR_SIZE: number\r\nimport './style.css'\r\n\r\nfunction initDocumentInternal(): void {\r\n\t// require(\"@/internal/style.css\");\r\n\tSCROLLBAR_SIZE = getScrollBarWidth() || 10\r\n\tconst style = document.createElement('style')\r\n\tstyle.setAttribute('type', 'text/css')\r\n\tstyle.setAttribute('data-name', 'cheetah-grid')\r\n\tstyle.innerHTML = `\r\n.cheetah-grid .grid-scroll-end-point {\r\n\twidth: ${ SCROLLBAR_SIZE }px;\r\n\theight: ${ SCROLLBAR_SIZE }px;\r\n}\r\n.cheetah-grid > canvas {\r\n\twidth: -webkit-calc(100% - ${ SCROLLBAR_SIZE }px);\r\n\twidth: calc(100% - ${ SCROLLBAR_SIZE }px);\r\n\theight: -webkit-calc(100% - ${ SCROLLBAR_SIZE }px);\r\n\theight: calc(100% - ${ SCROLLBAR_SIZE }px);\r\n}\r\n\t\t`\r\n\r\n\tdocument.head.appendChild(style)\r\n}\r\n\r\nlet initDocumentVar = initDocumentInternal\r\n\r\nexport function initDocument(): void {\r\n\tinitDocumentVar()\r\n\tinitDocumentVar = Function.prototype as () => void\r\n}\r\n\r\nexport function getScrollBarSize(): number {\r\n\treturn SCROLLBAR_SIZE\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { isNode } from './utils'\r\n\r\ntype SymbolType = (description?: string | number) => symbol;\r\n\r\nconst Symbol: SymbolType = isNode\r\n\t? (global.Symbol as SymbolType)\r\n\t: (window.Symbol as SymbolType)\r\n\t\t? (window.Symbol as SymbolType)\r\n\t\t: ((): SymbolType => {\r\n\t\t\tfunction random(): string {\r\n\t\t\t\tconst c = 'abcdefghijklmnopqrstuvwxyz0123456789'\r\n\t\t\t\tconst cl = c.length\r\n\t\t\t\tlet r = ''\r\n\t\t\t\tfor (let i = 0; i < 10; i++) {\r\n\t\t\t\t\tr += c[Math.floor(Math.random() * cl)]\r\n\t\t\t\t}\r\n\t\t\t\treturn r\r\n\t\t\t}\r\n\r\n\t\t\treturn (name?: string | number): symbol => {\r\n\t\t\t\tif (name) {\r\n\t\t\t\t\treturn `#${ name }_${ random() }` as any\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn `#_${ random() }` as any\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})()\r\nconst mem: { [key: string]: symbol } = {}\r\n\r\nexport function get(name?: string): '$$$$private symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\tif (name) {\r\n\t\treturn (mem[name] ? mem[name] : (mem[name] = Symbol(name))) as any\r\n\t} else {\r\n\t\treturn Symbol() as any\r\n\t}\r\n}\r\n\r\nexport function getProtectedSymbol(): '$$$$protected symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('protected') as any\r\n}\r\n\r\nexport function getCheckColumnStateId(): '$$$$chkcol.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('chkcol.stateID') as any\r\n}\r\n\r\nexport function getRadioColumnStateId(): '$$$$rdcol.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('rdcol.stateID') as any\r\n}\r\n\r\nexport function getButtonColumnStateId(): '$$$$btncol.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('btncol.stateID') as any\r\n}\r\n\r\nexport function getColumnFadeinStateId(): '$$$$col.fadein_stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('col.fadein_stateID') as any\r\n}\r\n\r\nexport function getBranchGraphColumnStateId(): '$$$$branch_graph_col.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('branch_graph_col.stateID') as any\r\n}\r\n\r\nexport function getSmallDialogInputEditorStateId(): '$$$$small_dialog_input_editor.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('small_dialog_input_editor.stateID') as any\r\n}\r\n\r\nexport function getInlineInputEditorStateId(): '$$$$inline_input_editor.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('inline_input_editor.stateID') as any\r\n}\r\n\r\nexport function getInlineMenuEditorStateId(): '$$$$inline_menu_editor.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('inline_menu_editor.stateID') as any\r\n}\r\n\r\nexport function getCheckHeaderStateId(): '$$$$check_header.stateID symbol$$$$' /* It is treated as a string so that it can be handled easily with typescript. */ {\r\n\treturn get('check_header.stateID') as any\r\n}\r\n","import type { CellAddress, CellRange, MaybeCall, MaybePromise } from '../ts-types'\r\n\r\nconst isNode = typeof window === 'undefined' || typeof window.window === 'undefined'\r\n\r\ntype ArrayElementPredicate<E> = (t: E, i: number, arr: E[]) => boolean;\r\n// type ObjectElementPredicate<T, K extends keyof T> = (\r\n//   t: T[K],\r\n//   key?: K,\r\n//   obj?: T\r\n// ) => boolean;\r\n\r\ntype ArrayElementFunction<E> = (t: E, i: number, arr: E[]) => void;\r\ntype ObjectElementFunction<T, K extends keyof T> = (t: T[K], key: K, obj: T) => void;\r\nlet arrayFind: <T>(arr: T[], predicate: ArrayElementPredicate<T>) => T | undefined\r\nlet arrayFindIndex: <T>(arr: T[], predicate: ArrayElementPredicate<T>) => number\r\nconst array = {\r\n\tget find(): typeof arrayFind {\r\n\t\tif (arrayFind) {\r\n\t\t\treturn arrayFind\r\n\t\t}\r\n\t\tif (Array.prototype.find) {\r\n\t\t\tarrayFind = <T>(arr: T[], predicate: ArrayElementPredicate<T>): T | undefined => Array.prototype.find.call(arr, predicate)\r\n\t\t} else {\r\n\t\t\tarrayFind = <T>(arr: T[], predicate: ArrayElementPredicate<T>): T | undefined => {\r\n\t\t\t\tconst index = array.findIndex(arr, predicate)\r\n\t\t\t\treturn index >= 0 ? arr[index] : undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn arrayFind\r\n\t},\r\n\tget findIndex(): typeof arrayFindIndex {\r\n\t\tif (arrayFindIndex) {\r\n\t\t\treturn arrayFindIndex\r\n\t\t}\r\n\t\tif (Array.prototype.findIndex) {\r\n\t\t\tarrayFindIndex = <T>(arr: T[], predicate: ArrayElementPredicate<T>): number => Array.prototype.findIndex.call(arr, predicate)\r\n\t\t} else {\r\n\t\t\tarrayFindIndex = <T>(arr: T[], predicate: ArrayElementPredicate<T>): number => {\r\n\t\t\t\tconst { length } = arr\r\n\t\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\t\tconst value = arr[i]\r\n\t\t\t\t\tif (predicate(value, i, arr)) {\r\n\t\t\t\t\t\treturn i\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn -1\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn arrayFindIndex\r\n\t}\r\n}\r\n\r\nfunction analyzeUserAgent(): {\r\n    IE: boolean;\r\n    Edge: boolean;\r\n    Chrome: boolean;\r\n    Firefox: boolean;\r\n    Safari: boolean;\r\n    } {\r\n\tif (isNode) {\r\n\t\treturn {\r\n\t\t\tIE: false,\r\n\t\t\tEdge: false,\r\n\t\t\tChrome: false,\r\n\t\t\tFirefox: false,\r\n\t\t\tSafari: false\r\n\t\t}\r\n\t} else {\r\n\t\tconst ua = window.navigator.userAgent.toLowerCase()\r\n\t\treturn {\r\n\t\t\tIE: !!/(msie|trident)/.exec(ua),\r\n\t\t\tEdge: ua.indexOf('edge') > -1,\r\n\t\t\tChrome: ua.indexOf('chrome') > -1 && ua.indexOf('edge') === -1,\r\n\t\t\tFirefox: ua.indexOf('firefox') > -1,\r\n\t\t\tSafari: ua.indexOf('safari') > -1 && ua.indexOf('edge') === -1\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst isDef = <T>(data: T | null | undefined | void): data is T => {\r\n\treturn data !== null && typeof data !== 'undefined'\r\n}\r\n\r\nconst isDefString = <T>(data: T | null | undefined | void): data is T => {\r\n\treturn isDef(data) && (typeof data !== 'string' || data !== '')\r\n}\r\nconst { IE, Chrome, Firefox, Edge, Safari } = analyzeUserAgent()\r\n\r\nfunction setReadonly<T, K extends keyof T>(obj: T, name: K, value: T[K]): void {\r\n\tObject.defineProperty(obj, name, {\r\n\t\tenumerable: false,\r\n\t\tconfigurable: true,\r\n\t\tvalue\r\n\t})\r\n}\r\n\r\nexport function each<E>(obj: E[], fn: ArrayElementFunction<E>): void;\r\nexport function each<T, K extends keyof T>(obj: T, fn: ObjectElementFunction<T, K>): void;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function each(obj: any, fn: any): void {\r\n\tfor (const key in obj) {\r\n\t\tfn(obj[key], key, obj)\r\n\t}\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction isObject(obj: any): obj is Record<string, any> {\r\n\treturn obj === Object(obj)\r\n}\r\n\r\nexport function omit<T, K extends keyof T>(source: T, omits: K[]): Omit<T, K> {\r\n\tconst result = {} as Omit<T, K>\r\n\tfor (const key in source) {\r\n\t\tif (omits.indexOf(key as never) >= 0) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tObject.defineProperty(result, key, {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[key]\r\n\t\t\t},\r\n\t\t\tset(val) {\r\n\t\t\t\tsource[key] = val\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true\r\n\t\t})\r\n\t}\r\n\treturn result\r\n}\r\n\r\nexport function defaults<T>(source: T, defs: Partial<T>): T {\r\n\tconst keys: string[] = []\r\n\tconst result = {} as T\r\n\tfor (const key in source) {\r\n\t\tkeys.push(key)\r\n\t\tObject.defineProperty(result, key, {\r\n\t\t\tget() {\r\n\t\t\t\tconst val = source[key]\r\n\t\t\t\treturn val === undefined ? defs[key] : val\r\n\t\t\t},\r\n\t\t\tset(val) {\r\n\t\t\t\tsource[key] = val\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true\r\n\t\t})\r\n\t}\r\n\tfor (const key in defs) {\r\n\t\tif (keys.indexOf(key) >= 0) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tObject.defineProperty(result, key, {\r\n\t\t\tget() {\r\n\t\t\t\tconst val = source[key]\r\n\t\t\t\treturn val === undefined ? defs[key] : val\r\n\t\t\t},\r\n\t\t\tset(val) {\r\n\t\t\t\tsource[key] = val\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t\tenumerable: true\r\n\t\t})\r\n\t}\r\n\treturn result\r\n}\r\n\r\nexport function extend<T, U>(t: T, u: U): T & U;\r\nexport function extend<T, U, V>(t: T, u: U, v: V): T & U & V;\r\nexport function extend<T>(...args: T[]): T;\r\nexport function extend<T>(...args: T[]): T {\r\n\tconst result = {} as T\r\n\targs.forEach((source) => {\r\n\t\tfor (const key in source) {\r\n\t\t\tObject.defineProperty(result, key, {\r\n\t\t\t\tget() {\r\n\t\t\t\t\treturn source[key]\r\n\t\t\t\t},\r\n\t\t\t\tset(val) {\r\n\t\t\t\t\tsource[key] = val\r\n\t\t\t\t},\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tenumerable: true\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n\treturn result\r\n}\r\n\r\nfunction isDescendantElement(root: HTMLElement, target: HTMLElement): boolean {\r\n\twhile (target.parentElement) {\r\n\t\tconst p = target.parentElement\r\n\t\tif (root === p) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\ttarget = p\r\n\t}\r\n\treturn false\r\n}\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nfunction applyChainSafe(obj: any, fn: (value: any, name: string) => any, ...names: string[]): any {\r\n\tlet value = obj\r\n\tfor (let i = 0; i < names.length && value != null; i++) {\r\n\t\tvalue = fn(value, names[i])\r\n\t}\r\n\treturn value\r\n}\r\n\r\nfunction getChainSafe(obj: any, ...names: string[]): any {\r\n\treturn applyChainSafe(obj, (val, name) => val[name], ...names)\r\n}\r\n\r\nfunction getOrApply<_T, A extends any[]>(value: undefined, ...args: A): undefined;\r\nfunction getOrApply<_T, A extends any[]>(value: null, ...args: A): null;\r\nfunction getOrApply<T, A extends any[]>(value: MaybeCall<T, A>, ...args: A): T;\r\nfunction getOrApply<T, A extends any[]>(value: MaybeCall<T, A>, ...args: A): T {\r\n\tif (typeof value === 'function') {\r\n\t\treturn (value as any)(...args)\r\n\t} else {\r\n\t\treturn value\r\n\t}\r\n}\r\n\r\n/* eslint-enable @typescript-eslint/no-explicit-any */\r\nfunction endsWith(str: string, searchString: string, position?: number): boolean {\r\n\tconst subjectString = str.toString()\r\n\tif (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n\t\tposition = subjectString.length\r\n\t}\r\n\tposition -= searchString.length\r\n\tconst lastIndex = subjectString.lastIndexOf(searchString, position)\r\n\treturn lastIndex !== -1 && lastIndex === position\r\n}\r\n\r\nfunction genChars(s: string): { next(): string | null } {\r\n\t// Surrogate Code Point\r\n\t// [\\uD800-\\uDBFF]\r\n\t// Variation Selectors\r\n\t// FVS [\\u180B-\\u180D]\r\n\t// VS1VS16 [\\uFE00-\\uFE0F]\r\n\t// VS17VS256 \\uDB40[\\uDD00-\\uDDEF]\r\n\tconst re = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|\\r\\n|[^\\uD800-\\uDFFF])([\\u180B-\\u180D]|[\\uFE00-\\uFE0F]|\\uDB40[\\uDD00-\\uDDEF])?/g\r\n\treturn {\r\n\t\tnext(): string | null {\r\n\t\t\tconst res = re.exec(s)\r\n\t\t\treturn res !== null ? res[0] : null\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport type GenWordsResult = {\r\n    next(): string | null;\r\n};\r\n\r\nfunction genWords(s: string): GenWordsResult {\r\n\tconst re = /[!-~]+|[^!-~\\s]+|\\s+/g\r\n\treturn {\r\n\t\tnext(): string | null {\r\n\t\t\tconst res = re.exec(s)\r\n\t\t\treturn res !== null ? res[0] : null\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isPromise<T>(data: T | Promise<T> | undefined): data is Promise<T> {\r\n\treturn Boolean(data && typeof (data as Promise<T>).then === 'function')\r\n}\r\n\r\nfunction then<T, R>(result: MaybePromise<T>, callback: (arg: T) => MaybePromise<R>): MaybePromise<R>;\r\nfunction then<T, R>(result: MaybePromise<T>, callback: (arg: T) => R): MaybePromise<R>;\r\nfunction then<T, R>(result: MaybePromise<T>, callback: (arg: T) => R): MaybePromise<R> {\r\n\treturn isPromise(result) ? result.then((r) => callback(r)) : callback(result)\r\n}\r\n\r\nfunction getMouseButtons(e: MouseEvent): number {\r\n\tif (e.buttons != null) {\r\n\t\treturn e.buttons\r\n\t}\r\n\t/*for legacy*/\r\n\tif (e.which != null) {\r\n\t\tif (e.which === 3) {\r\n\t\t\t//right?\r\n\t\t\treturn 4\r\n\t\t}\r\n\t\tif (e.which === 2) {\r\n\t\t\t//middle?\r\n\t\t\treturn 4\r\n\t\t}\r\n\t\treturn e.which //left or no\r\n\t}\r\n\r\n\tif (e.button === 0 || e.button === 1) {\r\n\t\treturn 1 //candidate left\r\n\t}\r\n\tif (e.button === 2) {\r\n\t\treturn 2 // right\r\n\t}\r\n\treturn 0 //no or middle?\r\n}\r\n\r\nfunction getKeyCode(e: KeyboardEvent): number {\r\n\treturn e.keyCode || e.which\r\n}\r\n\r\nfunction isTouchEvent(e: TouchEvent | MouseEvent): e is TouchEvent {\r\n\treturn !!(e as TouchEvent).changedTouches\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction getIgnoreCase(obj: any, name: string): any {\r\n\tif (obj[name]) {\r\n\t\treturn obj[name]\r\n\t}\r\n\tconst l = name.toLowerCase()\r\n\tif (obj[l]) {\r\n\t\treturn obj[l]\r\n\t}\r\n\tconst u = name.toLowerCase()\r\n\tif (obj[u]) {\r\n\t\treturn obj[u]\r\n\t}\r\n\tfor (const k in obj) {\r\n\t\tif (k.toLowerCase() === l) {\r\n\t\t\treturn obj[k]\r\n\t\t}\r\n\t}\r\n\treturn undefined\r\n}\r\n\r\nfunction cancel(e: Event): void {\r\n\te.preventDefault()\r\n\te.stopPropagation()\r\n}\r\n\r\nfunction toBoxArray<T>(obj: T | T[]): [ T, T, T, T ] {\r\n\tif (!Array.isArray(obj)) {\r\n\t\treturn [ obj /*top*/, obj /*right*/, obj /*bottom*/, obj ]\r\n\t}\r\n\tif (obj.length === 3) {\r\n\t\treturn [ obj[0] /*top*/, obj[1] /*right*/, obj[2] /*bottom*/, obj[1] ]\r\n\t}\r\n\tif (obj.length === 2) {\r\n\t\treturn [ obj[0] /*top*/, obj[1] /*right*/, obj[0] /*bottom*/, obj[1] ]\r\n\t}\r\n\tif (obj.length === 1) {\r\n\t\treturn [ obj[0] /*top*/, obj[0] /*right*/, obj[0] /*bottom*/, obj[0] ]\r\n\t}\r\n\treturn obj as [ T, T, T, T ]\r\n}\r\n\r\nexport {\r\n\tisDef,\r\n\tisDefString,\r\n\tisNode,\r\n\tisDescendantElement,\r\n\tgetChainSafe,\r\n\tapplyChainSafe,\r\n\tgetOrApply,\r\n\tgetIgnoreCase,\r\n\tthen,\r\n\tarray\r\n}\r\n\r\nexport function cellEquals(a: CellAddress, b: CellAddress): boolean {\r\n\treturn a.col === b.col && a.row === b.row\r\n}\r\n\r\nexport function cellInRange(range: CellRange, col: number, row: number): boolean {\r\n\treturn range.start.col <= col && col <= range.end.col && range.start.row <= row && row <= range.end.row\r\n}\r\n\r\nexport const browser = {\r\n\tIE,\r\n\tEdge,\r\n\tChrome,\r\n\tFirefox,\r\n\tSafari,\r\n\t// Chrome 33554431\r\n\t// FireFox 17895588\r\n\t// IE 10737433\r\n\theightLimit: Chrome ? 33554431 : Firefox ? 17895588 : 10737433 // default IE limit\r\n}\r\n\r\nexport const obj = {\r\n\tsetReadonly,\r\n\tisObject\r\n}\r\nexport const str = {\r\n\tendsWith,\r\n\tgenChars,\r\n\tgenWords\r\n}\r\nexport const event = {\r\n\tgetMouseButtons,\r\n\tgetKeyCode,\r\n\tisTouchEvent,\r\n\tcancel\r\n}\r\nexport const style = {\r\n\ttoBoxArray\r\n}\r\nexport const emptyFn = Function.prototype\r\n","import {DG_EVENT_TYPE} from '../core/DG_EVENT_TYPE';\r\nimport type {DrawGridEvents} from '../core/DG_EVENT_TYPE';\r\nimport {extend} from '../internal/utils';\r\n\r\nexport interface ListGridEvents extends DrawGridEvents {\r\n  /**\r\n   * Indicates when the cell value was changed.\r\n   */\r\n  CHANGED_VALUE: 'changed_value';\r\n  /**\r\n   * Indicates when the header cell value was changed.\r\n   */\r\n  CHANGED_HEADER_VALUE: 'changed_header_value';\r\n}\r\n\r\nexport const LG_EVENT_TYPE: ListGridEvents = extend(DG_EVENT_TYPE, {\r\n\tCHANGED_VALUE: 'changed_value' as const,\r\n\tCHANGED_HEADER_VALUE: 'changed_header_value' as const\r\n});\r\n","import type * as headerAction from '../../header/action';\r\nimport type * as headerType from '../../header/type';\r\nimport type {\r\n\tCellRange,\r\n\tColumnActionOption,\r\n\tColumnIconOption,\r\n\tColumnStyleOption,\r\n\tColumnTypeOption,\r\n\tFieldDef,\r\n\tHeaderActionOption,\r\n\tHeaderStyleOption,\r\n\tHeaderTypeOption,\r\n\tLayoutObjectId,\r\n\tListGridAPI,\r\n\tMessage\r\n} from '../../ts-types';\r\nimport type {BaseAction} from '../../columns/action';\r\nimport type {BaseColumn} from '../../columns/type/BaseColumn';\r\nimport type {BaseStyle as HeaderBaseStyle} from '../../header/style';\r\n\r\nexport type OldSortOption<T> = boolean | ((order: 'asc' | 'desc', col: number, grid: ListGridAPI<T>) => void);\r\n\r\nexport interface BaseHeaderDefine<T> {\r\n  caption?: string | (() => string);\r\n  headerField?: string;\r\n  headerStyle?: HeaderStyleOption | HeaderBaseStyle | null;\r\n  headerType?: HeaderTypeOption | headerType.BaseHeader<T> | null;\r\n  headerAction?: HeaderActionOption | headerAction.BaseAction<T> | null;\r\n  sort?: OldSortOption<T>;\r\n}\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\r\nexport interface HeaderDefine<T> extends BaseHeaderDefine<T> {}\r\nexport interface ColumnDefine<T> extends BaseHeaderDefine<T> {\r\n  field?: FieldDef<T>;\r\n  width?: number | string;\r\n  minWidth?: number | string;\r\n  maxWidth?: number | string;\r\n  icon?: ColumnIconOption<T> | ColumnIconOption<T>[];\r\n  message?: Message | ((record: T) => Message) | keyof T | (Message | ((record: T) => Message) | keyof T)[];\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  columnType?: ColumnTypeOption | BaseColumn<T, any> | null;\r\n  action?: ColumnActionOption | BaseAction<T> | null;\r\n  style?: ColumnStyleOption | null;\r\n}\r\n\r\nexport interface HeaderData<T> {\r\n  id: LayoutObjectId;\r\n  caption?: string | (() => string);\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  field?: any;\r\n  style?: HeaderStyleOption | HeaderBaseStyle | null;\r\n  headerType: headerType.BaseHeader<T>;\r\n  action?: headerAction.BaseAction<T>;\r\n  define: HeaderDefine<T>;\r\n}\r\n\r\nexport interface WidthData {\r\n  width?: number | string;\r\n  minWidth?: number | string;\r\n  maxWidth?: number | string;\r\n}\r\nexport interface ColumnData<T> extends WidthData {\r\n  id: LayoutObjectId;\r\n  field?: FieldDef<T>;\r\n  icon?: ColumnIconOption<T> | ColumnIconOption<T>[];\r\n  message?: Message | ((record: T) => Message) | keyof T | (Message | ((record: T) => Message) | keyof T)[];\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  columnType: BaseColumn<T, any>;\r\n  action?: BaseAction<T>;\r\n  style: ColumnStyleOption | null | undefined;\r\n  define: ColumnDefine<T>;\r\n}\r\n\r\n// Simple header\r\n\r\nexport interface GroupHeaderDefine<T> extends HeaderDefine<T> {\r\n  columns: HeadersDefine<T>;\r\n}\r\nexport type HeadersDefine<T> = (GroupHeaderDefine<T> | ColumnDefine<T>)[];\r\n\r\n// Advanced layout\r\n\r\nexport interface HeaderCellDefine<T> extends HeaderDefine<T> {\r\n  colSpan?: number;\r\n  rowSpan?: number;\r\n}\r\n\r\nexport interface CellDefine<T> extends ColumnDefine<T> {\r\n  colSpan?: number;\r\n  rowSpan?: number;\r\n}\r\n\r\nexport type HeaderBodyLayoutDefine<T> = {\r\n  header: HeaderCellDefine<T>[][];\r\n  body: CellDefine<T>[][];\r\n};\r\n\r\nexport type ArrayLayoutDefine<T> = CellDefine<T>[][];\r\nexport type LayoutDefine<T> = HeaderBodyLayoutDefine<T> | ArrayLayoutDefine<T>;\r\n\r\n/** @internal */\r\ninterface LayoutMapAPI<T> {\r\n  readonly headerRowCount: number;\r\n  readonly bodyRowCount: number;\r\n  readonly colCount: number;\r\n\r\n  readonly columnWidths: WidthData[];\r\n  readonly headerObjects: HeaderData<T>[];\r\n  readonly columnObjects: ColumnData<T>[];\r\n\r\n  getHeader(col: number, row: number): HeaderData<T>;\r\n  getBody(col: number, row: number): ColumnData<T>;\r\n  getCellId(col: number, row: number): LayoutObjectId;\r\n  getCellRange(col: number, row: number): CellRange;\r\n  getBodyLayoutRangeById(id: LayoutObjectId): CellRange;\r\n  getRecordIndexByRow(row: number): number;\r\n  getRecordStartRowByRecordIndex(index: number): number;\r\n}\r\n\r\nexport type {LayoutMapAPI};\r\n","//\n// export {\n//     LayoutMapAPI,\n//     HeaderDefine,\n//     ColumnDefine,\n//     HeadersDefine,\n//     GroupHeaderDefine,\n//     LayoutDefine\n// } from './api'\n// export { SimpleHeaderLayoutMap } from './internal/simple-header-layout'\n// export { MultiLayoutMap } from './internal/multi-layout'\n//\n\nexport * from './api';\nexport * from './internal/simple-header-layout';\nexport * from './internal/multi-layout';\n","import {columns} from '../../../columns';\r\nimport * as headerAction from '../../../header/action';\r\nimport * as headerType from '../../../header/type';\r\nimport type {CellDefine, ColumnData, HeaderBodyLayoutDefine, HeaderCellDefine, HeaderData, LayoutDefine, LayoutMapAPI, WidthData} from '../api';\r\nimport type {CellRange, LayoutObjectId} from '../../../ts-types';\r\nimport {EmptyDataCache} from './utils';\r\n\r\ninterface HasSpans {\r\n  colSpan?: number;\r\n  rowSpan?: number;\r\n  width?: number | string;\r\n  minWidth?: number | string;\r\n  maxWidth?: number | string;\r\n}\r\n\r\nfunction normalizeLayout<T>(layout: LayoutDefine<T>): HeaderBodyLayoutDefine<T> {\r\n\tif (Array.isArray(layout)) {\r\n\t\treturn {\r\n\t\t\theader: layout,\r\n\t\t\tbody: layout\r\n\t\t};\r\n\t}\r\n\treturn layout;\r\n}\r\n\r\nlet seqId = 0;\r\n\r\nclass LayoutObjectGrid<T, D extends HasSpans> {\r\n  objects: T[] = [];\r\n\r\n  objectGrid: T[][] = [];\r\n\r\n  objectMap: { [key in LayoutObjectId]: T } = {};\r\n\r\n  columnCount = 0;\r\n\r\n  columnWidths: WidthData[] = [];\r\n\r\n  constructor(layout: D[][], transform: (d: D, id: LayoutObjectId) => T) {\r\n  \tlayout.forEach((rowLayout, row) => {\r\n  \t\tlet col = 0;\r\n  \t\trowLayout.forEach((cell) => {\r\n  \t\t\tconst id = seqId++;\r\n  \t\t\tconst obj = transform(cell, id);\r\n  \t\t\tthis.objects.push(obj);\r\n  \t\t\tthis.objectMap[id] = obj;\r\n  \t\t\tcol = this._findStartCell(col, row);\r\n  \t\t\tconst rowSpan = Number(cell.rowSpan ?? 1);\r\n  \t\t\tconst colSpan = Number(cell.colSpan ?? 1);\r\n  \t\t\tconst endRow = row + rowSpan;\r\n  \t\t\tconst endCol = col + colSpan;\r\n  \t\t\tfor (let rowIndex = row; rowIndex < endRow; rowIndex++) {\r\n  \t\t\t\tconst objectGridRow = this._getObjectGridRow(rowIndex);\r\n  \t\t\t\tfor (let colIndex = col; colIndex < endCol; colIndex++) {\r\n  \t\t\t\t\tobjectGridRow[colIndex] = obj;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\tif (colSpan === 1) {\r\n  \t\t\t\tthis._setWidthDataIfAbsent(col, cell);\r\n  \t\t\t}\r\n  \t\t\tthis._useColumnIndex(endCol - 1);\r\n  \t\t\tcol = endCol;\r\n  \t\t});\r\n  \t});\r\n  }\r\n\r\n  get rowCount(): number {\r\n  \treturn this.objectGrid.length;\r\n  }\r\n\r\n  private _findStartCell(col: number, row: number): number {\r\n  \tconst objectGridRow = this._getObjectGridRow(row);\r\n  \tfor (let index = col; index < objectGridRow.length; index++) {\r\n  \t\tif (!objectGridRow[index]) {\r\n  \t\t\treturn index;\r\n  \t\t}\r\n  \t}\r\n  \treturn objectGridRow.length;\r\n  }\r\n\r\n  private _getObjectGridRow(row: number): T[] {\r\n  \treturn this.objectGrid[row] || (this.objectGrid[row] = []);\r\n  }\r\n\r\n  private _useColumnIndex(col: number): void {\r\n  \tif (this.columnCount > col) {\r\n  \t\treturn;\r\n  \t}\r\n  \tthis.columnCount = col + 1;\r\n  }\r\n\r\n  private _setWidthDataIfAbsent(col: number, cell: HasSpans): void {\r\n  \tif (!this.columnWidths[col]) {\r\n  \t\tif (cell.width != null || cell.maxWidth != null || cell.minWidth != null) {\r\n  \t\t\tthis.columnWidths[col] = {\r\n  \t\t\t\twidth: cell.width,\r\n  \t\t\t\tmaxWidth: cell.maxWidth,\r\n  \t\t\t\tminWidth: cell.minWidth\r\n  \t\t\t};\r\n  \t\t}\r\n  \t}\r\n  }\r\n}\r\n\r\nexport class MultiLayoutMap<T> implements LayoutMapAPI<T> {\r\n  private _header: LayoutObjectGrid<HeaderData<T>, HeaderCellDefine<T>>;\r\n\r\n  private _body: LayoutObjectGrid<ColumnData<T>, CellDefine<T>>;\r\n\r\n  private _columnWidths: WidthData[] = [];\r\n\r\n  private _columnCount: number;\r\n\r\n  private _emptyDataCache = new EmptyDataCache();\r\n\r\n  constructor(layout: LayoutDefine<T>) {\r\n  \tconst hbLayouut = normalizeLayout(layout);\r\n  \tconst header = (this._header = new LayoutObjectGrid(hbLayouut.header, (hd: HeaderCellDefine<T>, id: LayoutObjectId): HeaderData<T> => ({\r\n  \t\tid,\r\n  \t\tcaption: hd.caption,\r\n  \t\tfield: hd.headerField || (hd as CellDefine<T>).field,\r\n  \t\tstyle: hd.headerStyle,\r\n  \t\theaderType: headerType.ofCell(hd),\r\n  \t\taction: headerAction.ofCell(hd),\r\n  \t\tdefine: hd\r\n  \t})));\r\n  \tconst body = (this._body = new LayoutObjectGrid(hbLayouut.body, (colDef: CellDefine<T>, id: LayoutObjectId): ColumnData<T> => ({\r\n  \t\tid,\r\n  \t\tfield: colDef.field,\r\n  \t\twidth: colDef.width,\r\n  \t\tminWidth: colDef.minWidth,\r\n  \t\tmaxWidth: colDef.maxWidth,\r\n  \t\ticon: colDef.icon,\r\n  \t\tmessage: colDef.message,\r\n  \t\tcolumnType: columns.type.of(colDef.columnType),\r\n  \t\taction: columns.action.of(colDef.action),\r\n  \t\tstyle: colDef.style,\r\n  \t\tdefine: colDef\r\n  \t})));\r\n  \tconst columnCount = (this._columnCount = Math.max(header.columnCount, body.columnCount));\r\n  \tfor (let col = 0; col < columnCount; col++) {\r\n  \t\tconst widthDef = header.columnWidths[col] || body.columnWidths[col] || {};\r\n  \t\tthis._columnWidths[col] = widthDef;\r\n  \t}\r\n  }\r\n\r\n  get columnWidths(): WidthData[] {\r\n  \treturn this._columnWidths;\r\n  }\r\n\r\n  get headerRowCount(): number {\r\n  \treturn this._header.rowCount;\r\n  }\r\n\r\n  get bodyRowCount(): number {\r\n  \treturn this._body.rowCount;\r\n  }\r\n\r\n  get colCount(): number {\r\n  \treturn this._columnCount;\r\n  }\r\n\r\n  get headerObjects(): HeaderData<T>[] {\r\n  \treturn this._header.objects;\r\n  }\r\n\r\n  get columnObjects(): ColumnData<T>[] {\r\n  \treturn this._body.objects;\r\n  }\r\n\r\n  getCellId(col: number, row: number): LayoutObjectId {\r\n  \tif (this.headerRowCount <= row) {\r\n  \t\tconst bodyRow = row - this.headerRowCount;\r\n  \t\tconst bodyLayoutRow = bodyRow % this.bodyRowCount;\r\n  \t\treturn this._body.objectGrid[bodyLayoutRow]?.[col]?.id;\r\n  \t}\r\n  \t//in header\r\n  \treturn this._header.objectGrid[row]?.[col]?.id;\r\n  }\r\n\r\n  getHeader(col: number, row: number): HeaderData<T> {\r\n  \tconst id = this.getCellId(col, row);\r\n  \treturn this._header.objectMap[id as number] || this._emptyDataCache.getHeader(col, row);\r\n  }\r\n\r\n  getBody(col: number, row: number): ColumnData<T> {\r\n  \tconst id = this.getCellId(col, row);\r\n  \treturn this._body.objectMap[id as number] || this._emptyDataCache.getBody(col, row);\r\n  }\r\n\r\n  getBodyLayoutRangeById(id: LayoutObjectId): CellRange {\r\n  \tfor (let row = 0; row < this.bodyRowCount; row++) {\r\n  \t\tconst objectGridRow = this._body.objectGrid[row];\r\n  \t\tif (!objectGridRow) {\r\n  \t\t\tcontinue;\r\n  \t\t}\r\n  \t\tfor (let col = 0; col < this.colCount; col++) {\r\n  \t\t\tif (id === objectGridRow[col]?.id) {\r\n  \t\t\t\treturn this._getCellRange(this._body, col, row, 0);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n  \tthrow new Error(`can not found body layout @id=${id as number}`);\r\n  }\r\n\r\n  getCellRange(col: number, row: number): CellRange {\r\n  \tif (this.headerRowCount <= row) {\r\n  \t\tconst recordIndex = this.getRecordIndexByRow(row);\r\n  \t\tconst startRow = this.getRecordStartRowByRecordIndex(recordIndex);\r\n  \t\tconst bodyRow = row - this.headerRowCount;\r\n  \t\tconst bodyLayoutRow = bodyRow % this.bodyRowCount;\r\n  \t\treturn this._getCellRange(this._body, col, bodyLayoutRow, startRow);\r\n  \t}\r\n  \t//in header\r\n  \treturn this._getCellRange(this._header, col, row, 0);\r\n  }\r\n\r\n  getRecordIndexByRow(row: number): number {\r\n  \tif (row < this.headerRowCount) {\r\n  \t\treturn -1;\r\n  \t} else {\r\n  \t\tconst bodyRow = row - this.headerRowCount;\r\n  \t\treturn Math.floor(bodyRow / this.bodyRowCount);\r\n  \t}\r\n  }\r\n\r\n  getRecordStartRowByRecordIndex(index: number): number {\r\n  \treturn this.headerRowCount + index * this.bodyRowCount;\r\n  }\r\n\r\n  private _getCellRange(\r\n  \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  \t\tlayout: LayoutObjectGrid<HeaderData<T> | ColumnData<T>, any>,\r\n  \t\tcol: number,\r\n  \t\tlayoutRow: number,\r\n  \t\toffsetRow: number\r\n  ): CellRange {\r\n  \tconst result: CellRange = {\r\n  \t\tstart: {col, row: layoutRow + offsetRow},\r\n  \t\tend: {col, row: layoutRow + offsetRow}\r\n  \t};\r\n  \tconst {objectGrid} = layout;\r\n  \tconst id = objectGrid[layoutRow]?.[col]?.id;\r\n  \tif (id == null) {\r\n  \t\treturn result;\r\n  \t}\r\n  \tfor (let c = col - 1; c >= 0; c--) {\r\n  \t\tif (id !== objectGrid[layoutRow]?.[c]?.id) {\r\n  \t\t\tbreak;\r\n  \t\t}\r\n  \t\tresult.start.col = c;\r\n  \t}\r\n  \tfor (let c = col + 1; c < layout.columnCount; c++) {\r\n  \t\tif (id !== objectGrid[layoutRow]?.[c]?.id) {\r\n  \t\t\tbreak;\r\n  \t\t}\r\n  \t\tresult.end.col = c;\r\n  \t}\r\n  \tfor (let r = layoutRow - 1; r >= 0; r--) {\r\n  \t\tif (id !== objectGrid[r]?.[col]?.id) {\r\n  \t\t\tbreak;\r\n  \t\t}\r\n  \t\tresult.start.row = r + offsetRow;\r\n  \t}\r\n  \tfor (let r = layoutRow + 1; r < layout.rowCount; r++) {\r\n  \t\tif (id !== objectGrid[r]?.[col]?.id) {\r\n  \t\t\tbreak;\r\n  \t\t}\r\n  \t\tresult.end.row = r + offsetRow;\r\n  \t}\r\n  \treturn result;\r\n  }\r\n}\r\n","import { columns } from '../../../columns'\r\nimport * as headerAction from '../../../header/action'\r\nimport * as headerType from '../../../header/type'\r\nimport type { CellRange, LayoutObjectId } from '../../../ts-types'\r\nimport type {\r\n\tColumnData,\r\n\tColumnDefine,\r\n\tGroupHeaderDefine,\r\n\tHeaderData,\r\n\tHeadersDefine,\r\n\tLayoutMapAPI\r\n} from '../api'\r\nimport { EmptyDataCache } from './utils'\r\n\r\nlet seqId = 0\r\n\r\nexport class SimpleHeaderLayoutMap<T> implements LayoutMapAPI<T> {\r\n    private _headerObjects: HeaderData<T>[]\r\n\r\n    private _headerObjectMap: { [key in LayoutObjectId]: HeaderData<T> }\r\n\r\n    private _headerCellIds: number[][]\r\n\r\n    private _columns: ColumnData<T>[]\r\n\r\n    readonly bodyRowCount: number = 1\r\n\r\n    private _emptyDataCache = new EmptyDataCache()\r\n\r\n    constructor(header: HeadersDefine<T>) {\r\n    \tthis._columns = []\r\n    \tthis._headerCellIds = []\r\n\r\n    \tthis._headerObjects = this._addHeaders(0, header, [])\r\n    \tthis._headerObjectMap = this._headerObjects.reduce((o, e) => {\r\n    \t\to[e.id as number] = e\r\n    \t\treturn o\r\n    \t}, {} as { [key in LayoutObjectId]: HeaderData<T> })\r\n    }\r\n\r\n    get columnWidths(): ColumnData<T>[] {\r\n    \treturn this._columns\r\n    }\r\n\r\n    get headerRowCount(): number {\r\n    \treturn this._headerCellIds.length\r\n    }\r\n\r\n    get colCount(): number {\r\n    \treturn this._columns.length\r\n    }\r\n\r\n    get headerObjects(): HeaderData<T>[] {\r\n    \treturn this._headerObjects\r\n    }\r\n\r\n    get columnObjects(): ColumnData<T>[] {\r\n    \treturn this._columns\r\n    }\r\n\r\n    getCellId(col: number, row: number): LayoutObjectId {\r\n    \tif (this.headerRowCount <= row) {\r\n    \t\treturn this._columns[col].id\r\n    \t}\r\n    \t//in header\r\n    \treturn this._headerCellIds[row][col]\r\n    }\r\n\r\n    getHeader(col: number, row: number): HeaderData<T> | any {\r\n    \tconst id = this.getCellId(col, row)\r\n    \treturn (\r\n    \t\tthis._headerObjectMap[id as number] ||\r\n            this._emptyDataCache.getHeader(col, row)\r\n    \t)\r\n    }\r\n\r\n    getBody(col: number, _row: number): ColumnData<T> | any {\r\n    \treturn this._columns[col] || this._emptyDataCache.getBody(col, 0)\r\n    }\r\n\r\n    getBodyLayoutRangeById(id: LayoutObjectId): CellRange {\r\n    \tfor (let col = 0; col < this.colCount; col++) {\r\n    \t\tif (id === this._columns[col].id) {\r\n    \t\t\treturn {\r\n    \t\t\t\tstart: { col, row: 0 },\r\n    \t\t\t\tend: { col, row: 0 }\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \tthrow new Error(`can not found body layout @id=${ id as number }`)\r\n    }\r\n\r\n    getCellRange(col: number, row: number): CellRange {\r\n    \tconst result: CellRange = { start: { col, row }, end: { col, row } }\r\n    \tif (this.headerRowCount <= row) {\r\n    \t\treturn result\r\n    \t}\r\n    \t//in header\r\n    \tconst id = this.getCellId(col, row)\r\n    \tfor (let c = col - 1; c >= 0; c--) {\r\n    \t\tif (id !== this.getCellId(c, row)) {\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t\tresult.start.col = c\r\n    \t}\r\n    \tfor (let c = col + 1; c < this.colCount; c++) {\r\n    \t\tif (id !== this.getCellId(c, row)) {\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t\tresult.end.col = c\r\n    \t}\r\n    \tfor (let r = row - 1; r >= 0; r--) {\r\n    \t\tif (id !== this.getCellId(col, r)) {\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t\tresult.start.row = r\r\n    \t}\r\n    \tfor (let r = row + 1; r < this.headerRowCount; r++) {\r\n    \t\tif (id !== this.getCellId(col, r)) {\r\n    \t\t\tbreak\r\n    \t\t}\r\n    \t\tresult.end.row = r\r\n    \t}\r\n    \treturn result\r\n    }\r\n\r\n    getRecordIndexByRow(row: number): number {\r\n    \tif (row < this.headerRowCount) {\r\n    \t\treturn -1\r\n    \t} else {\r\n    \t\treturn row - this.headerRowCount\r\n    \t}\r\n    }\r\n\r\n    getRecordStartRowByRecordIndex(index: number): number {\r\n    \treturn this.headerRowCount + index\r\n    }\r\n\r\n    private _addHeaders(\r\n    \t\trow: number,\r\n    \t\theader: HeadersDefine<T>,\r\n    \t\troots: number[]\r\n    ): HeaderData<T>[] {\r\n    \tconst results: HeaderData<T>[] = []\r\n    \tconst rowCells = this._headerCellIds[row] || this._newRow(row)\r\n    \theader.forEach((hd) => {\r\n    \t\tconst col = this._columns.length\r\n    \t\tconst id = seqId++\r\n    \t\tconst cell: HeaderData<T> = {\r\n    \t\t\tid,\r\n    \t\t\tcaption: hd.caption,\r\n    \t\t\tfield: hd.headerField || (hd as ColumnDefine<T>).field,\r\n    \t\t\tstyle: hd.headerStyle,\r\n    \t\t\theaderType: headerType.ofCell(hd),\r\n    \t\t\taction: headerAction.ofCell(hd),\r\n    \t\t\tdefine: hd\r\n    \t\t}\r\n    \t\tresults[id] = cell\r\n    \t\trowCells[col] = id\r\n    \t\tfor (let r = row - 1; r >= 0; r--) {\r\n    \t\t\tthis._headerCellIds[r][col] = roots[r]\r\n    \t\t}\r\n    \t\tif ((hd as GroupHeaderDefine<T>).columns) {\r\n    \t\t\tthis._addHeaders(row + 1, (hd as GroupHeaderDefine<T>).columns, [\r\n    \t\t\t\t...roots,\r\n    \t\t\t\tid\r\n    \t\t\t]).forEach((c) => results.push(c))\r\n    \t\t} else {\r\n    \t\t\tconst colDef = hd as ColumnDefine<T>\r\n    \t\t\tthis._columns.push({\r\n    \t\t\t\tid: seqId++,\r\n    \t\t\t\tfield: colDef.field,\r\n    \t\t\t\twidth: colDef.width,\r\n    \t\t\t\tminWidth: colDef.minWidth,\r\n    \t\t\t\tmaxWidth: colDef.maxWidth,\r\n    \t\t\t\ticon: colDef.icon,\r\n    \t\t\t\tmessage: colDef.message,\r\n    \t\t\t\tcolumnType: columns.type.of(colDef.columnType),\r\n    \t\t\t\taction: columns.action.of(colDef.action),\r\n    \t\t\t\tstyle: colDef.style,\r\n    \t\t\t\tdefine: colDef\r\n    \t\t\t})\r\n    \t\t\tfor (let r = row + 1; r < this._headerCellIds.length; r++) {\r\n    \t\t\t\tthis._headerCellIds[r][col] = id\r\n    \t\t\t}\r\n    \t\t}\r\n    \t})\r\n    \treturn results\r\n    }\r\n\r\n    private _newRow(row: number): number[] {\r\n    \tconst newRow: number[] = (this._headerCellIds[row] = [])\r\n    \tif (!this._columns.length) {\r\n    \t\treturn newRow\r\n    \t}\r\n    \tconst prev = this._headerCellIds[row - 1]\r\n    \tfor (let col = 0; col < prev.length; col++) {\r\n    \t\tnewRow[col] = prev[col]\r\n    \t}\r\n    \treturn newRow\r\n    }\r\n}\r\n","import {columns} from '../../../columns';\r\nimport * as headerType from '../../../header/type';\r\nimport type {ColumnData, HeaderData} from '../api';\r\n\r\nlet seqId = -1;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function newEmptyHeaderData(): HeaderData<any> {\r\n\treturn {\r\n\t\tid: seqId--,\r\n\t\tdefine: {},\r\n\t\theaderType: headerType.of(null) // default\r\n\t};\r\n}\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function newEmptyColumnData(): ColumnData<any> {\r\n\treturn {\r\n\t\tid: seqId--,\r\n\t\tdefine: {},\r\n\t\tcolumnType: columns.type.of(null), // default\r\n\t\tstyle: null\r\n\t};\r\n}\r\n\r\nexport class EmptyDataCache<T> {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  private headers: HeaderData<T>[][] = [];\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  private columns: ColumnData<T>[][] = [];\r\n\r\n  getHeader(col: number, row: number): HeaderData<T> {\r\n  \tconst rows = this.headers[row] || (this.headers[row] = []);\r\n  \treturn rows[col] || (rows[col] = newEmptyHeaderData());\r\n  }\r\n\r\n  getBody(col: number, row: number): ColumnData<T> {\r\n  \tconst rows = this.columns[row] || (this.columns[row] = []);\r\n  \treturn rows[col] || (rows[col] = newEmptyColumnData());\r\n  }\r\n}\r\n","import type {IconDefine} from '../ts-types';\r\n\r\nexport const icons: { [key: string]: IconDefine } = {};\r\n","import type {Theme} from '../themes/theme';\r\n\r\nexport const themes: { [key: string]: Theme } = {};\r\n","import type { IconDefine } from './ts-types'\r\nimport type { Theme } from './themes/theme'\r\nimport { icons as iconPlugins } from './plugins/icons'\r\nimport { themes as themePlugins } from './plugins/themes'\r\n\r\nfunction registerPlugin<T>(obj: { [key: string]: T }, name: string, value: T): T {\r\n\tconst old = obj[name]\r\n\tobj[name] = value\r\n\treturn old\r\n}\r\n\r\nfunction registerPlugins<T>(obj: { [key: string]: T }, values: { [key: string]: T }): void {\r\n\tfor (const k in values) {\r\n\t\tobj[k] = values[k]\r\n\t}\r\n}\r\n\r\nexport function theme(name: string, theme?: Theme): Theme {\r\n\tif (theme != null) {\r\n\t\treturn registerPlugin(themePlugins, name, theme)\r\n\t} else {\r\n\t\treturn themePlugins[name]\r\n\t}\r\n}\r\n\r\nexport function icon(name: string, icon?: IconDefine): IconDefine {\r\n\tif (icon != null) {\r\n\t\treturn registerPlugin(iconPlugins, name, icon)\r\n\t} else {\r\n\t\treturn iconPlugins[name]\r\n\t}\r\n}\r\n\r\nexport function icons(icons: { [key: string]: IconDefine }): void {\r\n\treturn registerPlugins(iconPlugins, icons)\r\n}\r\n\r\nexport const register = {\r\n\ttheme,\r\n\ticon,\r\n\ticons\r\n}\r\n","import { extend, getIgnoreCase } from './internal/utils'\r\nimport { Theme } from './themes/theme'\r\nimport type { ThemeDefine } from './ts-types'\r\nimport basicTheme from './themes/BASIC'\r\nimport materialDesignTheme from './themes/MATERIAL_DESIGN'\r\nimport { themes as plugins } from './plugins/themes'\r\n\r\nexport const BASIC = new Theme(basicTheme)\r\nexport const MATERIAL_DESIGN = new Theme(materialDesignTheme)\r\n\r\nconst builtin: { [key: string]: Theme } = {\r\n\tBASIC,\r\n\tMATERIAL_DESIGN\r\n}\r\nlet defTheme = MATERIAL_DESIGN\r\n\r\nexport const theme = { Theme }\r\n\r\nexport function of(value: ThemeDefine | string | undefined | null): Theme | null {\r\n\tif (!value) {\r\n\t\treturn null\r\n\t}\r\n\tif (typeof value === 'string') {\r\n\t\tconst t = getIgnoreCase(getChoices(), value)\r\n\t\tif (t) {\r\n\t\t\treturn t\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\tif (value instanceof Theme) {\r\n\t\treturn value\r\n\t}\r\n\treturn new Theme(value)\r\n}\r\n\r\nexport function getDefault(): Theme {\r\n\treturn defTheme\r\n}\r\n\r\nexport function setDefault(defaultTheme: Theme): void {\r\n\tdefTheme = of(defaultTheme) || defTheme\r\n}\r\n\r\nexport function getChoices(): { [key: string]: Theme } {\r\n\treturn extend(builtin, plugins)\r\n}\r\n\r\nexport const themes = {\r\n\tBASIC,\r\n\tMATERIAL_DESIGN,\r\n\ttheme,\r\n\tof,\r\n\tgetDefault,\r\n\tgetChoices\r\n}\r\n","/*eslint no-bitwise:0*/\r\n\r\nimport type {StylePropertyFunctionArg, ThemeDefine} from '../ts-types';\r\n\r\nfunction DEFAULT_BG_COLOR(args: StylePropertyFunctionArg): string {\r\n\tconst {row, grid} = args;\r\n\tif (row < grid.frozenRowCount) {\r\n\t\treturn '#FFF';\r\n\t}\r\n\tconst index = grid.getRecordIndexByRow(row);\r\n\tif (!(index & 1)) {\r\n\t\treturn '#FFF';\r\n\t} else {\r\n\t\treturn '#F6F6F6';\r\n\t}\r\n}\r\nconst cacheLinearGradient: { [key: string]: CanvasGradient } = {};\r\n\r\nfunction getLinearGradient(context: CanvasRenderingContext2D, left: number, top: number, right: number, bottom: number, colorStops: { [key: number]: string }): CanvasGradient {\r\n\tlet stop;\r\n\tconst stopsKey = [];\r\n\tfor (stop in colorStops) {\r\n\t\tstopsKey.push(`${stop}@${colorStops[stop]}`);\r\n\t}\r\n\tconst key = `${left}/${top}/${right}/${bottom}/${stopsKey.join(',')}`;\r\n\tconst ret = cacheLinearGradient[key];\r\n\tif (ret) {\r\n\t\treturn ret;\r\n\t}\r\n\tconst grad = context.createLinearGradient(left, top, left, bottom);\r\n\tfor (stop in colorStops) {\r\n\t\tgrad.addColorStop(Number(stop), colorStops[stop]);\r\n\t}\r\n\treturn (cacheLinearGradient[key] = grad);\r\n}\r\nfunction FROZEN_ROWS_BG_COLOR(args: StylePropertyFunctionArg): CanvasGradient {\r\n\tconst {\r\n\t\tcol,\r\n\t\tgrid,\r\n\t\tgrid: {frozenRowCount},\r\n\t\tcontext\r\n\t} = args;\r\n\tconst {left, top} = grid.getCellRelativeRect(col, 0);\r\n\tconst {bottom} = grid.getCellRelativeRect(col, frozenRowCount - 1);\r\n\r\n\treturn getLinearGradient(context, left, top, left, bottom, {\r\n\t\t0: '#FFF',\r\n\t\t1: '#D3D3D3'\r\n\t});\r\n}\r\n/**\r\n * basic theme\r\n * @name BASIC\r\n * @memberof cheetahGrid.themes.choices\r\n */\r\nexport default {\r\n\tcolor: '#000',\r\n\t// frozenRowsColor: '#000',\r\n\r\n\tdefaultBgColor: DEFAULT_BG_COLOR,\r\n\tfrozenRowsBgColor: FROZEN_ROWS_BG_COLOR,\r\n\tselectionBgColor: '#CCE0FF',\r\n\r\n\tborderColor: '#000',\r\n\t// frozenRowsBorderColor: '#000',\r\n\thighlightBorderColor: '#5E9ED6',\r\n\r\n\tcheckbox: {\r\n\t\tuncheckBgColor: '#FFF',\r\n\t\tcheckBgColor: 'rgb(76, 73, 72)',\r\n\t\tborderColor: '#000'\r\n\t},\r\n\tradioButton: {\r\n\t\tcheckColor: 'rgb(76, 73, 72)',\r\n\t\tcheckBorderColor: '#000',\r\n\t\tuncheckBorderColor: '#000',\r\n\t\tuncheckBgColor: '#FFF',\r\n\t\tcheckBgColor: '#FFF'\r\n\t},\r\n\tbutton: {\r\n\t\tcolor: '#FFF',\r\n\t\tbgColor: '#2196F3'\r\n\t},\r\n\theader: {\r\n\t\tsortArrowColor: 'rgba(0, 0, 0, 0.38)'\r\n\t},\r\n\tunderlayBackgroundColor: '#F6F6F6'\r\n} as ThemeDefine;\r\n","/*eslint no-bitwise:0*/\r\n\r\nimport type {StylePropertyFunctionArg, ThemeDefine} from '../ts-types';\r\n\r\nfunction FROZEN_ROWS_BORDER_COLOR(args: StylePropertyFunctionArg): string[] {\r\n\tconst {\r\n\t\trow,\r\n\t\tgrid: {frozenRowCount}\r\n\t} = args;\r\n\tif (frozenRowCount - 1 === row) {\r\n\t\treturn ['#f2f2f2', '#f2f2f2', '#ccc7c7', '#f2f2f2'];\r\n\t} else {\r\n\t\treturn ['#f2f2f2'];\r\n\t}\r\n}\r\nfunction BORDER_COLOR(args: StylePropertyFunctionArg): (string | null)[] {\r\n\tconst {col, row, grid} = args;\r\n\tconst {colCount, frozenColCount, recordRowCount} = grid;\r\n\tlet top: string | null = '#ccc7c7';\r\n\tlet bottom: string | null = '#ccc7c7';\r\n\tif (recordRowCount > 1) {\r\n\t\tconst startRow = grid.getRecordStartRowByRecordIndex(grid.getRecordIndexByRow(row));\r\n\t\tconst endRow = startRow + recordRowCount - 1;\r\n\t\tif (startRow !== row) {\r\n\t\t\ttop = null;\r\n\t\t}\r\n\t\tif (endRow !== row) {\r\n\t\t\tbottom = null;\r\n\t\t}\r\n\t}\r\n\tif (frozenColCount - 1 === col) {\r\n\t\treturn [top, '#f2f2f2', bottom, null];\r\n\t}\r\n\tif (colCount - 1 === col) {\r\n\t\treturn [top, '#f2f2f2', bottom, null];\r\n\t}\r\n\r\n\treturn [top, null, bottom, null];\r\n}\r\n/**\r\n * material design theme\r\n * @name MATERIAL_DESIGN\r\n * @memberof cheetahGrid.themes.choices\r\n */\r\nexport default {\r\n\tcolor: 'rgba(0, 0, 0, 0.87)',\r\n\tfrozenRowsColor: 'rgba(0, 0, 0, 0.54)',\r\n\r\n\tdefaultBgColor: '#FFF',\r\n\t// frozenRowsBgColor: '#FFF',\r\n\tselectionBgColor: '#CCE0FF',\r\n\r\n\tborderColor: BORDER_COLOR,\r\n\tfrozenRowsBorderColor: FROZEN_ROWS_BORDER_COLOR,\r\n\thighlightBorderColor: '#5E9ED6',\r\n\r\n\tcheckbox: {\r\n\t\t// uncheckBgColor: '#FFF',\r\n\t\tcheckBgColor: 'rgb(76, 73, 72)',\r\n\t\tborderColor: 'rgba(0, 0, 0, 0.26)'\r\n\t},\r\n\tradioButton: {\r\n\t\tcheckColor: 'rgb(76, 73, 72)',\r\n\t\tcheckBorderColor: 'rgb(76, 73, 72)',\r\n\t\tuncheckBorderColor: 'rgb(189, 189, 189)'\r\n\t\t// uncheckBgColor: \"#FFF\",\r\n\t\t// checkBgColor: \"#FFF\",\r\n\t},\r\n\tbutton: {\r\n\t\tcolor: '#FFF',\r\n\t\tbgColor: '#2196F3'\r\n\t},\r\n\theader: {\r\n\t\tsortArrowColor: 'rgba(0, 0, 0, 0.38)'\r\n\t},\r\n\tunderlayBackgroundColor: '#FFF'\r\n} as ThemeDefine;\r\n","import type {ColorPropertyDefine, ColorsPropertyDefine, PartialThemeDefine, RequiredThemeDefine, StylePropertyFunctionArg, ThemeDefine} from '../ts-types';\r\nimport {getChainSafe} from '../internal/utils';\r\nimport {get as getSymbol} from '../internal/symbolManager';\r\n//private symbol\r\nconst _ = getSymbol();\r\n\r\nfunction getProp<T extends ColorPropertyDefine | ColorsPropertyDefine>(obj: PartialThemeDefine, superObj: ThemeDefine, names: string[], defNames?: string[]): T {\r\n\treturn getChainSafe(obj, ...names) || getChainSafe(superObj, ...names) || (defNames && getChainSafe(obj, ...defNames)) || (defNames && getChainSafe(superObj, ...defNames));\r\n}\r\n\r\nexport class Theme implements RequiredThemeDefine {\r\n  private [_]: {\r\n    obj: PartialThemeDefine;\r\n    superTheme: ThemeDefine;\r\n  };\r\n\r\n  private _checkbox: RequiredThemeDefine['checkbox'] | null = null;\r\n\r\n  private _radioButton: RequiredThemeDefine['radioButton'] | null = null;\r\n\r\n  private _button: RequiredThemeDefine['button'] | null = null;\r\n\r\n  private _header: RequiredThemeDefine['header'] | null = null;\r\n\r\n  private _messages: RequiredThemeDefine['messages'] | null = null;\r\n\r\n  constructor(obj: ThemeDefine);\r\n\r\n  constructor(obj: PartialThemeDefine, superTheme: ThemeDefine);\r\n\r\n  constructor(obj: PartialThemeDefine | ThemeDefine, superTheme?: ThemeDefine) {\r\n  \tthis[_] = {\r\n  \t\tobj,\r\n  \t\tsuperTheme: superTheme as ThemeDefine\r\n  \t};\r\n  }\r\n\r\n  get font(): string {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['font']);\r\n  }\r\n\r\n  get underlayBackgroundColor(): string {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['underlayBackgroundColor']);\r\n  }\r\n\r\n  // color\r\n  get color(): ColorPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['color']);\r\n  }\r\n\r\n  get frozenRowsColor(): ColorPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['frozenRowsColor'], ['color']);\r\n  }\r\n\r\n  // background\r\n  get defaultBgColor(): ColorPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['defaultBgColor']);\r\n  }\r\n\r\n  get frozenRowsBgColor(): ColorPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['frozenRowsBgColor'], ['defaultBgColor']);\r\n  }\r\n\r\n  get selectionBgColor(): ColorPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['selectionBgColor'], ['defaultBgColor']);\r\n  }\r\n\r\n  get highlightBgColor(): ColorPropertyDefine {\r\n  \tif (this.hasProperty(['highlightBgColor'])) {\r\n  \t\tconst {obj, superTheme} = this[_];\r\n  \t\treturn getProp(obj, superTheme, ['highlightBgColor']);\r\n  \t}\r\n  \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  \treturn (args: StylePropertyFunctionArg): any => {\r\n  \t\tconst color = args.row < args.grid.frozenRowCount ? this.frozenRowsBgColor : this.defaultBgColor;\r\n  \t\tif (typeof color === 'function') {\r\n  \t\t\treturn color(args);\r\n  \t\t}\r\n  \t\treturn color;\r\n  \t};\r\n  }\r\n\r\n  // border\r\n  get borderColor(): ColorsPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['borderColor']);\r\n  }\r\n\r\n  get frozenRowsBorderColor(): ColorsPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['frozenRowsBorderColor'], ['borderColor']);\r\n  }\r\n\r\n  get highlightBorderColor(): ColorsPropertyDefine {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn getProp(obj, superTheme, ['highlightBorderColor'], ['borderColor']);\r\n  }\r\n\r\n  get checkbox(): RequiredThemeDefine['checkbox'] {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn (\r\n  \t\tthis._checkbox ||\r\n      (this._checkbox = {\r\n      \tget uncheckBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['checkbox', 'uncheckBgColor'], ['defaultBgColor']);\r\n      \t},\r\n      \tget checkBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['checkbox', 'checkBgColor'], ['borderColor']);\r\n      \t},\r\n      \tget borderColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['checkbox', 'borderColor'], ['borderColor']);\r\n      \t}\r\n      })\r\n  \t);\r\n  }\r\n\r\n  get radioButton(): RequiredThemeDefine['radioButton'] {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn (\r\n  \t\tthis._radioButton ||\r\n      (this._radioButton = {\r\n      \tget checkColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['radioButton', 'checkColor'], ['color']);\r\n      \t},\r\n      \tget uncheckBorderColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['radioButton', 'uncheckBorderColor'], ['borderColor']);\r\n      \t},\r\n      \tget checkBorderColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['radioButton', 'checkBorderColor'], ['borderColor']);\r\n      \t},\r\n      \tget uncheckBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['radioButton', 'uncheckBgColor'], ['defaultBgColor']);\r\n      \t},\r\n      \tget checkBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['radioButton', 'checkBgColor'], ['defaultBgColor']);\r\n      \t}\r\n      })\r\n  \t);\r\n  }\r\n\r\n  get button(): RequiredThemeDefine['button'] {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn (\r\n  \t\tthis._button ||\r\n      (this._button = {\r\n      \tget color(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['button', 'color'], ['color']);\r\n      \t},\r\n      \tget bgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['button', 'bgColor'], ['defaultBgColor']);\r\n      \t}\r\n      })\r\n  \t);\r\n  }\r\n\r\n  get header(): RequiredThemeDefine['header'] {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn (\r\n  \t\tthis._header ||\r\n      (this._header = {\r\n      \tget sortArrowColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['header', 'sortArrowColor'], ['color']);\r\n      \t}\r\n      })\r\n  \t);\r\n  }\r\n\r\n  get messages(): RequiredThemeDefine['messages'] {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn (\r\n  \t\tthis._messages ||\r\n      (this._messages = {\r\n      \tget infoBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['messages', 'infoBgColor']);\r\n      \t},\r\n      \tget errorBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['messages', 'errorBgColor']);\r\n      \t},\r\n      \tget warnBgColor(): ColorPropertyDefine {\r\n      \t\treturn getProp(obj, superTheme, ['messages', 'warnBgColor']);\r\n      \t}\r\n      })\r\n  \t);\r\n  }\r\n\r\n  hasProperty(names: string[]): boolean {\r\n  \tconst {obj, superTheme} = this[_];\r\n  \treturn hasThemeProperty(obj, names) || hasThemeProperty(superTheme, names);\r\n  }\r\n\r\n  extends(obj: PartialThemeDefine): Theme {\r\n  \treturn new Theme(obj, this);\r\n  }\r\n}\r\n\r\nfunction hasThemeProperty(obj: PartialThemeDefine, names: string[]): boolean {\r\n\tif (obj instanceof Theme) {\r\n\t\treturn obj.hasProperty(names);\r\n\t} else {\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tlet o: any = obj;\r\n\t\tif (!o) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (let index = 0; index < names.length; index++) {\r\n\t\t\tconst name = names[index];\r\n\t\t\to = o[name];\r\n\t\t\tif (!o) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn !!o;\r\n\t}\r\n}\r\n","import { CanvasHelper, canvasHelper } from './tools/canvashelper'\r\n\r\n/**\r\n * tools\r\n // * @namespace cheetahGrid.tools\r\n // * @memberof cheetahGrid\r\n */\r\n// export { canvashelper };\r\n/**\r\n * tools\r\n */\r\nexport const tools: { canvasHelper: CanvasHelper } = { canvasHelper }\r\n","const parser = new DOMParser()\r\nconst ELEMENT_NODE = 1\r\n\r\nfunction findElement(el: Element, test: (child: Element) => boolean): Element | null {\r\n\tfor (let i = 0; i < el.childNodes.length; i++) {\r\n\t\tconst child = el.childNodes[i]\r\n\t\tif (child.nodeType !== ELEMENT_NODE) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif (test(child as Element)) {\r\n\t\t\treturn child as Element\r\n\t\t}\r\n\t\tconst r = findElement(child as Element, test)\r\n\t\tif (r) {\r\n\t\t\treturn r\r\n\t\t}\r\n\t}\r\n\treturn null\r\n}\r\n\r\nclass Svg {\r\n    private _svg: HTMLElement\r\n\r\n    private _glyphs: { [key: string]: Element }\r\n\r\n    private _glyphUnis: { [key: string]: Element }\r\n\r\n    private _fontFace: Element | null | undefined\r\n\r\n    private _font: Element | null | undefined\r\n\r\n    public constructor(svgCode: string) {\r\n    \tconst document = parser.parseFromString(svgCode, 'image/svg+xml')\r\n    \tthis._svg = document.documentElement as HTMLElement\r\n    \tthis._glyphs = {}\r\n    \tthis._glyphUnis = {}\r\n    }\r\n\r\n    public get svg() {\r\n    \treturn this._svg\r\n    }\r\n\r\n    public get fontFaceElement() {\r\n    \tif (!this._fontFace) {\r\n    \t\tthis._fontFace = this.findElement((child) => child.tagName.toLowerCase() === 'font-face')\r\n    \t}\r\n    \treturn this._fontFace\r\n    }\r\n\r\n    public get fontElement() {\r\n    \tif (!this._font) {\r\n    \t\tthis._font = this.findElement((child) => child.tagName.toLowerCase() === 'font')\r\n    \t}\r\n    \treturn this._font\r\n    }\r\n\r\n    public findElement(test: (child: Element) => boolean): Element {\r\n    \treturn findElement(this.svg, test) as Element\r\n    }\r\n\r\n    public findGlyph(glyphName: string) {\r\n    \treturn this._glyphs[glyphName] || (this._glyphs[glyphName] = this.findElement((child) => child.getAttribute('glyph-name') === glyphName))\r\n    }\r\n\r\n    public findGlyphByUnicode(unicode: string) {\r\n    \treturn this._glyphUnis[unicode] || (this._glyphUnis[unicode] = this.findElement((child) => child.getAttribute('unicode') === unicode))\r\n    }\r\n\r\n    public walkAllGlyph(callback: (child: Element) => void) {\r\n    \tconst walkGlyph = (el: Element, fn: (child: Element) => void) => {\r\n    \t\tfor (let i = 0; i < el.childNodes.length; i++) {\r\n    \t\t\tconst child = el.childNodes[i] as Element\r\n    \t\t\tif (child.nodeType !== ELEMENT_NODE) {\r\n    \t\t\t\tcontinue\r\n    \t\t\t}\r\n    \t\t\tconst unicode = child.getAttribute('unicode')\r\n    \t\t\tif (unicode && child.getAttribute('d')) {\r\n    \t\t\t\tif (!this._glyphUnis[unicode]) {\r\n    \t\t\t\t\tthis._glyphUnis[unicode] = child\r\n    \t\t\t\t}\r\n    \t\t\t\tconst glyphName = child.getAttribute('glyph-name')\r\n    \t\t\t\tif (glyphName && !this._glyphs[glyphName]) {\r\n    \t\t\t\t\tthis._glyphs[glyphName] = child\r\n    \t\t\t\t}\r\n    \t\t\t\tfn(child)\r\n    \t\t\t} else {\r\n    \t\t\t\twalkGlyph(child, fn)\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \twalkGlyph(this.svg, callback)\r\n    }\r\n}\r\n\r\nexport default Svg\r\n","import {calcBasePosition, calcStartPosition, getFontSize} from '../internal/canvases';\r\nimport type {ColorDef} from '../ts-types';\r\nimport type {PaddingOption} from '../internal/canvases';\r\nconst {ceil, PI} = Math;\r\n\r\nexport function strokeColorsRect(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tborderColors: [ColorDef | null, ColorDef | null, ColorDef | null, ColorDef | null],\r\n\t\tleft: number,\r\n\t\ttop: number,\r\n\t\twidth: number,\r\n\t\theight: number\r\n): void {\r\n  type Position = { x: number; y: number };\r\n  function strokeRectLines(positions: [Position, Position, Position, Position, Position]): void {\r\n  \tfor (let i = 0; i < borderColors.length; i++) {\r\n  \t\tconst color = borderColors[i];\r\n  \t\tconst preColor = borderColors[i - 1];\r\n  \t\tif (color) {\r\n  \t\t\tif (preColor !== color) {\r\n  \t\t\t\tif (preColor) {\r\n  \t\t\t\t\tctx.strokeStyle = preColor;\r\n  \t\t\t\t\tctx.stroke();\r\n  \t\t\t\t}\r\n  \t\t\t\tconst pos1 = positions[i];\r\n  \t\t\t\tctx.beginPath();\r\n  \t\t\t\tctx.moveTo(pos1.x, pos1.y);\r\n  \t\t\t}\r\n  \t\t\tconst pos2 = positions[i + 1];\r\n  \t\t\tctx.lineTo(pos2.x, pos2.y);\r\n  \t\t} else {\r\n  \t\t\tif (preColor) {\r\n  \t\t\t\tctx.strokeStyle = preColor;\r\n  \t\t\t\tctx.stroke();\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n  \tconst preColor = borderColors[borderColors.length - 1];\r\n  \tif (preColor) {\r\n  \t\tctx.strokeStyle = preColor;\r\n  \t\tctx.stroke();\r\n  \t}\r\n  }\r\n  if (borderColors[0] === borderColors[1] && borderColors[0] === borderColors[2] && borderColors[0] === borderColors[3]) {\r\n  \tif (borderColors[0]) {\r\n  \t\tctx.strokeStyle = borderColors[0];\r\n  \t\tctx.strokeRect(left, top, width, height);\r\n  \t}\r\n  } else {\r\n  \tstrokeRectLines([\r\n  \t\t{x: left, y: top},\r\n  \t\t{x: left + width, y: top},\r\n  \t\t{x: left + width, y: top + height},\r\n  \t\t{x: left, y: top + height},\r\n  \t\t{x: left, y: top}\r\n  \t]);\r\n  }\r\n}\r\nexport function roundRect(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void {\r\n\tctx.beginPath();\r\n\tctx.arc(left + radius, top + radius, radius, -PI, -0.5 * PI, false);\r\n\tctx.arc(left + width - radius, top + radius, radius, -0.5 * PI, 0, false);\r\n\tctx.arc(left + width - radius, top + height - radius, radius, 0, 0.5 * PI, false);\r\n\tctx.arc(left + radius, top + height - radius, radius, 0.5 * PI, PI, false);\r\n\tctx.closePath();\r\n}\r\nexport function fillRoundRect(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void {\r\n\troundRect(ctx, left, top, width, height, radius);\r\n\tctx.fill();\r\n}\r\nexport function strokeRoundRect(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void {\r\n\troundRect(ctx, left, top, width, height, radius);\r\n\tctx.stroke();\r\n}\r\nexport function fillCircle(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number): void {\r\n\tconst min = Math.min(width, height) / 2;\r\n\tctx.beginPath();\r\n\tctx.arc(left + min, top + min, min, 0, 2 * Math.PI);\r\n\tctx.closePath();\r\n\tctx.fill();\r\n}\r\nexport function strokeCircle(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number): void {\r\n\tconst min = Math.min(width, height) / 2;\r\n\tctx.beginPath();\r\n\tctx.arc(left + min, top + min, min, 0, 2 * Math.PI);\r\n\tctx.closePath();\r\n\tctx.stroke();\r\n}\r\n\r\nexport type FillTextRectOption = {\r\n  offset?: number;\r\n  padding?: PaddingOption;\r\n};\r\nexport function fillTextRect(ctx: CanvasRenderingContext2D, text: string, left: number, top: number, width: number, height: number, {offset = 2, padding}: FillTextRectOption = {}): void {\r\n\tconst rect = {\r\n\t\tleft,\r\n\t\ttop,\r\n\t\twidth,\r\n\t\theight,\r\n\t\tright: left + width,\r\n\t\tbottom: top + height\r\n\t};\r\n\tctx.save();\r\n\ttry {\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(rect.left, rect.top, rect.width, rect.height);\r\n\t\t//clip\r\n\t\tctx.clip();\r\n\r\n\t\t//\r\n\t\tconst pos = calcBasePosition(ctx, rect, {\r\n\t\t\toffset,\r\n\t\t\tpadding\r\n\t\t});\r\n\r\n\t\tctx.fillText(text, pos.x, pos.y);\r\n\t} finally {\r\n\t\tctx.restore();\r\n\t}\r\n}\r\n\r\nexport type DrawInlineImageRectOption = {\r\n  offset?: number;\r\n  padding?: PaddingOption;\r\n};\r\nexport function drawInlineImageRect(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\timage: CanvasImageSource,\r\n\t\tsrcLeft: number,\r\n\t\tsrcTop: number,\r\n\t\tsrcWidth: number,\r\n\t\tsrcHeight: number,\r\n\t\tdestWidth: number,\r\n\t\tdestHeight: number,\r\n\t\tleft: number,\r\n\t\ttop: number,\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\t{offset = 2, padding}: DrawInlineImageRectOption = {}\r\n): void {\r\n\tconst rect = {\r\n\t\tleft,\r\n\t\ttop,\r\n\t\twidth,\r\n\t\theight,\r\n\t\tright: left + width,\r\n\t\tbottom: top + height\r\n\t};\r\n\tctx.save();\r\n\ttry {\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(rect.left, rect.top, rect.width, rect.height);\r\n\t\t//clip\r\n\t\tctx.clip();\r\n\r\n\t\t//\r\n\t\tconst pos = calcStartPosition(ctx, rect, destWidth, destHeight, {\r\n\t\t\toffset,\r\n\t\t\tpadding\r\n\t\t});\r\n\r\n\t\tctx.drawImage(image, srcLeft, srcTop, srcWidth, srcHeight, pos.x, pos.y, destWidth, destHeight);\r\n\t} finally {\r\n\t\tctx.restore();\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns an object containing the width of the checkbox.\r\n * @param  {CanvasRenderingContext2D} ctx canvas context\r\n * @return {Object} Object containing the width of the checkbox\r\n * @memberof cheetahGrid.tools.canvashelper\r\n */\r\nexport function measureCheckbox(ctx: CanvasRenderingContext2D): {\r\n  width: number;\r\n} {\r\n\treturn {\r\n\t\twidth: getFontSize(ctx, null).width\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns an object containing the width of the radio button.\r\n * @param  {CanvasRenderingContext2D} ctx canvas context\r\n * @return {Object} Object containing the width of the radio button\r\n * @memberof cheetahGrid.tools.canvashelper\r\n */\r\nexport function measureRadioButton(ctx: CanvasRenderingContext2D): {\r\n  width: number;\r\n} {\r\n\treturn {\r\n\t\twidth: getFontSize(ctx, null).width\r\n\t};\r\n}\r\n\r\nexport type DrawCheckboxOption = {\r\n  uncheckBgColor?: ColorDef;\r\n  checkBgColor?: ColorDef;\r\n  borderColor?: ColorDef;\r\n  boxSize?: number;\r\n};\r\n/**\r\n * draw Checkbox\r\n * @param  {CanvasRenderingContext2D} ctx canvas context\r\n * @param  {number} x The x coordinate where to start drawing the checkbox (relative to the canvas)\r\n * @param  {number} y The y coordinate where to start drawing the checkbox (relative to the canvas)\r\n * @param  {boolean|number} check checkbox check status\r\n * @param  {object} option option\r\n * @return {void}\r\n * @memberof cheetahGrid.tools.canvashelper\r\n */\r\nexport function drawCheckbox(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\tcheck: number | boolean,\r\n\t\t{uncheckBgColor = '#FFF', checkBgColor = 'rgb(76, 73, 72)', borderColor = '#000', boxSize = measureCheckbox(ctx).width}: DrawCheckboxOption = {}\r\n): void {\r\n\tconst checkPoint = typeof check === 'number' ? (check > 1 ? 1 : check) : 1;\r\n\r\n\tctx.save();\r\n\ttry {\r\n\t\tctx.fillStyle = check ? checkBgColor : uncheckBgColor;\r\n\t\tconst leftX = ceil(x);\r\n\t\tconst topY = ceil(y);\r\n\t\tconst size = ceil(boxSize);\r\n\r\n\t\tfillRoundRect(ctx, leftX - 1, topY - 1, size + 1, size + 1, boxSize / 5);\r\n\t\tctx.lineWidth = 1;\r\n\t\tctx.strokeStyle = borderColor;\r\n\t\tstrokeRoundRect(ctx, leftX - 0.5, topY - 0.5, size, size, boxSize / 5);\r\n\t\tif (check) {\r\n\t\t\tctx.lineWidth = ceil(boxSize / 10);\r\n\t\t\tctx.strokeStyle = uncheckBgColor;\r\n\t\t\tlet leftWidth = boxSize / 4;\r\n\t\t\tlet rightWidth = (boxSize / 2) * 0.9;\r\n\t\t\tconst leftLeftPos = x + boxSize * 0.2;\r\n\t\t\tconst leftTopPos = y + boxSize / 2;\r\n\r\n\t\t\tif (checkPoint < 0.5) {\r\n\t\t\t\tleftWidth *= checkPoint * 2;\r\n\t\t\t}\r\n\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.moveTo(leftLeftPos, leftTopPos);\r\n\t\t\tctx.lineTo(leftLeftPos + leftWidth, leftTopPos + leftWidth);\r\n\t\t\tif (checkPoint > 0.5) {\r\n\t\t\t\tif (checkPoint < 1) {\r\n\t\t\t\t\trightWidth *= (checkPoint - 0.5) * 2;\r\n\t\t\t\t}\r\n\t\t\t\tctx.lineTo(leftLeftPos + leftWidth + rightWidth, leftTopPos + leftWidth - rightWidth);\r\n\t\t\t}\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t} finally {\r\n\t\tctx.restore();\r\n\t}\r\n}\r\n\r\nexport type DrawRadioButtonOption = {\r\n  checkColor?: ColorDef;\r\n  borderColor?: ColorDef;\r\n  bgColor?: ColorDef;\r\n  boxSize?: number;\r\n};\r\n/**\r\n * draw Radio button\r\n * @param  {CanvasRenderingContext2D} ctx canvas context\r\n * @param  {number} x The x coordinate where to start drawing the radio button (relative to the canvas)\r\n * @param  {number} y The y coordinate where to start drawing the radio button (relative to the canvas)\r\n * @param  {boolean|number} check radio button check status\r\n * @param  {object} option option\r\n * @return {void}\r\n * @memberof cheetahGrid.tools.canvashelper\r\n */\r\nexport function drawRadioButton(\r\n\t\tctx: CanvasRenderingContext2D,\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\tcheck: number | boolean,\r\n\t\t{checkColor = 'rgb(76, 73, 72)', borderColor = '#000', bgColor = '#FFF', boxSize = measureRadioButton(ctx).width}: DrawRadioButtonOption = {}\r\n): void {\r\n\tconst ratio = typeof check === 'number' ? (check > 1 ? 1 : check) : 1;\r\n\r\n\tctx.save();\r\n\ttry {\r\n\t\tctx.fillStyle = bgColor;\r\n\t\tconst leftX = ceil(x);\r\n\t\tconst topY = ceil(y);\r\n\t\tconst size = ceil(boxSize);\r\n\t\tfillCircle(ctx, leftX - 1, topY - 1, size + 1, size + 1);\r\n\r\n\t\tctx.lineWidth = 1;\r\n\t\tctx.strokeStyle = borderColor;\r\n\t\tstrokeCircle(ctx, leftX - 0.5, topY - 0.5, size, size);\r\n\t\tif (check) {\r\n\t\t\tconst checkSize = (size * ratio) / 2;\r\n\t\t\tconst padding = (size - checkSize) / 2;\r\n\t\t\tctx.fillStyle = checkColor;\r\n\t\t\tfillCircle(ctx, ceil((leftX - 0.5 + padding) * 100) / 100, ceil((topY - 0.5 + padding) * 100) / 100, ceil(checkSize * 100) / 100, ceil(checkSize * 100) / 100);\r\n\t\t}\r\n\t} finally {\r\n\t\tctx.restore();\r\n\t}\r\n}\r\n\r\nexport type DrawButtonOption = {\r\n  backgroundColor?: ColorDef;\r\n  bgColor?: ColorDef;\r\n  radius?: number;\r\n  shadow?: {\r\n    color?: string;\r\n    blur?: number;\r\n    offsetX?: number;\r\n    offsetY?: number;\r\n    offset?: { x?: number; y?: number };\r\n  };\r\n};\r\n/**\r\n * draw Button\r\n */\r\nexport function drawButton(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, option: DrawButtonOption = {}): void {\r\n\tconst {backgroundColor = '#FFF', bgColor = backgroundColor, radius = 4, shadow = {}} = option;\r\n\tctx.save();\r\n\ttry {\r\n\t\tctx.fillStyle = bgColor;\r\n\r\n\t\tif (shadow) {\r\n\t\t\tconst {color = 'rgba(0, 0, 0, 0.24)', blur = 1, offsetX = 0, offsetY = 2, offset: {x: ox = offsetX, y: oy = offsetY} = {}} = shadow;\r\n\t\t\tctx.shadowColor = color;\r\n\t\t\tctx.shadowBlur = blur; //\r\n\t\t\tctx.shadowOffsetX = ox;\r\n\t\t\tctx.shadowOffsetY = oy;\r\n\t\t}\r\n\r\n\t\tfillRoundRect(ctx, ceil(left), ceil(top), ceil(width), ceil(height), radius);\r\n\t} finally {\r\n\t\tctx.restore();\r\n\t}\r\n}\r\nexport const canvasHelper = {\r\n\tdrawButton,\r\n\tdrawCheckbox,\r\n\tdrawInlineImageRect,\r\n\tdrawRadioButton,\r\n\tfillRoundRect,\r\n\tfillTextRect,\r\n\tmeasureCheckbox,\r\n\tmeasureRadioButton,\r\n\troundRect,\r\n\tstrokeColorsRect,\r\n\tstrokeRoundRect,\r\n\tfillCircle,\r\n\tstrokeCircle\r\n};\r\nexport type CanvasHelper = {\r\n  roundRect: typeof roundRect;\r\n  fillRoundRect: typeof fillRoundRect;\r\n  strokeRoundRect: typeof strokeRoundRect;\r\n  drawCheckbox: typeof drawCheckbox;\r\n  measureCheckbox: typeof measureCheckbox;\r\n  fillTextRect: typeof fillTextRect;\r\n  drawButton: typeof drawButton;\r\n  drawInlineImageRect: typeof drawInlineImageRect;\r\n  strokeColorsRect: typeof strokeColorsRect;\r\n};\r\n","import Svg from './Svg'\r\n\r\nconst ELEMENT_NODE = 1\r\n\r\nfunction polygonToPath(polygon: Element) {\r\n\tconst points = polygon.getAttribute('points')\r\n\treturn `M${ points }z`\r\n}\r\n\r\nfunction polylineToPath(polyline: Element) {\r\n\tconst points = polyline.getAttribute('points')\r\n\treturn `M${ points }`\r\n}\r\n\r\nfunction circleToPath(circle: Element) {\r\n\tconst cx = Number(circle.getAttribute('cx'))\r\n\tconst cy = Number(circle.getAttribute('cy'))\r\n\tconst r = Number(circle.getAttribute('r'))\r\n\r\n\t// https://tyru.github.io/svg-circle-misc-algorithm/\r\n\tconst SEGMENTS = 8\r\n\tconst ANGLE = (2 * Math.PI) / SEGMENTS\r\n\tconst anchorX = (theta: number) => r * Math.cos(theta)\r\n\tconst anchorY = (theta: number) => r * Math.sin(theta)\r\n\tconst controlX = (theta: number) => anchorX(theta) + r * Math.tan(ANGLE / 2) * Math.cos(theta - Math.PI / 2)\r\n\tconst controlY = (theta: number) => anchorY(theta) + r * Math.tan(ANGLE / 2) * Math.sin(theta - Math.PI / 2)\r\n\r\n\tlet paths = `M${ cx + r } ${ cy }`\r\n\tfor (let index = 1; index <= SEGMENTS; index++) {\r\n\t\tconst theta = index * ANGLE\r\n\t\tpaths += `Q${ controlX(theta) + cx } ${ controlY(theta) + cy } ${ anchorX(theta) + cx } ${ anchorY(theta) + cy }`\r\n\t}\r\n\treturn paths\r\n}\r\n\r\nfunction getD(path: Element) {\r\n\tconst fill = path.getAttribute('fill')\r\n\tif (fill === 'none') {\r\n\t\treturn ''\r\n\t}\r\n\treturn (path.getAttribute('d') as string).replace(/[\\n\\r]/g, '')\r\n}\r\n\r\nfunction elementToPaths(el: Element) {\r\n\tlet path = ''\r\n\tswitch (el.tagName.toLowerCase()) {\r\n\tcase 'path':\r\n\tcase 'glyph':\r\n\t\tpath = getD(el)\r\n\t\tbreak\r\n\tcase 'circle':\r\n\t\tpath = circleToPath(el)\r\n\t\tbreak\r\n\tcase 'polygon':\r\n\t\tpath = polygonToPath(el)\r\n\t\tbreak\r\n\tcase 'polyline':\r\n\t\tpath = polylineToPath(el)\r\n\t\tbreak\r\n\tcase 'g':\r\n\t\tfor (let i = 0; i < el.childNodes.length; i++) {\r\n\t\t\tconst child = el.childNodes[i]\r\n\t\t\tif (child.nodeType !== ELEMENT_NODE) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif (!(child as Element).getAttribute('fill')) {\r\n\t\t\t\t(child as Element).setAttribute('fill', el.getAttribute('fill') as string)\r\n\t\t\t}\r\n\t\t\tpath += elementToPaths(child as Element)\r\n\t\t}\r\n\t\tbreak\r\n\tdefault:\r\n\t\twindow.console.warn(`unsupported:${ el.tagName }`, `@ ${ el.innerHTML }`)\r\n\t}\r\n\treturn path\r\n}\r\n\r\nfunction buildObject(\r\n\t\tobj: {\r\n        offsetX?: number;\r\n        offsetY?: number;\r\n        width?: number;\r\n        height?: number;\r\n        d?: string;\r\n        isGlyph?: boolean;\r\n        html?: string;\r\n    } = {}\r\n) {\r\n\tconst icon: {\r\n        d: string;\r\n        height: number;\r\n        width: number;\r\n        html: string;\r\n        ud?: boolean; // upside Down\r\n        offsetX?: number;\r\n        offsetY?: number;\r\n    } = {\r\n    \td: obj.d || '',\r\n    \thtml: obj.html || '',\r\n    \theight: obj.height || 0,\r\n    \twidth: obj.width || 0\r\n    }\r\n\tif (obj.isGlyph) {\r\n\t\ticon.ud = true\r\n\t}\r\n\tif (obj.offsetX !== undefined) {\r\n\t\ticon.offsetX = obj.offsetX\r\n\t}\r\n\tif (obj.offsetY !== undefined) {\r\n\t\ticon.offsetY = obj.offsetY\r\n\t}\r\n\treturn icon\r\n}\r\n\r\nfunction glyphToJSON(\r\n\t\tsvgCode: string,\r\n\t\topt: {\r\n        glyphName?: string;\r\n        unicode?: string;\r\n    }\r\n) {\r\n\tconst svg = new Svg(svgCode)\r\n\r\n\tfunction findGlyph() {\r\n\t\tif (opt.glyphName) {\r\n\t\t\treturn svg.findGlyph(opt.glyphName)\r\n\t\t} else if (opt.unicode) {\r\n\t\t\treturn svg.findGlyphByUnicode(opt.unicode)\r\n\t\t}\r\n\t}\r\n\r\n\tconst fontFace = svg.fontFaceElement || {\r\n\t\tgetAttribute(qualifiedName: string) {\r\n\t\t\treturn null\r\n\t\t}\r\n\t}\r\n\tconst font = svg.fontElement || {\r\n\t\tgetAttribute(qualifiedName: string) {\r\n\t\t\treturn null\r\n\t\t}\r\n\t}\r\n\tconst glyph = findGlyph() as Element\r\n\t// xyxy\r\n\t// const bbox = (fontFace.getAttribute(\"bbox\") || \"\").split(\" \");\r\n\t// bbox.st = {\r\n\t// \tx: bbox[0] - 0,\r\n\t// \ty: bbox[1] - 0,\r\n\t// };\r\n\t// bbox.ed = {\r\n\t// \tx: bbox[2] - 0,\r\n\t// \ty: bbox[3] - 0,\r\n\t// };\r\n\r\n\tconst fontHorizAdvX = Number(font.getAttribute('horiz-adv-x')) || 0\r\n\tconst fontVertAdvX = Number(font.getAttribute('vert-adv-x')) || 0\r\n\tconst horizAdvX = Number(glyph.getAttribute('horiz-adv-x')) || fontHorizAdvX || 0\r\n\tconst vertAdvX = Number(glyph.getAttribute('vert-adv-x')) || fontVertAdvX || 0\r\n\r\n\tconst unitsPerEm = Number(fontFace.getAttribute('units-per-em')) || 1000\r\n\t// const ascent = Number(fontFace.getAttribute(\"ascent\")) || (unitsPerEm - vertAdvX);\r\n\tconst descent = Number(fontFace.getAttribute('descent')) || vertAdvX\r\n\r\n\tlet size = unitsPerEm\r\n\tconst contentSize = {\r\n\t\theight: vertAdvX || unitsPerEm,\r\n\t\twidth: horizAdvX || unitsPerEm\r\n\t}\r\n\tif (horizAdvX > size) {\r\n\t\tsize = horizAdvX\r\n\t}\r\n\tif (vertAdvX > size) {\r\n\t\tsize = vertAdvX\r\n\t}\r\n\r\n\tlet offsetX = 0 // -bbox.st.x || 0;\r\n\tlet offsetY = -descent\r\n\toffsetX += Math.round((size - contentSize.width) / 2)\r\n\toffsetY += Math.round((size - contentSize.height) / 2)\r\n\r\n\tconst d = elementToPaths(glyph)\r\n\r\n\treturn buildObject({\r\n\t\td,\r\n\t\theight: size,\r\n\t\thtml: glyph.outerHTML,\r\n\t\tisGlyph: true,\r\n\t\toffsetX,\r\n\t\toffsetY,\r\n\t\twidth: size\r\n\t})\r\n}\r\n\r\nfunction svgToJSON(svgCode: string) {\r\n\tconst { svg } = new Svg(svgCode)\r\n\tconst viewBox = (svg.getAttribute('viewBox') || '').split(' ')\r\n\tconst width = Number(svg.getAttribute('width') || viewBox[2]) || 0\r\n\tconst height = Number(svg.getAttribute('height') || viewBox[3]) || 0\r\n\tconst offsetX = 0 - Number(viewBox[0]) || 0\r\n\tconst offsetY = 0 - Number(viewBox[1]) || 0\r\n\r\n\tlet d = ''\r\n\tfor (let i = 0; i < svg.childNodes.length; i++) {\r\n\t\tconst el = svg.childNodes[i]\r\n\t\tif (el.nodeType !== ELEMENT_NODE) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\td += elementToPaths(el as Element)\r\n\t}\r\n\treturn buildObject({\r\n\t\td,\r\n\t\theight,\r\n\t\thtml: svgCode,\r\n\t\toffsetX,\r\n\t\toffsetY,\r\n\t\twidth\r\n\t})\r\n}\r\n\r\nconst svgToIcon = (\r\n\t\tsvgCode: string,\r\n\t\topt: {\r\n        glyphName?: string;\r\n        unicode?: string;\r\n    } = {}\r\n) => {\r\n\tif (opt.glyphName || opt.unicode) {\r\n\t\treturn glyphToJSON(svgCode, opt)\r\n\t} else {\r\n\t\treturn svgToJSON(svgCode)\r\n\t}\r\n}\r\n\r\nexport default svgToIcon\r\n","import type {ListGridAPI} from '../ts-types';\r\nimport type {TooltipElement} from './internal/TooltipElement';\r\n\r\nexport abstract class BaseTooltip<T> {\r\n  private _grid: ListGridAPI<T>;\r\n\r\n  private _tooltipElement?: TooltipElement<T>;\r\n\r\n  constructor(grid: ListGridAPI<T>) {\r\n  \tthis._grid = grid;\r\n  }\r\n\r\n  dispose(): void {\r\n  \tthis.detachTooltipElement();\r\n  \tif (this._tooltipElement) {\r\n  \t\tthis._tooltipElement.dispose();\r\n  \t}\r\n  \tthis._tooltipElement = undefined;\r\n  }\r\n\r\n  private _getTooltipElement(): TooltipElement<T> {\r\n  \tif (this._tooltipElement) {\r\n  \t\treturn this._tooltipElement;\r\n  \t}\r\n  \treturn (this._tooltipElement = this.createTooltipElementInternal());\r\n  }\r\n\r\n  abstract createTooltipElementInternal(): TooltipElement<T>;\r\n\r\n  attachTooltipElement(col: number, row: number, content: string): void {\r\n  \tconst tooltipElement = this._getTooltipElement();\r\n  \ttooltipElement.attach(this._grid, col, row, content);\r\n  }\r\n\r\n  moveTooltipElement(col: number, row: number): void {\r\n  \tconst tooltipElement = this._getTooltipElement();\r\n  \ttooltipElement.move(this._grid, col, row);\r\n  }\r\n\r\n  detachTooltipElement(): void {\r\n  \tconst tooltipElement = this._getTooltipElement();\r\n  \ttooltipElement._detach();\r\n  }\r\n}\r\n","import {BaseTooltip} from './BaseTooltip';\r\nimport {TooltipElement} from './internal/TooltipElement';\r\n\r\nexport class Tooltip<T> extends BaseTooltip<T> {\r\n\tcreateTooltipElementInternal(): TooltipElement<T> {\r\n\t\treturn new TooltipElement();\r\n\t}\r\n}\r\n","import type {CellRange, ListGridAPI} from '../ts-types';\r\nimport type {BaseTooltip} from './BaseTooltip';\r\nimport {LG_EVENT_TYPE} from '../list-grid/LG_EVENT_TYPE';\r\nimport {Tooltip} from './Tooltip';\r\nimport {cellInRange} from '../internal/utils';\r\n\r\nconst TOOLTIP_INSTANCE_FACTORY = {\r\n\t'overflow-text'<T>(grid: ListGridAPI<T>): BaseTooltip<T> {\r\n\t\treturn new Tooltip(grid);\r\n\t}\r\n};\r\n\r\nfunction getTooltipInstanceInfo<T>(\r\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n\t\tgrid: ListGridAPI<T>,\r\n\t\tcol: number,\r\n\t\trow: number\r\n): {\r\n    type: 'overflow-text';\r\n    content: string;\r\n  } | null {\r\n\t//\r\n\t// overflow text tooltip\r\n\tconst overflowText = grid.getCellOverflowText(col, row);\r\n\tif (overflowText) {\r\n\t\treturn {\r\n\t\t\ttype: 'overflow-text',\r\n\t\t\tcontent: overflowText\r\n\t\t};\r\n\t}\r\n\treturn null;\r\n}\r\n\r\ntype AttachInfo<T> = {\r\n  instance: BaseTooltip<T>;\r\n  range: CellRange;\r\n};\r\n\r\nexport class TooltipHandler<T> {\r\n  private _grid: ListGridAPI<T>;\r\n\r\n  private _tooltipInstances: { [type: string]: BaseTooltip<T> };\r\n\r\n  private _attachInfo?: AttachInfo<T> | null;\r\n\r\n  constructor(grid: ListGridAPI<T>) {\r\n  \tthis._grid = grid;\r\n  \tthis._tooltipInstances = {};\r\n  \tthis._bindGridEvent(grid);\r\n  }\r\n\r\n  dispose(): void {\r\n  \tconst tooltipInstances = this._tooltipInstances;\r\n  \tfor (const k in tooltipInstances) {\r\n  \t\ttooltipInstances[k].dispose();\r\n  \t}\r\n  \tdelete this._tooltipInstances;\r\n  \tthis._attachInfo = null;\r\n  }\r\n\r\n  _attach(col: number, row: number): void {\r\n  \tconst info = this._attachInfo;\r\n  \tconst instanceInfo = this._getTooltipInstanceInfo(col, row);\r\n  \tif (info && (!instanceInfo || info.instance !== instanceInfo.instance)) {\r\n  \t\tinfo.instance.detachTooltipElement();\r\n  \t\tthis._attachInfo = null;\r\n  \t}\r\n  \tif (!instanceInfo) {\r\n  \t\treturn;\r\n  \t}\r\n  \tconst {instance} = instanceInfo;\r\n  \tinstance.attachTooltipElement(col, row, instanceInfo.content);\r\n  \tconst range = this._grid.getCellRange(col, row);\r\n  \tthis._attachInfo = {range, instance};\r\n  }\r\n\r\n  _move(col: number, row: number): void {\r\n  \tconst info = this._attachInfo;\r\n  \tif (!info || !cellInRange(info.range, col, row)) {\r\n  \t\treturn;\r\n  \t}\r\n  \tconst {instance} = info;\r\n  \tinstance.moveTooltipElement(col, row);\r\n  }\r\n\r\n  _detach(): void {\r\n  \tconst info = this._attachInfo;\r\n  \tif (!info) {\r\n  \t\treturn;\r\n  \t}\r\n  \tconst {instance} = info;\r\n  \tinstance.detachTooltipElement();\r\n  \tthis._attachInfo = null;\r\n  }\r\n\r\n  _isAttachCell(col: number, row: number): boolean {\r\n  \tconst info = this._attachInfo;\r\n  \tif (!info) {\r\n  \t\treturn false;\r\n  \t}\r\n  \treturn cellInRange(info.range, col, row);\r\n  }\r\n\r\n  _bindGridEvent(grid: ListGridAPI<T>): void {\r\n  \tgrid.listen(LG_EVENT_TYPE.MOUSEOVER_CELL, (e) => {\r\n  \t\tif (e.related) {\r\n  \t\t\tif (this._isAttachCell(e.col, e.row)) {\r\n  \t\t\t\treturn;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthis._attach(e.col, e.row);\r\n  \t});\r\n  \tgrid.listen(LG_EVENT_TYPE.MOUSEOUT_CELL, (e) => {\r\n  \t\tif (e.related) {\r\n  \t\t\tif (this._isAttachCell(e.related.col, e.related.row)) {\r\n  \t\t\t\treturn;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthis._detach();\r\n  \t});\r\n  \tgrid.listen(LG_EVENT_TYPE.SELECTED_CELL, (e) => {\r\n  \t\tif (this._isAttachCell(e.col, e.row)) {\r\n  \t\t\tthis._detach();\r\n  \t\t}\r\n  \t});\r\n  \tgrid.listen(LG_EVENT_TYPE.SCROLL, () => {\r\n  \t\tconst info = this._attachInfo;\r\n  \t\tif (!info) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tthis._move(info.range.start.col, info.range.start.row);\r\n  \t});\r\n  \tgrid.listen(LG_EVENT_TYPE.CHANGED_VALUE, (e) => {\r\n  \t\tif (this._isAttachCell(e.col, e.row)) {\r\n  \t\t\tthis._detach();\r\n  \t\t\tthis._attach(e.col, e.row);\r\n  \t\t}\r\n  \t});\r\n  }\r\n\r\n  _getTooltipInstanceInfo(\r\n  \t\tcol: number,\r\n  \t\trow: number\r\n  ): {\r\n      instance: Tooltip<T>;\r\n      type: string;\r\n      content: string;\r\n    } | null {\r\n  \tconst grid = this._grid;\r\n  \tconst tooltipInstances = this._tooltipInstances;\r\n  \tconst info = getTooltipInstanceInfo(grid, col, row);\r\n  \tif (!info) {\r\n  \t\treturn null;\r\n  \t}\r\n  \tconst {type} = info;\r\n  \tconst instance = tooltipInstances[type] || (tooltipInstances[type] = TOOLTIP_INSTANCE_FACTORY[type](grid));\r\n  \treturn {\r\n  \t\tinstance,\r\n  \t\ttype,\r\n  \t\tcontent: info.content\r\n  \t};\r\n  }\r\n}\r\n","import {EventHandler} from '../../internal/EventHandler';\r\nimport type {ListGridAPI} from '../../ts-types';\r\nimport {createElement} from '../../internal/dom';\r\n\r\nconst CLASSNAME = 'cheetah-grid__tooltip-element';\r\nconst CONTENT_CLASSNAME = `${CLASSNAME}__content`;\r\nconst HIDDEN_CLASSNAME = `${CLASSNAME}--hidden`;\r\nconst SHOWN_CLASSNAME = `${CLASSNAME}--shown`;\r\nimport './TooltipElement.css';\r\n\r\nfunction createTooltipDomElement(): HTMLElement {\r\n\t// require('@/tooltip/internal/TooltipElement.css')\r\n\tconst rootElement = createElement('div', {\r\n\t\tclassList: [CLASSNAME, HIDDEN_CLASSNAME]\r\n\t});\r\n\tconst messageElement = createElement('pre', {\r\n\t\tclassList: [CONTENT_CLASSNAME]\r\n\t});\r\n\trootElement.appendChild(messageElement);\r\n\treturn rootElement;\r\n}\r\n\r\nexport class TooltipElement<T> {\r\n  private _handler: EventHandler\r\n\r\n  private _rootElement: HTMLElement\r\n\r\n  private _messageElement: HTMLElement\r\n\r\n  constructor() {\r\n  \tthis._handler = new EventHandler();\r\n  \tconst rootElement = (this._rootElement = createTooltipDomElement());\r\n  \tthis._messageElement = rootElement.querySelector(`.${CONTENT_CLASSNAME}`) as HTMLElement;\r\n  }\r\n\r\n  dispose(): void {\r\n  \tthis.detach();\r\n\r\n  \tconst rootElement = this._rootElement;\r\n  \tif (rootElement.parentElement) {\r\n  \t\trootElement.parentElement.removeChild(rootElement);\r\n  \t}\r\n\r\n  \tthis._handler.dispose();\r\n  \t// @ts-expect-error -- ignore\r\n  \tdelete this._rootElement;\r\n  \tdelete this._messageElement;\r\n  }\r\n\r\n  attach(grid: ListGridAPI<T>, col: number, row: number, content: string): void {\r\n  \tconst rootElement = this._rootElement;\r\n  \tconst messageElement = this._messageElement;\r\n\r\n  \trootElement.classList.remove(SHOWN_CLASSNAME);\r\n  \trootElement.classList.add(HIDDEN_CLASSNAME);\r\n\r\n  \tif (this._attachCell(grid, col, row)) {\r\n  \t\trootElement.classList.add(SHOWN_CLASSNAME);\r\n  \t\trootElement.classList.remove(HIDDEN_CLASSNAME);\r\n\r\n  \t\tmessageElement.textContent = content;\r\n  \t} else {\r\n  \t\tthis._detach();\r\n  \t}\r\n  }\r\n\r\n  move(grid: ListGridAPI<T>, col: number, row: number): void {\r\n  \tconst rootElement = this._rootElement;\r\n  \tif (this._attachCell(grid, col, row)) {\r\n  \t\trootElement.classList.add(SHOWN_CLASSNAME);\r\n  \t\trootElement.classList.remove(HIDDEN_CLASSNAME);\r\n  \t} else {\r\n  \t\tthis._detach();\r\n  \t}\r\n  }\r\n\r\n  detach(): void {\r\n  \tthis._detach();\r\n  }\r\n\r\n  _detach(): void {\r\n  \tconst rootElement = this._rootElement;\r\n  \tif (rootElement.parentElement) {\r\n  \t\t// rootElement.parentElement.removeChild(rootElement);\r\n  \t\trootElement.classList.remove(SHOWN_CLASSNAME);\r\n  \t\trootElement.classList.add(HIDDEN_CLASSNAME);\r\n  \t}\r\n  }\r\n\r\n  _attachCell(grid: ListGridAPI<T>, col: number, row: number): boolean {\r\n  \tconst rootElement = this._rootElement;\r\n  \tconst {element, rect} = grid.getAttachCellsArea(grid.getCellRange(col, row));\r\n\r\n  \tconst {bottom: top, left, width} = rect;\r\n  \tconst {frozenRowCount, frozenColCount} = grid;\r\n  \tif (row >= frozenRowCount && frozenRowCount > 0) {\r\n  \t\tconst {rect: frozenRect} = grid.getAttachCellsArea(grid.getCellRange(col, frozenRowCount - 1));\r\n  \t\tif (top < frozenRect.bottom) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t} else {\r\n  \t\tif (top < 0) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t}\r\n  \tif (col >= frozenColCount && frozenColCount > 0) {\r\n  \t\tconst {rect: frozenRect} = grid.getAttachCellsArea(grid.getCellRange(frozenColCount - 1, row));\r\n  \t\tif (left < frozenRect.right) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t} else {\r\n  \t\tif (left < 0) {\r\n  \t\t\treturn false; //\r\n  \t\t}\r\n  \t}\r\n  \tconst {offsetHeight, offsetWidth} = element;\r\n  \tif (offsetHeight < top) {\r\n  \t\treturn false; //\r\n  \t}\r\n  \tif (offsetWidth < left) {\r\n  \t\treturn false; //\r\n  \t}\r\n\r\n  \trootElement.style.top = `${top.toFixed()}px`;\r\n  \trootElement.style.left = `${(left + width / 2).toFixed()}px`;\r\n  \trootElement.style.minWidth = `${width.toFixed()}px`;\r\n  \tif (rootElement.parentElement !== element) {\r\n  \t\telement.appendChild(rootElement);\r\n  \t}\r\n  \treturn true;\r\n  }\r\n}\r\n","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij48cGF0aCBkPSJNMzggMjZIMjZ2MTJoLTRWMjZIMTB2LTRoMTJWMTBoNHYxMmgxMnY0eiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij48cGF0aCBmaWxsPSIjMDEwMTAxIiBkPSJNNDAgMjRsLTIuODItMi44MkwyNiAzMi4zNFY4aC00djI0LjM0TDEwLjg0IDIxLjE2IDggMjRsMTYgMTYgMTYtMTZ6Ii8+PC9zdmc+\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij48cGF0aCBkPSJNOCAyNGwyLjgzIDIuODNMMjIgMTUuNjZWNDBoNFYxNS42NmwxMS4xNyAxMS4xN0w0MCAyNCAyNCA4IDggMjR6Ii8+PC9zdmc+\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4Ij48cGF0aCBkPSJNNiAzNC41VjQyaDcuNWwyMi4xMy0yMi4xMy03LjUtNy41TDYgMzQuNXptMzUuNDEtMjAuNDFjLjc4LS43OC43OC0yLjA1IDAtMi44M2wtNC42Ny00LjY3Yy0uNzgtLjc4LTIuMDUtLjc4LTIuODMgMGwtMy42NiAzLjY2IDcuNSA3LjUgMy42Ni0zLjY2eiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgMTcuMjdMMTguMTggMjFsLTEuNjQtNy4wM0wyMiA5LjI0bC03LjE5LS42MUwxMiAyIDkuMTkgOC42MyAyIDkuMjRsNS40NiA0LjczTDUuODIgMjF6Ii8+PC9zdmc+\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMjIgOS4yNGwtNy4xOS0uNjJMMTIgMiA5LjE5IDguNjMgMiA5LjI0bDUuNDYgNC43M0w1LjgyIDIxIDEyIDE3LjI3IDE4LjE4IDIxbC0xLjYzLTcuMDNMMjIgOS4yNHpNMTIgMTUuNGwtMy43NiAyLjI3IDEtNC4yOC0zLjMyLTIuODggNC4zOC0uMzhMMTIgNi4xbDEuNzEgNC4wNCA0LjM4LjM4LTMuMzIgMi44OCAxIDQuMjhMMTIgMTUuNHoiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMjIgOS4yNGwtNy4xOS0uNjJMMTIgMiA5LjE5IDguNjMgMiA5LjI0bDUuNDYgNC43M0w1LjgyIDIxIDEyIDE3LjI3IDE4LjE4IDIxbC0xLjYzLTcuMDNMMjIgOS4yNHpNMTIgMTUuNFY2LjFsMS43MSA0LjA0IDQuMzguMzgtMy4zMiAyLjg4IDEgNC4yOEwxMiAxNS40eiIvPjwvc3ZnPg==\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// // import type * as TYPES from './ts-types'\r\n// import { IconDefine } from './ts-types'\r\n// import * as columns from './columns'\r\n// import * as core from './core'\r\n// import * as data from './data'\r\n// import * as headers from './headers'\r\n// import * as icons from './icons'\r\n// import * as register from './register'\r\n// import * as themes from './themes'\r\n// import * as tools from './tools'\r\n// import {\r\n//     ColumnDefine,\r\n//     GroupHeaderDefine,\r\n//     HeaderDefine,\r\n//     HeadersDefine,\r\n//     ListGrid,\r\n//     ListGridConstructorOptions\r\n// } from './ListGrid'\r\n// import { GridCanvasHelper } from './GridCanvasHelper'\r\n// import type { Theme } from './themes/theme'\r\n//\r\n// export { getInternal as _getInternal } from './get-internal'\r\n\r\nimport { IconDefine } from './ts-types'\r\nimport { columns as _columns } from './columns'\r\nimport { core as _core } from './core'\r\nimport { tools as _tools } from './tools'\r\nimport { ListGrid as _ListGrid } from './ListGrid'\r\nimport { data as _data } from './data'\r\nimport { headers as _headers } from './headers'\r\nimport { themes as _themes } from './themes'\r\nimport { GridCanvasHelper as _GridCanvasHelper } from './GridCanvasHelper'\r\nimport { register as _register } from './register'\r\nimport { svgIcons } from './icons'\r\n\r\nconst kakaGrid = {\r\n\tversion: '1.0.1',\r\n\tcore: _core,\r\n\ttools: _tools,\r\n\r\n\t// impl Grids\r\n\tListGrid: _ListGrid,\r\n\r\n\t// objects\r\n\tcolumns: _columns,\r\n\tdata: _data,\r\n\theaders: _headers,\r\n\tthemes: _themes,\r\n\r\n\t// helper\r\n\tGridCanvasHelper: _GridCanvasHelper,\r\n\tget icons() {\r\n\t\treturn svgIcons.get()\r\n\t},\r\n\r\n\t// plugin registers\r\n\tregister: _register\r\n}\r\nexport default kakaGrid\r\n//\r\n//\r\n// export {\r\n//     core,\r\n//     tools,\r\n//     // impl Grids\r\n//     ListGrid,\r\n//     // ListGrid types\r\n//     ListGridConstructorOptions,\r\n//     HeadersDefine,\r\n//     ColumnDefine,\r\n//     HeaderDefine,\r\n//     GroupHeaderDefine,\r\n//     // objects\r\n//     columns,\r\n//     headers,\r\n//     themes,\r\n//     data,\r\n//     // helper\r\n//     GridCanvasHelper,\r\n//     readonly icons:{\r\n// [key: string]:IconDefine\r\n// },\r\n//     // getIcons,\r\n//     register\r\n// }\r\n//\r\n// /!*function getIcons(): { [key: string]: TYPES.IconDefine } {\r\n//     return icons.get()\r\n// }*!/\r\n//\r\n// export default {\r\n//     core,\r\n//     tools,\r\n//     // impl Grids\r\n//     ListGrid,\r\n//     // objects\r\n//     columns,\r\n//     headers,\r\n//     themes,\r\n//     data,\r\n//     // helper\r\n//     GridCanvasHelper,\r\n//     //plugin registers\r\n//     register,\r\n//     get icons(): { [key: string]: TYPES.IconDefine } {\r\n//         return getIcons()\r\n//     }\r\n// }\r\n//\r\n"],"names":[],"sourceRoot":""}